/// This file contains the trusted interface `TrustedNotary` of the
/// notary service. Since it's a trusted file, an auditor must read
/// and check it; it's not sufficient to just verify it.
///
/// To use the trusted notary from C#, compile this Dafny code to C#
/// then invoke the `TrustedNotary` methods from the C# code.
///
/// To set up a new notary with a new file, use code like the following:
///
/// ```
/// var requiredFileSize = TrustedNotaryModule.TrustedNotary.GetRequiredFileSize();
/// var fileHandle = PersistentMemoryModule.PersistentMemoryRegion.Create(ps.FileName, requiredFileSize);
/// var perm = new PermissionToControlWritesToPersistentMemory();
/// var success = TrustedNotaryModule.TrustedNotary.Setup(fileHandle, perm);
/// if (success) {
///     Console.WriteLine("Notary Server file set up successfully.");
/// }
/// else {
///     Console.WriteLine("Notary Server file setup failed.");
/// }
/// ```
///
/// To start up a notary with an existing file (after setup or after a
/// crash), use code like the following:
///
/// ```
/// var fileHandle = new PersistentMemoryModule.PersistentMemoryRegion(ps.FileName);
/// var perm = new PermissionToControlWritesToPersistentMemory();
/// var trustedNotary = TrustedNotaryModule.TrustedNotary.Start(fileHandle, perm);
/// if (trustedNotary != null) {
///     Console.WriteLine("Notary Server started successfully.");
/// }
/// else {
///     Console.WriteLine("Notary Server failed to start.");
/// }
/// ```
///
/// To use a trusted notary, call the methods `ExtractPublicKey`,
/// `Advance`, `Sign`, `ReadCounter`, and `ReadMessage`, e.g., with:
///
/// ```
/// var publicKey = notaryServer.ExtractPublicKey();
/// var message = new byte[32];
/// var rng = new Random();
/// rng.NextBytes(message);
/// var success = notaryServer.Advance(message);
/// var signature = notaryServer.Sign();
/// var counter = notaryServer.ReadCounter();
/// ```
///
/// A signature generated by the notary can be checked using only the
/// public key, e.g., with the following code:
///
/// ```
/// using System.Buffers.Binary;
/// using System.Security.Cryptography;
/// ...
/// byte[] data = new byte[8 + message.Length];
/// BinaryPrimitives.WriteUInt64BigEndian(new Span<byte>(data, 0, 8), counter);
/// message.CopyTo(data, 8);
/// var rsa = RSA.Create();
/// rsa.ImportRSAPublicKey(publicKey, out _);
/// var verified = rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
/// ```

include "../Framework/ExternalMethods_t.dfy"
include "../Framework/NativeTypes_t.dfy"
include "../Framework/PersistentMemory_t.dfy"
include "NotarySpec_t.dfy"
include "UntrustedNotary_v.dfy"

module TrustedNotaryModule {
import opened ExternalMethodsModule
import opened NativeTypesModule
import opened NotarySpecModule
import opened PersistentMemoryModule
import opened UntrustedNotaryModule

/// This is the class for objects implementing a trusted notary
/// service. It wraps the untrusted notary `UntrustedNotary` using
/// the PoWER approach to ensuring crash consistency. That is, it
/// ensures that all untrusted writes result in legal crash states no
/// matter what subset of the written chunks get persisted before the
/// next crash or flush.
class TrustedNotary
{
    var pmem: PersistentMemoryRegion                      // the persistent-memory region available for storage
    var impl: UntrustedNotary                             // the untrusted (but verified) notary doing the work
    var perm: PermissionToControlWritesToPersistentMemory // permission the trusted notary is given so that it can
                                                          //     dynamically change the PoWER permissions

    // This static method returns the minimum number of bytes it needs in persistent memory.
    static method GetRequiredFileSize() returns (result: int64)
    {
        return 1200 + UntrustedNotary.SPACE_NEEDED_NOT_INCLUDING_KEY as int64;
    }

    // This predicate indicates whether this object is valid. All
    // methods of this function will create and maintain validity.
    ghost predicate Valid()
        reads this
        reads pmem
        reads impl
        reads impl.Repr()
    {
        && pmem.Valid()
        && impl.Valid(pmem.View())        // We don't care what the untrusted implementation's invariant is;
                                         //     we just make sure to maintain it.
        && pmem !in impl.Repr()             // We don't care what parts of the heap the implementation uses;
                                         //      we just make sure the persistent memory isn't part of it.
        && UntrustedNotary.Recover(pmem.View().durableState).Some? // We rely on the untrusted notary to maintain the
                                                                  //    invariant that its recovery routine (whatever
                                                                  //    it is) will succeed after a crash
    }

    static ghost predicate TriggerState(s: seq<byte>)
    {
        true
    }

    // This is the constructor for a `TrustedNotary`. It's intended only for internal use.
    constructor(
        i_pmem: PersistentMemoryRegion,
        i_impl: UntrustedNotary,
        i_perm: PermissionToControlWritesToPersistentMemory
    )
        ensures this.pmem == i_pmem
        ensures this.impl == i_impl
        ensures this.perm == i_perm
    {
        this.pmem := i_pmem;
        this.impl := i_impl;
        this.perm := i_perm;
    }

    // This function provides the current abstract view of the notary service.
    ghost function View() : NotaryServerState
        reads this
        reads pmem
        reads impl
        reads impl.Repr()
        requires Valid()
    {
        UntrustedNotary.Recover(pmem.View().durableState).value
    }

    // This method sets up the notary service on a given
    // persistent-memory region, overwriting its contents. It requires
    // an input parameter of type
    // `PermissionToControlWritesToPersistentMemory` to enable it to
    // dynamically change the write permissions on the region. It
    // returns a boolean indicating whether setup was successful. The
    // postcondition ensures conformance to the specification for
    // notary service initialization, given by `SetupCorrect` in
    // `NotarySpec_t.dfy`.
    static method Setup(pmem: PersistentMemoryRegion, perm: PermissionToControlWritesToPersistentMemory)
                       returns (success: bool)
        requires pmem.Valid()
        modifies pmem
        ensures  pmem.Valid()
        ensures  SetupCorrect(if success then UntrustedNotary.Recover(pmem.View().durableState) else None,
                              PmvLen(pmem.View()), UntrustedNotary.SPACE_NEEDED_NOT_INCLUDING_KEY,
                              pmem.constants.imperviousToCorruption)
    {
        // The untrusted notary can crash into any state it wants
        // since it makes no guarantees about crashes during setup. If
        // there's a crash during setup, the caller is expected to
        // just run setup again. So we set the set of states permitted
        // to be "all states".
        ghost var statesPermitted: iset<seq<byte>> := iset s | TriggerState(s);
        assert(TriggerState(pmem.View().durableState));
        pmem.UpdateStatesPermitted(statesPermitted, perm);
        success := UntrustedNotary.Setup(pmem);
    }

    // This method starts up the notary service given a persistent
    // memory region that's already been set up. Indeed, it might have
    // run multiple times, crashing after each time. It recovers the
    // current state into memory and returns a `TrustedNotary` that's
    // ready to accept notarization requests. It can return `null`
    // when the specification allows, e.g., when the memory shows
    // evidence of corruption.
    static method Start(pmem: PersistentMemoryRegion, perm: PermissionToControlWritesToPersistentMemory)
                        returns (result: TrustedNotary?)
        requires pmem.Valid()
        requires UntrustedNotary.Recover(pmem.View().durableState).Some?
        modifies pmem
        ensures  pmem.Valid()
        ensures  result != null ==> result.Valid()
        ensures  result != null ==> result.View() == old(UntrustedNotary.Recover(pmem.View().durableState).value)
        ensures  result == null ==> !pmem.constants.imperviousToCorruption
    {
        // To ensure crash consistency of this start operation (i.e.,
        // to maintain the system's logical state even if crashes
        // happen during crash recovery), we use the PoWER approach.
        // Specifically, we restrict the untrusted notary to only
        // update persistent memory only if it can guarantee that, for
        // all crash states that might result, recovery produces the
        // same result as it would produce now.
        ghost var statesPermitted: iset<seq<byte>> :=
            iset s | UntrustedNotary.Recover(s) == UntrustedNotary.Recover(pmem.View().durableState);
        assert(pmem.View().durableState in statesPermitted);
        pmem.UpdateStatesPermitted(statesPermitted, perm);
        var impl := UntrustedNotary.Start(pmem);
        if impl != null
        {
            result := new TrustedNotary(pmem, impl, perm);
        }
        else
        {
            result := null;
        }
    }

    // This method queries the trusted notary for its public key.
    method ExtractPublicKey() returns (publicKey: array<byte>)
        requires Valid()
        ensures  SpecPublicKeySerializationCorrect(View().key.publicKey, publicKey[..])
    {
        publicKey := impl.ExtractPublicKey(pmem);
    }

    // This method queries the trusted notary for the current value of
    // its counter, i.e., how many times it has advanced the counter.
    method ReadCounter() returns (counter: uint64)
        requires Valid()
        ensures  counter == View().counter
    {
        counter := impl.ReadCounter(pmem);
    }

    // This method queries the trusted notary for the last message
    // notarized, i.e., the one associated with the notary's current
    // counter value.
    method ReadMessage() returns (message: array<byte>)
        requires Valid()
        ensures  fresh(message)
        ensures  message[..] == View().lastMessage
    {
        message := impl.ReadMessage(pmem);
    }

    // This method advances the counter and associates the new counter
    // value with the given message. It returns a result consistent
    // with the specification for the advance operation, given as
    // `AdvanceCorrect` in `NotarySpec_t.dfy`.
    method Advance(message: array<byte>) returns (success: bool)
        requires Valid()
        modifies this
        modifies pmem
        modifies impl
        modifies impl.Repr()
        ensures  Valid()
        ensures  AdvanceCorrect(old(View()), View(), message[..], pmem.constants.imperviousToCorruption, success)
    {
        // To ensure crash consistency, we use the PoWER approach: We
        // restrict writes such that, no matter how the system crashes
        // during this operation, recovery results in either the
        // current state or a state that can result from atomically
        // performing the advance operation as specified by
        // `AdvanceCorrect`.
        ghost var state := View();
        ghost var statesPermitted := iset s | (
            || UntrustedNotary.Recover(s) == Some(state)
            || (&& UntrustedNotary.Recover(s).Some?
                && AdvanceCorrect(state, UntrustedNotary.Recover(s).value, message[..], true, true))
        );
        pmem.UpdateStatesPermitted(statesPermitted, perm);
        success := impl.Advance(pmem, message);
    }

    // This method obtains the notary's signature binding the current
    // counter value to the last message notarized. It will likely be
    // called once after each `Advance`.
    method Sign() returns (signature: array<byte>)
        requires Valid()
        modifies impl
        modifies impl.Repr()
        ensures  Valid()
        ensures  SignCorrect(View(), signature[..])
    {
        signature := impl.Sign(pmem);
    }
}

}
