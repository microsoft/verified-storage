# initially generated by claude.ai

import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from statistics import mean, stdev
from pathlib import Path
import argparse
import sys
import csv
import scipy.stats as st
import json

kvstores = ["redis", "pmemrocksdb", "capybarakv"]
nice_kvstore_names = ["pmem-Redis", "pmem-RocksDB", "CapybaraKV"]
workloads = ["sequential_put", "sequential_get", "sequential_update", "sequential_delete", 
    "rand_put", "rand_get", "rand_update", "rand_delete"]
nice_workload_names = ["Seq\nput", "Seq\nget", "Seq\nupdate", "Seq\ndelete",
    "Rand\nput", "Rand\nget", "Rand\nupdate", "Rand\ndelete"]

def process_workload_file(file_path):
    """Process a single workload file and return the values."""
    with open(file_path, 'r') as f:
        return [int(line.strip()) for line in f if line.strip()]

def process_workload_directory(workload_dir):
    """Process all files in a workload directory and return mean and std dev."""
    print("Processing directory", workload_dir)
    values = []
    
    # Process all files in the directory
    for filename in os.listdir(workload_dir):
        file_path = os.path.join(workload_dir, filename)
        if os.path.isfile(file_path):
            try:
                file_values = process_workload_file(file_path)
                values.extend(file_values)
            except (ValueError, IOError) as e:
                print(f"Warning: Couldn't process file {file_path}: {str(e)}")
                continue
    
    if not values:
        print(f"Warning: No valid data found in directory {workload_dir}")
        return 0, 0

    mean_latency = mean(values)
    stdev_latency = stdev(values)
    conf_int = st.t.interval(0.95, df=len(values)-1, loc=mean_latency, scale=st.sem(values))
    conf_int_for_plot = [mean_latency - conf_int[0], conf_int[1] - mean_latency]

    return mean_latency, stdev_latency, conf_int_for_plot if len(values) > 1 else 0

def analyze_kvstore_data(base_dir):
    """Analyze data from all KV stores and their workloads."""
    if not os.path.exists(base_dir):
        print(f"Error: Directory '{base_dir}' does not exist")
        sys.exit(1)
        
    results = {}
    
    # Process each KV store directory
    for kvstore in os.listdir(base_dir):
        kvstore_path = os.path.join(base_dir, kvstore)
        if not os.path.isdir(kvstore_path):
            continue
            
        results[kvstore] = {}
        
        # Process each workload in the KV store directory
        # for workload in os.listdir(kvstore_path):
        for workload in workloads:
            workload_path = os.path.join(kvstore_path, workload)
            if not os.path.isdir(workload_path):
                continue
                
            mean_val, std_val, conf_int = process_workload_directory(workload_path)
            results[kvstore][workload] = (mean_val, std_val, conf_int)
    
    if not results:
        print(f"Error: No valid data found in directory '{base_dir}'")
        sys.exit(1)
        
    return results

def save_results_to_json(results, output_file):
    json_string = json.dumps(results)
    with open(output_file, "w") as f:
        f.write(json_string)

def read_results_from_json(input_file):
    with open(input_file, "r") as f:
        json_string = f.read()
        results = json.loads(json_string)
    return results

def plot_results(results, output_file='results.pdf'):
    """Create a bar plot with error bars from the results."""

    mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=["cornflowerblue", "orange", "black"]) 
    
    # Set up the plot
    plt.figure(figsize=(4.6, 1.8))
    x = np.arange(len(workloads))
    width = 0.8 / len(kvstores)
    # plt.set_axisbelow(True)
    
    # Plot bars for each KV store
    for i, kvstore in enumerate(kvstores):
        means = [results[kvstore][w][0] for w in workloads]
        err1 = [results[kvstore][w][2][0] for w in workloads]
        err2 = [results[kvstore][w][2][1] for w in workloads]
        err = [err1, err2]

        if kvstore == kvstores[0]:
            hatch = "////"
        elif kvstore == kvstores[1]:
            hatch= ".."
        else:
            hatch = ""
        
        plt.bar(x + i*width - width*len(kvstores)/2 + width/2, 
                means,
                width,
                label=kvstore,
                yerr=err,
                hatch=hatch,
                error_kw=dict(ecolor="red", capsize=1), 
                zorder=4)
        
    plt.grid(True, zorder=3, axis="y")
    # plt.xlabel('Workload')
    plt.ylabel('Latency (us)')
    plt.yscale("log")
    
    plt.xticks(x, nice_workload_names, fontsize="8")
    plt.legend(nice_kvstore_names, loc="upper center", fontsize="8", 
        ncol=3, bbox_to_anchor=(0.5, 1.25))
    plt.tight_layout(pad=0)
    
    
    # Save the plot
    plt.savefig(output_file, bbox_inches="tight")
    print(f"Plot saved as '{output_file}'")
    plt.close()

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Process and visualize key-value store workload data',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument('base_dir', 
                       help='Base directory containing KV store data')
    parser.add_argument('-o', '--output',
                       default='results.pdf',
                       help='Output PDF file name')
    parser.add_argument('-j', '--json',
                       default='results.json',
                       help='JSON file name')
    parser.add_argument('-r', '--read',
                        action='store_true',
                        default=False, 
                        help='Flag indicating whether program should read  \
                            results from a JSON file or compute and store them \
                            in the file. Default false (compute and store).')
    return parser.parse_args()

def main():
    # Parse command line arguments
    args = parse_arguments()
    
    if not args.read:
        # Process the data
        results = analyze_kvstore_data(args.base_dir)
        # Store the data
        save_results_to_json(results, args.json)
    else: 
        results = read_results_from_json(args.json)
    
    # Create the visualization
    plot_results(results, args.output)

if __name__ == "__main__":
    main()