Building deps_hack
Building pmcopy
Verifying
#![feature(prelude_import)]
#![feature(maybe_uninit_as_bytes)]
#![feature(maybe_uninit_slice)]
#![feature(maybe_uninit_write_slice)]

#![allow(unused_imports)]
#![allow(unused_braces)]
#![allow(unused_variables)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unused_mut)]


// pub mod log;
// pub mod multilog;




// #[test]
// fn check_multilog_in_volatile_memory() {
//     assert!(test_multilog_in_volatile_memory());
// }

//#[test]
//fn check_durable_on_memory_mapped_file () {
//    test_durable_on_memory_mapped_file();
//}





// test_multilog_in_volatile_memory();
// test_multilog_on_memory_mapped_file();
// test_log_on_memory_mapped_file();
// test_durable_on_memory_mapped_file();
//    let _ = test_kv_on_memory_mapped_file();
//    let _ = test_concurrent_kv_on_memory_mapped_file();

#![allow(internal_features)]
#![feature(stmt_expr_attributes)]
#![feature(box_patterns)]
#![feature(negative_impls)]
#![feature(rustc_attrs)]
#![feature(unboxed_closures)]
#![feature(register_tool)]
#![feature(tuple_trait)]
#![feature(custom_inner_attributes)]
#![feature(try_trait_v2)]
#![register_tool(verus)]
#![register_tool(verifier)]
#![register_tool(verusfmt)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use builtin::*;
use builtin_macros::*;
use vstd::prelude::*;
pub mod common {
    pub mod align_v {
        use builtin::*;
        use builtin_macros::*;
        use crate::pmem::pmcopy_t::{pmcopy_axioms, PmCopy};
        use crate::pmem::traits_t::{align_of, size_of};
        use vstd::arithmetic::overflow::CheckedU64;
        use vstd::prelude::*;
        #[cfg(verus_keep_ghost)]
        use vstd::arithmetic::div_mod::{
            lemma_fundamental_div_mod, lemma_mod_multiples_vanish,
        };
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn is_aligned(addr: int, alignment: int) -> bool {
            ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::spec_eq((addr).spec_euclidean_mod(alignment),
                ::builtin::spec_literal_nat("0"))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        pub fn space_needed_for_alignment(addr: int, alignment: int) -> int {
            ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            let remainder = (addr).spec_euclidean_mod(alignment);
            if ::builtin::spec_eq(remainder, ::builtin::spec_literal_nat("0"))
                    {
                    ::builtin::spec_literal_integer("0")
                } else { (alignment).spec_sub(remainder) }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn round_up_to_alignment(addr: int, alignment: int) -> int {
            ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            (addr).spec_add(space_needed_for_alignment(addr, alignment))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_auto_space_needed_for_alignment_bounded() {
            ::builtin::ensures([::builtin::forall(|addr: int, alignment: int|
                                ::builtin::imply((::builtin::spec_literal_nat("0")).spec_lt(alignment),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                #[verus::internal(trigger)] space_needed_for_alignment(addr,
                                                    alignment)), alignment))))]);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn get_space_needed_for_alignment_usize(addr: u64,
            alignment: usize) -> usize {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::ensures(|result: usize|
                    [::builtin::spec_eq(result,
                                space_needed_for_alignment(::builtin::spec_cast_integer::<_,
                                            int>(addr),
                                    ::builtin::spec_cast_integer::<_, int>(alignment)))]);
            let remainder: usize = (addr % (alignment as u64)) as usize;
            if remainder == 0 { remainder } else { alignment - remainder }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn exec_round_up_to_alignment<T>(addr: u64) -> u64 where
            T: PmCopy {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(T::spec_align_of()),
                        (round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                            int>(addr),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(T::spec_align_of()))).spec_le(u64::MAX)]);
            ::builtin::ensures(|result: u64|
                    [::builtin::spec_eq(result,
                                round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                            int>(addr),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(T::spec_align_of())))]);
            let alignment_needed =
                get_space_needed_for_alignment_usize(addr, align_of::<T>());
            addr + (alignment_needed as u64)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn get_space_needed_for_alignment(addr: u64, alignment: u64)
            -> u64 {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::ensures(|result: u64|
                    [::builtin::spec_eq(result,
                                space_needed_for_alignment(::builtin::spec_cast_integer::<_,
                                            int>(addr),
                                    ::builtin::spec_cast_integer::<_, int>(alignment)))]);
            let remainder = addr % alignment;
            if remainder == 0 { remainder } else { alignment - remainder }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_space_needed_for_alignment_works(addr: int,
            alignment: int) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::ensures([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    space_needed_for_alignment(addr, alignment)), alignment)),
                        is_aligned((addr).spec_add(space_needed_for_alignment(addr,
                                    alignment)), alignment)]);
            let remainder = (addr).spec_euclidean_mod(alignment);
            if !::builtin::spec_eq(remainder,
                            ::builtin::spec_literal_nat("0")) {
                    {
                        ::builtin::assert_by(::builtin::spec_eq(addr,
                                ((alignment).spec_mul(((addr).spec_euclidean_div(alignment)))).spec_add(((addr).spec_euclidean_mod(alignment)))),
                            { lemma_fundamental_div_mod(addr, alignment); });
                    }
                    ::builtin::assert_(::builtin::spec_eq(((addr).spec_add(alignment)).spec_sub(remainder),
                            ((alignment).spec_mul(((addr).spec_euclidean_div(alignment)))).spec_add(alignment)));
                    {
                        ::builtin::assert_by(::builtin::spec_eq(((((addr).spec_add(alignment)).spec_sub(remainder))).spec_euclidean_mod(alignment),
                                (alignment).spec_euclidean_mod(alignment)),
                            {
                                lemma_mod_multiples_vanish((addr).spec_euclidean_div(alignment),
                                    alignment, alignment);
                            });
                    }
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_reserve_space<T>(offset: int) -> (int, int) where
            T: PmCopy {
            ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(T::spec_align_of())]);
            let start =
                round_up_to_alignment(offset,
                    ::builtin::spec_cast_integer::<_, int>(T::spec_align_of()));
            let end = (start).spec_add(T::spec_size_of());
            (start, end)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_reserve_specified_space(offset: int, size: int,
            alignment: int) -> (int, int) {
            ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            let start = round_up_to_alignment(offset, alignment);
            let end = (start).spec_add(size);
            (start, end)
        }
        #[inline]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn align_checked_u64(v: &CheckedU64, alignment: u64)
            -> CheckedU64 {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::ensures(|result: CheckedU64|
                    [((v.view())).spec_le((result.view())),
                            ((result.view())).spec_lt(((v.view())).spec_add(alignment)),
                            ::builtin::spec_eq((result.view()),
                                round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                            int>((v.view())),
                                    ::builtin::spec_cast_integer::<_, int>(alignment))),
                            is_aligned(::builtin::spec_cast_integer::<_,
                                        int>((result.view())),
                                ::builtin::spec_cast_integer::<_, int>(alignment))]);

            #[verifier::proof_block]
            {
                lemma_space_needed_for_alignment_works(::builtin::spec_cast_integer::<_,
                            int>((v.view())),
                    ::builtin::spec_cast_integer::<_, int>(alignment));
            }
            if v.is_overflowed() {
                    CheckedU64::new_overflowed(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                        int>((v.view())),
                                ::builtin::spec_cast_integer::<_, int>(alignment))))
                } else {
                   v.add_value(get_space_needed_for_alignment(v.unwrap(),
                           alignment))
               }
        }
        #[inline]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn align_checked_u64_to_usize(v: &CheckedU64, alignment: usize)
            -> CheckedU64 {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::ensures(|result: CheckedU64|
                    [((v.view())).spec_le((result.view())),
                            ((result.view())).spec_lt(((v.view())).spec_add(alignment)),
                            ::builtin::spec_eq((result.view()),
                                round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                            int>((v.view())),
                                    ::builtin::spec_cast_integer::<_, int>(alignment))),
                            is_aligned(::builtin::spec_cast_integer::<_,
                                        int>((result.view())),
                                ::builtin::spec_cast_integer::<_, int>(alignment))]);

            #[verifier::proof_block]
            {
                lemma_space_needed_for_alignment_works(::builtin::spec_cast_integer::<_,
                            int>((v.view())),
                    ::builtin::spec_cast_integer::<_, int>(alignment));
            }
            if v.is_overflowed() {
                    CheckedU64::new_overflowed(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                        int>((v.view())),
                                ::builtin::spec_cast_integer::<_, int>(alignment))))
                } else {
                   v.add_value(get_space_needed_for_alignment_usize(v.unwrap(),
                               alignment) as u64)
               }
        }
        #[inline]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn reserve_space<T>(offset: &CheckedU64)
            -> (CheckedU64, CheckedU64) where T: PmCopy {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(T::spec_align_of())]);
            ::builtin::ensures(|bounds: (CheckedU64, CheckedU64)|
                    [({
                                    let (start, end) = bounds;
                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((offset.view())),
                                                                        (start.view())),
                                                                    ((offset.view())).spec_add(T::spec_align_of())))) &&
                                                        (::builtin::spec_eq((start.view()),
                                                                round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                                                            int>((offset.view())),
                                                                    ::builtin::spec_cast_integer::<_,
                                                                            int>(T::spec_align_of()))))) &&
                                                (is_aligned(::builtin::spec_cast_integer::<_,
                                                                int>((start.view())),
                                                        ::builtin::spec_cast_integer::<_,
                                                                int>(T::spec_align_of())))) &&
                                        (::builtin::spec_eq(((end.view())).spec_sub((start.view())),
                                                T::spec_size_of()))
                                })]);
            let start = align_checked_u64_to_usize(&offset, align_of::<T>());
            let end = start.add_value(size_of::<T>() as u64);
            (start, end)
        }
        #[inline]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn reserve_specified_space(offset: &CheckedU64, size: u64,
            alignment: u64) -> (CheckedU64, CheckedU64) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::ensures(|bounds: (CheckedU64, CheckedU64)|
                    [({
                                    let (start, end) = bounds;
                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((offset.view())),
                                                                        (start.view())), ((offset.view())).spec_add(alignment)))) &&
                                                        (::builtin::spec_eq((start.view()),
                                                                round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                                                            int>((offset.view())),
                                                                    ::builtin::spec_cast_integer::<_, int>(alignment))))) &&
                                                (is_aligned(::builtin::spec_cast_integer::<_,
                                                                int>((start.view())),
                                                        ::builtin::spec_cast_integer::<_, int>(alignment)))) &&
                                        (::builtin::spec_eq(((end.view())).spec_sub((start.view())),
                                                size))
                                })]);
            let start = align_checked_u64(&offset, alignment);
            let end = start.add_value(size);
            (start, end)
        }
        #[inline]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn reserve_specified_space_checked_u64(offset: &CheckedU64,
            size: &CheckedU64, alignment: u64) -> (CheckedU64, CheckedU64) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
            ::builtin::ensures(|bounds: (CheckedU64, CheckedU64)|
                    [({
                                    let (start, end) = bounds;
                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((offset.view())),
                                                                        (start.view())), ((offset.view())).spec_add(alignment)))) &&
                                                        (::builtin::spec_eq((start.view()),
                                                                round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                                                            int>((offset.view())),
                                                                    ::builtin::spec_cast_integer::<_, int>(alignment))))) &&
                                                (is_aligned(::builtin::spec_cast_integer::<_,
                                                                int>((start.view())),
                                                        ::builtin::spec_cast_integer::<_, int>(alignment)))) &&
                                        (::builtin::spec_eq(((end.view())).spec_sub((start.view())),
                                                (size.view())))
                                })]);
            let start = align_checked_u64(&offset, alignment);
            let end = start.add_checked(size);
            (start, end)
        }
    }
    pub mod recover_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::set_lib::*;
        use vstd::seq::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::traits_t::{
            size_of, PmSized, ConstPmSized, UnsafeSpecPmSized, PmSafe,
        };
        use crate::pmem::pmemutil_v::*;
        use super::subrange_v::*;
        #[doc =
        " Recovers an object of type T from a sequence of bytes, verifying its CRC."]
        #[doc = " Returns Some(T) if recovery is successful, otherwise None."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn recover_object<T>(s: Seq<u8>, start: int, crc_addr: int)
            -> Option<T> where T: PmCopy {
            if {
                        ((((::builtin::spec_literal_nat("0")).spec_le(start)) &&
                                            (((start).spec_add(T::spec_size_of())).spec_le(s.len()))) &&
                                    ((::builtin::spec_literal_nat("0")).spec_le(crc_addr))) &&
                            (((crc_addr).spec_add(u64::spec_size_of())).spec_le(s.len()))
                    } {
                    let object_bytes =
                        extract_section(s, start, T::spec_size_of());
                    let crc_bytes =
                        extract_section(s, crc_addr, u64::spec_size_of());
                    if {
                                ((T::bytes_parseable(object_bytes)) &&
                                            (u64::bytes_parseable(crc_bytes))) &&
                                    (::builtin::spec_eq(crc_bytes,
                                            spec_crc_bytes(object_bytes)))
                            } {
                            Some(T::spec_from_bytes(object_bytes))
                        } else { None }
                } else { None }
        }
        #[doc =
        " Recovers a corruption-detecting Boolean (CDB) from a sequence of bytes."]
        #[doc =
        " Returns Some(true) or Some(false) if recovery is successful, otherwise None."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn recover_cdb(s: Seq<u8>, addr: int) -> Option<bool> {
            if (::builtin::spec_literal_nat("0")).spec_le(addr) &&
                        ((addr).spec_add(u64::spec_size_of())).spec_le(s.len()) {
                    let cdb_bytes =
                        extract_section(s, addr, u64::spec_size_of());
                    if u64::bytes_parseable(cdb_bytes) {
                            let cdb = u64::spec_from_bytes(cdb_bytes);
                            if ::builtin::spec_eq(cdb, CDB_FALSE) {
                                    Some(false)
                                } else if ::builtin::spec_eq(cdb, CDB_TRUE) {
                                   Some(true)
                               } else { None }
                        } else { None }
                } else { None }
        }
        #[doc =
        " Recovers a sequence of bytes from a given start position and length, verifying its CRC."]
        #[doc =
        " Returns Some(Seq<u8>) if recovery is successful, otherwise None."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn recover_bytes(s: Seq<u8>, start: int, num_bytes: nat,
            crc_addr: int) -> Option<Seq<u8>> {
            if {
                        ((((::builtin::spec_literal_nat("0")).spec_le(start)) &&
                                            (((start).spec_add(num_bytes)).spec_le(s.len()))) &&
                                    ((::builtin::spec_literal_nat("0")).spec_le(crc_addr))) &&
                            (((crc_addr).spec_add(u64::spec_size_of())).spec_le(s.len()))
                    } {
                    let bytes = extract_section(s, start, num_bytes);
                    let crc_bytes =
                        extract_section(s, crc_addr, u64::spec_size_of());
                    if {
                                (u64::bytes_parseable(crc_bytes)) &&
                                    (::builtin::spec_eq(crc_bytes, spec_crc_bytes(bytes)))
                            } {
                            Some(bytes)
                        } else { None }
                } else { None }
        }
        #[doc =
        " Executes the recovery of an object of type T from persistent memory, verifying its CRC."]
        #[doc = " Returns Some(T) if recovery is successful, otherwise None."]
        #[doc =
        " If it returns None, it guarantees that the underlying persistent memory was corrupted."]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn exec_recover_object<PM, T>(pm: &PM, start: u64, crc_addr: u64)
            -> Option<T> where PM: PersistentMemoryRegion, T: PmCopy {
            ::builtin::requires([pm.inv(),
                        ::builtin::is_variant(recover_object::<T>((pm.view()).read_state,
                                ::builtin::spec_cast_integer::<_, int>(start),
                                ::builtin::spec_cast_integer::<_, int>(crc_addr)), "Some"),
                        ((crc_addr).spec_add(u64::spec_size_of())).spec_le(start) ||
                            ((start).spec_add(T::spec_size_of())).spec_le(crc_addr)]);
            ::builtin::ensures(|result: Option<T>|
                    [match result {
                                None => !pm.constants().impervious_to_corruption(),
                                Some(x) =>
                                    ::builtin::spec_eq(recover_object::<T>((pm.view()).read_state,
                                            ::builtin::spec_cast_integer::<_, int>(start),
                                            ::builtin::spec_cast_integer::<_, int>(crc_addr)), Some(x)),
                            }]);
            #[verus::internal(spec)]
            #[verus::internal(unwrapped_binding)]
            let mut verus_tmp;

            #[verifier::proof_block]
            {
                verus_tmp =
                    extract_section((pm.view()).read_state,
                        ::builtin::spec_cast_integer::<_, int>(start),
                        T::spec_size_of())
            };
            #[verus::internal(spec)]
            let mut true_bytes;

            #[verifier::proof_block]
            {
                #[verus::internal(spec)]
                let verus_tmp_true_bytes = verus_tmp;
                true_bytes = verus_tmp_true_bytes;
            };
            #[verus::internal(spec)]
            #[verus::internal(unwrapped_binding)]
            let mut verus_tmp;

            #[verifier::proof_block]
            { verus_tmp = T::spec_from_bytes(true_bytes) };
            #[verus::internal(spec)]
            let mut true_x;

            #[verifier::proof_block]
            {
                #[verus::internal(spec)]
                let verus_tmp_true_x = verus_tmp;
                true_x = verus_tmp_true_x;
            };
            let maybe_corrupted_x =
                match pm.read_aligned::<T>(start) {
                    Ok(bytes) => bytes,
                    Err(_) => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return None;
                    }
                };
            let maybe_corrupted_crc =
                match pm.read_aligned::<u64>(crc_addr) {
                    Ok(bytes) => bytes,
                    Err(_) => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return None;
                    }
                };
            if check_crc(maybe_corrupted_x.as_slice(),
                        maybe_corrupted_crc.as_slice(),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_bytes),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] pm.constants()),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_cast_integer::<_,
                                    int>(start)),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_cast_integer::<_,
                                    int>(crc_addr))) {
                    Some(*maybe_corrupted_x.extract_init_val(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_x)))
                } else { None }
        }
        #[doc =
        " Executes the recovery of a corruption-detecting Boolean (CDB) from persistent memory."]
        #[doc =
        " Returns Some(true) or Some(false) if recovery is successful, otherwise None."]
        #[doc =
        " If it returns None, it guarantees that the underlying persistent memory was corrupted."]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn exec_recover_cdb<PM>(pm: &PM, addr: u64) -> Option<bool> where
            PM: PersistentMemoryRegion {
            ::builtin::requires([pm.inv(),
                        ::builtin::is_variant(recover_cdb((pm.view()).read_state,
                                ::builtin::spec_cast_integer::<_, int>(addr)), "Some")]);
            ::builtin::ensures(|result: Option<bool>|
                    [match result {
                                None => !pm.constants().impervious_to_corruption(),
                                Some(b) =>
                                    ::builtin::spec_eq(recover_cdb((pm.view()).read_state,
                                            ::builtin::spec_cast_integer::<_, int>(addr)), Some(b)),
                            }]);
            #[verus::internal(spec)]
            #[verus::internal(unwrapped_binding)]
            let mut verus_tmp;

            #[verifier::proof_block]
            {
                verus_tmp =
                    extract_section((pm.view()).read_state,
                        ::builtin::spec_cast_integer::<_, int>(addr),
                        u64::spec_size_of())
            };
            #[verus::internal(spec)]
            let mut true_bytes;

            #[verifier::proof_block]
            {
                #[verus::internal(spec)]
                let verus_tmp_true_bytes = verus_tmp;
                true_bytes = verus_tmp_true_bytes;
            };
            let maybe_corrupted_bytes =
                match pm.read_aligned::<u64>(addr) {
                    Ok(bytes) => bytes,
                    Err(_) => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return None;
                    }
                };
            check_cdb(maybe_corrupted_bytes,
                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_bytes),
                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] pm.constants()),
                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_cast_integer::<_,
                            int>(addr)))
        }
        #[doc =
        " Executes the recovery of a sequence of bytes from persistent memory, verifying its CRC."]
        #[doc =
        " Returns Some(Vec<u8>) if recovery is successful, otherwise None."]
        #[doc =
        " If it returns None, it guarantees that the underlying persistent memory was corrupted."]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn exec_recover_bytes<PM>(pm: &PM, start: u64, num_bytes: u64,
            crc_addr: u64) -> Option<Vec<u8>> where
            PM: PersistentMemoryRegion {
            ::builtin::requires([pm.inv(),
                        ::builtin::is_variant(recover_bytes((pm.view()).read_state,
                                ::builtin::spec_cast_integer::<_, int>(start),
                                ::builtin::spec_cast_integer::<_, nat>(num_bytes),
                                ::builtin::spec_cast_integer::<_, int>(crc_addr)), "Some"),
                        ((crc_addr).spec_add(u64::spec_size_of())).spec_le(start) ||
                            ((start).spec_add(num_bytes)).spec_le(crc_addr)]);
            ::builtin::ensures(|result: Option<Vec<u8>>|
                    [match result {
                                None => !pm.constants().impervious_to_corruption(),
                                Some(s) =>
                                    ::builtin::spec_eq((s.view()),
                                        recover_bytes((pm.view()).read_state,
                                                ::builtin::spec_cast_integer::<_, int>(start),
                                                ::builtin::spec_cast_integer::<_, nat>(num_bytes),
                                                ::builtin::spec_cast_integer::<_, int>(crc_addr)).unwrap()),
                            }]);
            #[verus::internal(spec)]
            #[verus::internal(unwrapped_binding)]
            let mut verus_tmp;

            #[verifier::proof_block]
            {
                verus_tmp =
                    extract_section((pm.view()).read_state,
                        ::builtin::spec_cast_integer::<_, int>(start),
                        ::builtin::spec_cast_integer::<_, nat>(num_bytes))
            };
            #[verus::internal(spec)]
            let mut true_bytes;

            #[verifier::proof_block]
            {
                #[verus::internal(spec)]
                let verus_tmp_true_bytes = verus_tmp;
                true_bytes = verus_tmp_true_bytes;
            };
            let maybe_corrupted_bytes =
                match pm.read_unaligned(start, num_bytes) {
                    Ok(bytes) => bytes,
                    Err(_) => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return None;
                    }
                };
            let maybe_corrupted_crc =
                match pm.read_aligned::<u64>(crc_addr) {
                    Ok(bytes) => bytes,
                    Err(_) => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return None;
                    }
                };
            if check_crc(maybe_corrupted_bytes.as_slice(),
                        maybe_corrupted_crc.as_slice(),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_bytes),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] pm.constants()),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_cast_integer::<_,
                                    int>(start)),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_cast_integer::<_,
                                    int>(crc_addr))) {
                    Some(maybe_corrupted_bytes)
                } else { None }
        }
    }
    pub mod saturate_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::align_v::{
            get_space_needed_for_alignment,
            get_space_needed_for_alignment_usize,
        };
        #[cfg(verus_keep_ghost)]
        use crate::common::align_v::{
            lemma_space_needed_for_alignment_works, is_aligned,
            round_up_to_alignment,
        };
        #[cfg(verus_keep_ghost)]
        use vstd::arithmetic::div_mod::{
            lemma_div_is_ordered_by_denominator, lemma_div_plus_one,
            lemma_fundamental_div_mod, lemma_mod_division_less_than_divisor,
        };
        #[cfg(verus_keep_ghost)]
        use vstd::arithmetic::mul::lemma_mul_inequality;
        #[verus::internal(verus_macro)]
        pub struct SaturatingU64 {
            i: Ghost<int>,
            v: u64,
        }
        #[verus::internal(verus_macro)]
        impl View for SaturatingU64 {
            type V = int;
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn view(&self) -> int { (self.i.view()) }
        }
        #[verus::internal(verus_macro)]
        impl Clone for SaturatingU64 {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn clone(&self) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq((result.view()), (self.view()))]);

                #[verifier::proof_block]
                { use_type_invariant(self); }
                Self { i: self.i, v: self.v }
            }
        }
        #[verus::internal(verus_macro)]
        impl SaturatingU64 {
            #[verifier::type_invariant]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn well_formed(self) -> bool {
                if ((self.i.view())).spec_gt(u64::MAX) {
                        ::builtin::spec_eq(self.v, u64::MAX)
                    } else { ::builtin::spec_eq(self.v, self.i) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_new(v: u64) -> SaturatingU64 {
                SaturatingU64 {
                    i: ::builtin::Ghost::new(::builtin::spec_cast_integer::<_,
                                int>(v)),
                    v,
                }
            }
            #[verifier::when_used_as_spec(spec_new)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new(v: u64) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq((result.view()), v)]);
                Self {
                    i: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_cast_integer::<_,
                                int>(v)),
                    v,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn spec_is_saturated(&self) -> bool {
                ((self.view())).spec_ge(u64::MAX)
            }
            #[verifier::when_used_as_spec(spec_is_saturated)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn is_saturated(&self) -> bool {
                ::builtin::ensures(|result: bool|
                        [::builtin::spec_eq(result, self.spec_is_saturated())]);

                #[verifier::proof_block]
                { use_type_invariant(self) }
                self.v == u64::MAX
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_unwrap(&self) -> u64 { self.v }
            #[verifier::when_used_as_spec(spec_unwrap)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn unwrap(&self) -> u64 {
                ::builtin::ensures(|result: u64|
                        [if (result).spec_lt(u64::MAX) {
                                        ::builtin::spec_eq((self.view()), result)
                                    } else { self.is_saturated() },
                                ::builtin::spec_eq(result, self.spec_unwrap())]);

                #[verifier::proof_block]
                { use_type_invariant(self) }
                self.v
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn to_option(&self) -> Option<u64> {
                ::builtin::ensures(|result: Option<u64>|
                        [match result {
                                    Some(v) =>
                                        ::builtin::spec_eq((self.view()), v) &&
                                            (v).spec_lt(u64::MAX),
                                    None => ((self.view())).spec_ge(u64::MAX),
                                }]);

                #[verifier::proof_block]
                { use_type_invariant(self); }
                if self.v == u64::MAX { None } else { Some(self.v) }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn add(&self, v2: u64) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq((result.view()),
                                    ((self.view())).spec_add(v2))]);

                #[verifier::proof_block]
                { use_type_invariant(&self); }
                let i: Ghost<int> =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (&(self.view())).spec_add(v2));
                if v2 > u64::MAX - self.v {
                        Self { i, v: u64::MAX }
                    } else { Self { i, v: self.v + v2 } }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn align(&self, alignment: usize) -> Self {
                ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(alignment)]);
                ::builtin::ensures(|result: Self|
                        [((self.view())).spec_le((result.view())),
                                ((result.view())).spec_lt(((self.view())).spec_add(alignment)),
                                ::builtin::spec_eq((result.view()),
                                    round_up_to_alignment((self.view()),
                                        ::builtin::spec_cast_integer::<_, int>(alignment))),
                                is_aligned((result.view()),
                                    ::builtin::spec_cast_integer::<_, int>(alignment))]);

                #[verifier::proof_block]
                {
                    use_type_invariant(self);
                    lemma_space_needed_for_alignment_works((self.view()),
                        ::builtin::spec_cast_integer::<_, int>(alignment));
                }
                if self.v == u64::MAX {
                        Self {
                            i: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] round_up_to_alignment((self.i.view()),
                                    ::builtin::spec_cast_integer::<_, int>(alignment))),
                            v: self.v,
                        }
                    } else {
                       let increment_amount =
                           get_space_needed_for_alignment_usize(self.v, alignment);
                       self.add(increment_amount as u64)
                   }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn add_saturating_u64(&self, v2: &SaturatingU64) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq((result.view()),
                                    ((self.view())).spec_add((v2.view())))]);

                #[verifier::proof_block]
                { use_type_invariant(self); use_type_invariant(v2); }
                let i: Ghost<int> =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.view())).spec_add((v2.view())));
                if v2.is_saturated() || self.v > u64::MAX - v2.v {
                        Self { i, v: u64::MAX }
                    } else { Self { i, v: self.v + v2.v } }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn mul(&self, v2: u64) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq((result.view()),
                                    ((self.view())).spec_mul(v2))]);

                #[verifier::proof_block]
                { use_type_invariant(self); }
                let i: Ghost<int> =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.view())).spec_mul(v2));
                if v2 == 0 || self.v == 0 {
                        Self { i, v: 0 }
                    } else if self.v > u64::MAX / v2 {

                       #[verifier::proof_block]
                       {
                           ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_ge(::builtin::spec_chained_ge(::builtin::spec_chained_value((self.view())),
                                           self.v),
                                       ((u64::MAX).spec_euclidean_div(v2)).spec_add(::builtin::spec_literal_nat("1")))));
                           {
                               ::builtin::assert_by(((self.view())).spec_ge((((u64::MAX).spec_add(v2))).spec_euclidean_div(::builtin::spec_cast_integer::<_,
                                                   int>(v2))),
                                   {
                                       lemma_div_plus_one(::builtin::spec_cast_integer::<_,
                                                   int>(u64::MAX), ::builtin::spec_cast_integer::<_, int>(v2));
                                   });
                           }
                           {
                               ::builtin::assert_by(::builtin::spec_eq((v2).spec_mul(((((u64::MAX).spec_add(v2))).spec_euclidean_div((::builtin::spec_cast_integer::<_,
                                                               int>(v2))))),
                                       ((u64::MAX).spec_add(v2)).spec_sub(((((u64::MAX).spec_add(v2))).spec_euclidean_mod((::builtin::spec_cast_integer::<_,
                                                               int>(v2)))))),
                                   {
                                       lemma_fundamental_div_mod((u64::MAX).spec_add(v2),
                                           ::builtin::spec_cast_integer::<_, int>(v2));
                                   });
                           }
                           {
                               ::builtin::assert_by(((v2).spec_mul(((((u64::MAX).spec_add(v2))).spec_euclidean_div((::builtin::spec_cast_integer::<_,
                                                                   int>(v2)))))).spec_gt(u64::MAX),
                                   {
                                       {
                                           ::builtin::assert_by(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                           (((u64::MAX).spec_add(v2))).spec_euclidean_mod((::builtin::spec_cast_integer::<_,
                                                                           int>(v2)))), v2)),
                                               {
                                                   lemma_mod_division_less_than_divisor((u64::MAX).spec_add(v2),
                                                       ::builtin::spec_cast_integer::<_, int>(v2));
                                               });
                                       }
                                   });
                           }
                           {
                               ::builtin::assert_by((((self.view())).spec_mul(v2)).spec_ge((((((u64::MAX).spec_add(v2))).spec_euclidean_div((::builtin::spec_cast_integer::<_,
                                                                   int>(v2))))).spec_mul(v2)),
                                   {
                                       lemma_mul_inequality((((u64::MAX).spec_add(v2))).spec_euclidean_div((::builtin::spec_cast_integer::<_,
                                                           int>(v2))), (self.view()),
                                           ::builtin::spec_cast_integer::<_, int>(v2));
                                   });
                           }
                           ::builtin::assert_((((self.view())).spec_mul(v2)).spec_gt(u64::MAX));
                       }
                       Self { i, v: u64::MAX }
                   } else {

                       #[verifier::proof_block]
                       {
                           {
                               ::builtin::assert_by(((self.v).spec_mul(v2)).spec_le((((u64::MAX).spec_euclidean_div(v2))).spec_mul(v2)),
                                   {
                                       lemma_mul_inequality(::builtin::spec_cast_integer::<_,
                                                   int>(self.v),
                                           (::builtin::spec_cast_integer::<_,
                                                           int>(u64::MAX)).spec_euclidean_div(::builtin::spec_cast_integer::<_,
                                                       int>(v2)), ::builtin::spec_cast_integer::<_, int>(v2));
                                   });
                           }
                           {
                               ::builtin::assert_by(::builtin::spec_eq((((u64::MAX).spec_euclidean_div(v2))).spec_mul(v2),
                                       (u64::MAX).spec_sub((u64::MAX).spec_euclidean_mod(v2))),
                                   {
                                       lemma_fundamental_div_mod(::builtin::spec_cast_integer::<_,
                                                   int>(u64::MAX), ::builtin::spec_cast_integer::<_, int>(v2));
                                   });
                           }
                           {
                               ::builtin::assert_by(((((u64::MAX).spec_euclidean_div(v2))).spec_mul(v2)).spec_le(u64::MAX),
                                   {
                                       lemma_mod_division_less_than_divisor(::builtin::spec_cast_integer::<_,
                                                   int>(u64::MAX), ::builtin::spec_cast_integer::<_, int>(v2));
                                   });
                           }
                           if ::builtin::spec_eq(self.v, u64::MAX) &&
                                       !::builtin::spec_eq(v2, ::builtin::spec_literal_nat("1")) {
                                   ::builtin::assert_by_compute_only(((u64::MAX).spec_euclidean_div(::builtin::spec_literal_integer("2"))).spec_lt(u64::MAX));
                                   lemma_div_is_ordered_by_denominator(::builtin::spec_cast_integer::<_,
                                               int>(u64::MAX), ::builtin::spec_literal_integer("2"),
                                       ::builtin::spec_cast_integer::<_, int>(v2));
                                   ::builtin::assert_(false);
                               }
                       }
                       Self { i, v: self.v * v2 }
                   }
            }
        }
    }
    pub mod subrange_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::set_lib::*;
        use vstd::seq::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::traits_t::{
            size_of, PmSized, ConstPmSized, UnsafeSpecPmSized, PmSafe,
        };
        use crate::pmem::pmemutil_v::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn extract_section<T>(s: Seq<T>, i: int, len: nat) -> Seq<T> {
            s.subrange(i, (i).spec_add(len))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn seqs_match_in_range<T>(s1: Seq<T>, s2: Seq<T>, start: int,
            end: int) -> bool {
            ((::builtin::spec_eq(s1.len(), s2.len())) &&
                        (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            start), end), s1.len())))) &&
                (::builtin::spec_eq(s1.subrange(start, end),
                        s2.subrange(start, end)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn seqs_match_except_in_range<T>(s1: Seq<T>, s2: Seq<T>,
            start: int, end: int) -> bool {
            (((::builtin::spec_eq(s1.len(), s2.len())) &&
                                ((start).spec_le(end))) &&
                        (seqs_match_in_range(s1, s2,
                                ::builtin::spec_literal_integer("0"), start))) &&
                (seqs_match_in_range(s1, s2, end,
                        ::builtin::spec_cast_integer::<_, int>(s1.len())))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn pm_views_match_in_range(v1: PersistentMemoryRegionView,
            v2: PersistentMemoryRegionView, start: int, end: int) -> bool {
            (seqs_match_in_range(v1.durable_state, v2.durable_state, start,
                        end)) &&
                (seqs_match_in_range(v1.read_state, v2.read_state, start,
                        end))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn pm_views_match_except_in_range(v1: PersistentMemoryRegionView,
            v2: PersistentMemoryRegionView, start: int, end: int) -> bool {
            (seqs_match_except_in_range(v1.durable_state, v2.durable_state,
                        start, end)) &&
                (seqs_match_except_in_range(v1.read_state, v2.read_state,
                        start, end))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_can_result_from_partial_write_effect_on_match(s2:
                Seq<u8>, s1: Seq<u8>, write_addr: int, bytes: Seq<u8>) {
            ::builtin::requires([can_result_from_partial_write(s2, s1,
                            write_addr, bytes),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes.len())).spec_le(s1.len())]);
            ::builtin::ensures([seqs_match_except_in_range(s1, s2, write_addr,
                            (write_addr).spec_add(bytes.len()))]);
            lemma_can_result_from_partial_write_effect(s2, s1, write_addr,
                bytes);
            ::builtin::assert_(::builtin::ext_equal(s1.subrange(::builtin::spec_literal_integer("0"),
                        write_addr),
                    s2.subrange(::builtin::spec_literal_integer("0"),
                        write_addr)));
            ::builtin::assert_(::builtin::ext_equal(s1.subrange((write_addr).spec_add(bytes.len()),
                        ::builtin::spec_cast_integer::<_, int>(s1.len())),
                    s2.subrange((write_addr).spec_add(bytes.len()),
                        ::builtin::spec_cast_integer::<_, int>(s2.len()))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_can_result_from_partial_write_effect_on_match(s2:
                Seq<u8>, s1: Seq<u8>, write_addr: int, bytes: Seq<u8>) {
            ::builtin::requires([#[verus::internal(trigger)] can_result_from_partial_write(s2,
                            s1, write_addr, bytes),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes.len())).spec_le(s1.len())]);
            ::builtin::ensures([seqs_match_except_in_range(s1, s2, write_addr,
                            (write_addr).spec_add(bytes.len()))]);
            let end = (write_addr).spec_add(bytes.len());
            lemma_can_result_from_partial_write_effect(s2, s1, write_addr,
                bytes);
            ::builtin::assert_(::builtin::ext_equal(s1.subrange(::builtin::spec_literal_integer("0"),
                        write_addr),
                    s2.subrange(::builtin::spec_literal_integer("0"),
                        write_addr)));
            ::builtin::assert_(::builtin::ext_equal(s1.subrange(end,
                        ::builtin::spec_cast_integer::<_, int>(s1.len())),
                    s2.subrange(end,
                        ::builtin::spec_cast_integer::<_, int>(s1.len()))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_can_result_from_partial_write_effect_on_subranges(s2:
                Seq<u8>, s1: Seq<u8>, write_addr: int, bytes: Seq<u8>,
            inner_start: int, inner_end: int) {
            ::builtin::requires([#[verus::internal(trigger)] can_result_from_partial_write(s2,
                            s1, write_addr, bytes),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes.len())).spec_le(s1.len()),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            inner_start), inner_end), write_addr)) ||
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value((write_addr).spec_add(bytes.len())),
                                            inner_start), inner_end), s1.len()))]);
            ::builtin::ensures([::builtin::spec_eq(s1.subrange(inner_start,
                                inner_end),
                            #[verus::internal(trigger)] s2.subrange(inner_start,
                                inner_end))]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_partial_write_effect_on_match)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_subrange_subrange_dangerous)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_can_result_from_write_effect_on_read_state(v2:
                PersistentMemoryRegionView, v1: PersistentMemoryRegionView,
            write_addr: int, bytes: Seq<u8>) {
            ::builtin::requires([v1.valid(),
                        v2.can_result_from_write(v1, write_addr, bytes),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes.len())).spec_le(v1.len())]);
            ::builtin::ensures([v2.valid(),
                        seqs_match_except_in_range(v1.read_state, v2.read_state,
                            write_addr, (write_addr).spec_add(bytes.len())),
                        ::builtin::spec_eq(v2.read_state.subrange(write_addr,
                                (write_addr).spec_add(bytes.len())), bytes)]);
            let s1 = v1.read_state;
            let s2 = v2.read_state;
            let start = write_addr;
            let end = (write_addr).spec_add(bytes.len());
            ::builtin::assert_(::builtin::ext_equal(s1.subrange(::builtin::spec_literal_integer("0"),
                        start),
                    s2.subrange(::builtin::spec_literal_integer("0"), start)));
            ::builtin::assert_(::builtin::ext_equal(s1.subrange(end,
                        ::builtin::spec_cast_integer::<_, int>(s1.len())),
                    s2.subrange(end,
                        ::builtin::spec_cast_integer::<_, int>(s2.len()))));
            ::builtin::assert_(::builtin::ext_equal(v2.read_state.subrange(start,
                        end), bytes));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_can_result_from_write_effect_on_read_state(v2:
                PersistentMemoryRegionView, v1: PersistentMemoryRegionView,
            write_addr: int, bytes: Seq<u8>) {
            ::builtin::requires([v1.valid(),
                        #[verus::internal(trigger)] v2.can_result_from_write(v1,
                            write_addr, bytes),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes.len())).spec_le(v1.len())]);
            ::builtin::ensures([v2.valid(),
                        seqs_match_except_in_range(v1.read_state, v2.read_state,
                            write_addr, (write_addr).spec_add(bytes.len())),
                        ::builtin::spec_eq(v2.read_state.subrange(write_addr,
                                (write_addr).spec_add(bytes.len())), bytes)]);
            lemma_can_result_from_write_effect_on_read_state(v2, v1,
                write_addr, bytes);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_can_result_from_write_effect_on_read_state_subranges(v2:
                PersistentMemoryRegionView, v1: PersistentMemoryRegionView,
            write_addr: int, bytes: Seq<u8>, inner_start: int,
            inner_end: int) {
            ::builtin::requires([v1.valid(),
                        #[verus::internal(trigger)] v2.can_result_from_write(v1,
                            write_addr, bytes),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes.len())).spec_le(v1.len()),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            inner_start), inner_end), write_addr)) ||
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value((write_addr).spec_add(bytes.len())),
                                            inner_start), inner_end), v1.len()))]);
            ::builtin::ensures([::builtin::spec_eq(v1.read_state.subrange(inner_start,
                                inner_end),
                            #[verus::internal(trigger)] v2.read_state.subrange(inner_start,
                                inner_end))]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_write_effect_on_read_state)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_subrange_subrange_dangerous)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_length_of_subrange<T>(s: Seq<T>, i: int, j: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), j), s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(#[verus::internal(trigger)] s.subrange(i,
                                    j).len(), (j).spec_sub(i))]);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_subrange_subrange<T>(s: Seq<T>, outer_start: int,
            outer_end: int, inner_start: int, inner_end: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                outer_start), inner_start), inner_end), outer_end),
                                s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(s.subrange(inner_start,
                                inner_end),
                            s.subrange(outer_start,
                                    outer_end).subrange((inner_start).spec_sub(outer_start),
                                (inner_end).spec_sub(outer_start)))]);
            ::builtin::assert_(::builtin::ext_equal(s.subrange(inner_start,
                        inner_end),
                    s.subrange(outer_start,
                            outer_end).subrange((inner_start).spec_sub(outer_start),
                        (inner_end).spec_sub(outer_start))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_subrange_subrange_dangerous<T>(s: Seq<T>,
            outer_start: int, outer_end: int, inner_start: int,
            inner_end: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                outer_start), inner_start), inner_end), outer_end),
                                s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(#[verus::internal(trigger)] s.subrange(inner_start,
                                inner_end),
                            (#[verus::internal(trigger)] s.subrange(outer_start,
                                        outer_end)).subrange((inner_start).spec_sub(outer_start),
                                (inner_end).spec_sub(outer_start)))]);
            lemma_subrange_subrange(s, outer_start, outer_end, inner_start,
                inner_end);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_update_bytes_effect(s1: Seq<u8>, addr: int,
            bytes: Seq<u8>) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_le(addr),
                        ((addr).spec_add(bytes.len())).spec_le(s1.len())]);
            ::builtin::ensures([seqs_match_except_in_range(s1,
                            update_bytes(s1, addr, bytes), addr,
                            (addr).spec_add(bytes.len())),
                        ::builtin::spec_eq((#[verus::internal(trigger)] update_bytes(s1,
                                        addr, bytes)).subrange(addr, (addr).spec_add(bytes.len())),
                            bytes)]);
            let end = (addr).spec_add(bytes.len());
            let s2 = update_bytes(s1, addr, bytes);
            ::builtin::assert_(::builtin::ext_equal(s2.subrange(addr, end),
                    bytes));
            ::builtin::assert_(::builtin::ext_equal(s2.subrange(::builtin::spec_literal_integer("0"),
                        addr),
                    s1.subrange(::builtin::spec_literal_integer("0"), addr)));
            ::builtin::assert_(::builtin::ext_equal(s2.subrange(end,
                        ::builtin::spec_cast_integer::<_, int>(s1.len())),
                    s1.subrange(end,
                        ::builtin::spec_cast_integer::<_, int>(s1.len()))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_update_bytes_effect_on_subranges(s1: Seq<u8>,
            addr: int, bytes: Seq<u8>, inner_start: int, inner_end: int) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_le(addr),
                        ((addr).spec_add(bytes.len())).spec_le(s1.len()),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            inner_start), inner_end), addr)) ||
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value((addr).spec_add(bytes.len())),
                                            inner_start), inner_end), s1.len()))]);
            ::builtin::ensures([::builtin::spec_eq(#[verus::internal(trigger)] update_bytes(s1,
                                    addr, bytes).subrange(inner_start, inner_end),
                            s1.subrange(inner_start, inner_end))]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_update_bytes_effect)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn lemma_concatenate_subranges<T>(s: Seq<T>, pos1: int, pos2: int,
            pos3: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            pos1), pos2), pos3), s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(s.subrange(pos1, pos3),
                            (#[verus::internal(trigger)] s.subrange(pos1,
                                        pos2)).spec_add(#[verus::internal(trigger)] s.subrange(pos2,
                                    pos3)))]);
            ::builtin::assert_(::builtin::ext_equal(s.subrange(pos1, pos3),
                    (s.subrange(pos1, pos2)).spec_add(s.subrange(pos2, pos3))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_concatenate_three_subranges<T>(s: Seq<T>, pos1: int,
            pos2: int, pos3: int, pos4: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                pos1), pos2), pos3), pos4), s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(s.subrange(pos1, pos4),
                            ((s.subrange(pos1,
                                                pos2)).spec_add(s.subrange(pos2,
                                            pos3))).spec_add(s.subrange(pos3, pos4)))]);
            ::builtin::assert_(::builtin::ext_equal(s.subrange(pos1, pos4),
                    ((s.subrange(pos1,
                                        pos2)).spec_add(s.subrange(pos2,
                                    pos3))).spec_add(s.subrange(pos3, pos4))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_concatenate_four_subranges<T>(s: Seq<T>, pos1: int,
            pos2: int, pos3: int, pos4: int, pos5: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pos1), pos2), pos3), pos4), pos5), s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(s.subrange(pos1, pos5),
                            (((s.subrange(pos1,
                                                        pos2)).spec_add(s.subrange(pos2,
                                                    pos3))).spec_add(s.subrange(pos3,
                                            pos4))).spec_add(s.subrange(pos4, pos5)))]);
            ::builtin::assert_(::builtin::ext_equal(s.subrange(pos1, pos5),
                    (((s.subrange(pos1,
                                                pos2)).spec_add(s.subrange(pos2,
                                            pos3))).spec_add(s.subrange(pos3,
                                    pos4))).spec_add(s.subrange(pos4, pos5))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_seqs_match_in_range_can_narrow_range<T>(s1: Seq<T>,
            s2: Seq<T>, outer_start: int, outer_end: int, inner_start: int,
            inner_end: int) {
            ::builtin::requires([#[verus::internal(trigger)] seqs_match_in_range(s1,
                            s2, outer_start, outer_end),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                outer_start), inner_start), inner_end), outer_end),
                                s1.len()))]);
            ::builtin::ensures([::builtin::spec_eq(#[verus::internal(trigger)] s2.subrange(inner_start,
                                inner_end), s1.subrange(inner_start, inner_end))]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_subrange_subrange_dangerous)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_seqs_match_in_range_transitive<T>(s1: Seq<T>,
            s2: Seq<T>, s3: Seq<T>, outer_start: int, outer_end: int,
            inner_start: int, inner_end: int) {
            ::builtin::requires([seqs_match_in_range(s1, s2, inner_start,
                            inner_end),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                outer_start), inner_start), inner_end), outer_end),
                                s1.len())),
                        #[verus::internal(trigger)] seqs_match_in_range(s2, s3,
                            outer_start, outer_end)]);
            ::builtin::ensures([#[verus::internal(trigger)] seqs_match_in_range(s1,
                            s3, inner_start, inner_end)]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(reveal_group)]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn group_can_result_from_write_effect() {
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_partial_write_effect_on_match)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_partial_write_effect_on_subranges)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_write_effect_on_read_state)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_write_effect_on_read_state_subranges)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
        }
        #[verus::internal(reveal_group)]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn group_update_bytes_effect() {
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_update_bytes_effect)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_update_bytes_effect_on_subranges)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
        }
    }
    pub mod table_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::util_v::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::traits_t::*;
        use deps_hack::PmCopy;
        #[cfg(verus_keep_ghost)]
        use vstd::arithmetic::div_mod::{
            lemma_div_of0, lemma_div_plus_one,
            lemma_fundamental_div_mod_converse,
        };
        #[cfg(verus_keep_ghost)]
        use vstd::arithmetic::mul::{
            lemma_mul_basics, lemma_mul_inequality,
            lemma_mul_is_distributive_add_other_way,
        };
        #[repr(C)]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct TableMetadata {
            pub start: u64,
            pub end: u64,
            pub num_rows: u64,
            pub row_size: u64,
        }
        unsafe impl pmcopy for TableMetadata where u64: pmcopy, u64: pmcopy,
            u64: pmcopy, u64: pmcopy {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for TableMetadata {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                let offset: ::builtin::nat =
                    ::builtin::spec_literal_integer("0");
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    (offset).spec_add(spec_padding_needed(offset,
                            <TableMetadata>::spec_align_of()));
                offset
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                let alignment_seq =
                    <_ as
                            ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of(),
                                    <u64>::spec_align_of(), <u64>::spec_align_of(),
                                    <u64>::spec_align_of()]);
                nat_seq_max(alignment_seq)
            }
        }
        unsafe impl PmSized for TableMetadata {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for TableMetadata {
            const SIZE: usize =
                {
                    let offset: usize = 0;
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + padding_needed(offset, <TableMetadata>::ALIGN);
                    offset
                };
            const ALIGN: usize =
                {
                    let mut largest_alignment: usize = 0;
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    largest_alignment
                };
        }
        const SIZE_CHECK_TABLEMETADATA: usize =
            (core::mem::size_of::<TableMetadata>() == <TableMetadata>::SIZE)
                    as usize - 1;
        const ALIGN_CHECK_TABLEMETADATA: usize =
            (core::mem::align_of::<TableMetadata>() == <TableMetadata>::ALIGN)
                    as usize - 1;
        unsafe impl UnsafeSpecPmSized for TableMetadata {}
        impl Clone for TableMetadata {
            fn clone(&self) -> Self {
                Self {
                    start: self.start.clone(),
                    end: self.end.clone(),
                    num_rows: self.num_rows.clone(),
                    row_size: self.row_size.clone(),
                }
            }
        }
        impl PartialEq for TableMetadata {
            fn eq(&self, other: &Self) -> bool {
                self.start == other.start && self.end == other.end &&
                        self.num_rows == other.num_rows &&
                    self.row_size == other.row_size
            }
        }
        impl Eq for TableMetadata {}
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_tablemetadata_clone(b: &TableMetadata) -> TableMetadata {
            ::builtin::ensures(|res: TableMetadata|
                    [::builtin::spec_eq(*b, res)]);
            b.clone()
        }
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_tablemetadata_eq(lhs: &TableMetadata, rhs: &TableMetadata)
            -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
            lhs.eq(rhs)
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for TableMetadata {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> TableMetadata {
                ::builtin::ensures(|res: TableMetadata|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for TableMetadata {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self.eq(other)
            }
        }
        impl PmCopy for TableMetadata {}
        #[automatically_derived]
        impl ::core::marker::Copy for TableMetadata { }
        #[verus::internal(verus_macro)]
        impl TableMetadata {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                ((::builtin::spec_literal_nat("0")).spec_lt(self.row_size)) &&
                    (((::builtin::spec_cast_integer::<_,
                                                int>(self.num_rows)).spec_mul(self.row_size)).spec_le((self.end).spec_sub(self.start)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_row_index_to_addr(self, row_index: int) -> u64 {
                ::builtin::spec_cast_integer::<_,
                        u64>(((self.start).spec_add((row_index).spec_mul(self.row_size))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn row_index_to_addr(self, row_index: u64) -> u64 {
                ::builtin::requires([self.valid(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        row_index), self.num_rows))]);
                ::builtin::ensures(|out: u64|
                        [::builtin::spec_eq(out,
                                    self.spec_row_index_to_addr(::builtin::spec_cast_integer::<_,
                                                int>(row_index)))]);

                #[verifier::proof_block]
                {
                    lemma_row_index_to_addr_is_valid(self,
                        ::builtin::spec_cast_integer::<_, int>(row_index));
                }
                self.start + row_index * self.row_size
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn row_addr_to_index(self, addr: u64) -> int {
                (((addr).spec_sub(self.start))).spec_euclidean_div((::builtin::spec_cast_integer::<_,
                                int>(self.row_size)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn validate_row_addr(self, addr: u64) -> bool {
                let row_index = self.row_addr_to_index(addr);
                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    row_index), self.num_rows))) &&
                    (::builtin::spec_eq(addr,
                            (self.start).spec_add((row_index).spec_mul(self.row_size))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new(start: u64, end: u64, num_rows: u64, row_size: u64)
                -> Self {
                ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_lt(row_size),
                            ((num_rows).spec_mul(row_size)).spec_le((end).spec_sub(start))]);
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq(result,
                                    (Self { start, end, num_rows, row_size })),
                                result.valid()]);
                Self { start, end, num_rows, row_size }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_start_is_valid_row(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([::builtin::spec_eq(self.row_addr_to_index(self.start),
                                ::builtin::spec_literal_nat("0")),
                            ::builtin::imply((self.num_rows).spec_gt(::builtin::spec_literal_nat("0")),
                                self.validate_row_addr(self.start))]);
                lemma_div_of0(::builtin::spec_cast_integer::<_,
                            int>(self.row_size));
                ::builtin::assert_(::builtin::spec_eq((::builtin::spec_literal_int("0")).spec_euclidean_div(::builtin::spec_cast_integer::<_,
                                    int>(self.row_size)), ::builtin::spec_literal_nat("0")));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_row_addr_successor_is_valid(self, addr: u64) {
                ::builtin::requires([self.valid(),
                            self.validate_row_addr(addr),
                            ((addr).spec_add(self.row_size)).spec_le(self.end)]);
                ::builtin::ensures([({
                                    let row_index = self.row_addr_to_index(addr);
                                    let new_addr =
                                        ::builtin::spec_cast_integer::<_,
                                                u64>(((addr).spec_add(self.row_size)));
                                    ((::builtin::spec_eq(self.row_addr_to_index(new_addr),
                                                        (row_index).spec_add(::builtin::spec_literal_nat("1")))) &&
                                                (((row_index).spec_add(::builtin::spec_literal_nat("1"))).spec_le(self.num_rows)))
                                        &&
                                        (::builtin::imply(((row_index).spec_add(::builtin::spec_literal_nat("1"))).spec_lt(self.num_rows),
                                                self.validate_row_addr(new_addr)))
                                })]);
                let new_addr = (addr).spec_add(self.row_size);
                let row_index = self.row_addr_to_index(addr);
                let new_row =
                    (((new_addr).spec_sub(self.start))).spec_euclidean_div((::builtin::spec_cast_integer::<_,
                                    int>(self.row_size)));
                lemma_mul_inequality((row_index).spec_add(::builtin::spec_literal_nat("1")),
                    ::builtin::spec_cast_integer::<_, int>(self.num_rows),
                    ::builtin::spec_cast_integer::<_, int>(self.row_size));
                {
                    ::builtin::assert_by(::builtin::spec_eq(new_row,
                            (row_index).spec_add(::builtin::spec_literal_nat("1"))),
                        {
                            lemma_div_plus_one((addr).spec_sub(self.start),
                                ::builtin::spec_cast_integer::<_, int>(self.row_size));
                        });
                }
                {
                    ::builtin::assert_by(::builtin::spec_eq((addr).spec_add(self.row_size),
                            (self.start).spec_add((((row_index).spec_add(::builtin::spec_literal_nat("1")))).spec_mul(self.row_size))),
                        {
                            lemma_mul_is_distributive_add_other_way(::builtin::spec_cast_integer::<_,
                                        int>(self.row_size),
                                ::builtin::spec_cast_integer::<_, int>(row_index),
                                ::builtin::spec_literal_integer("1"));
                            lemma_mul_basics(::builtin::spec_cast_integer::<_,
                                        int>(self.row_size));
                        });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_index_addr_inverse(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([::builtin::forall(|addr: u64|
                                    ::builtin::imply(#[verus::internal(trigger)] self.validate_row_addr(addr),
                                        {
                                            let row = self.row_addr_to_index(addr);
                                            ::builtin::spec_eq(addr, self.spec_row_index_to_addr(row))
                                        })),
                            ::builtin::forall(|i: int|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), self.num_rows)),
                                        {
                                            let addr =
                                                #[verus::internal(trigger)] self.spec_row_index_to_addr(i);
                                            ::builtin::spec_eq(i, self.row_addr_to_index(addr))
                                        }))]);
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), self.num_rows)));
                                ::builtin::ensures({
                                        let addr =
                                            #[verus::internal(trigger)] self.spec_row_index_to_addr(i);
                                        ::builtin::spec_eq(i, self.row_addr_to_index(addr))
                                    });
                                lemma_row_index_to_addr_is_valid(self, i);
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_valid_row_set_len(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([({
                                    let valid_row_addrs =
                                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                                        u64| self.validate_row_addr(row_addr)));
                                    (::builtin::spec_eq(valid_row_addrs.len(), self.num_rows))
                                        && (valid_row_addrs.finite())
                                })]);
                let valid_row_addrs =
                    Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                    u64| self.validate_row_addr(row_addr)));
                let rows: Seq<u64> =
                    Seq::new(::builtin::spec_cast_integer::<_,
                                nat>(self.num_rows),
                        ::builtin::closure_to_fn_spec(|row_index: int|
                                self.spec_row_index_to_addr(row_index)));
                {
                    ::builtin::assert_by(rows.no_duplicates(),
                        {
                            {
                                ::builtin::assert_forall_by(|i, j|
                                        {
                                            ::builtin::requires((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        i), rows.len())) &&
                                                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        j), rows.len())) && !::builtin::spec_eq(i, j)));
                                            ::builtin::ensures(!::builtin::spec_eq(rows.spec_index(i),
                                                        rows.spec_index(j)));
                                            lemma_row_index_to_addr_is_valid(self, i);
                                            lemma_row_index_to_addr_is_valid(self, j);
                                        });
                            }
                        });
                }
                {
                    ::builtin::assert_by(::builtin::ext_equal(rows.to_set(),
                            valid_row_addrs),
                        {
                            {
                                ::builtin::assert_forall_by(|row_addr: u64|
                                        {
                                            ::builtin::requires(#[verus::internal(trigger)] rows.to_set().contains(row_addr));
                                            ::builtin::ensures(valid_row_addrs.contains(row_addr));
                                            let row_index =
                                                ::builtin::choose::<int,
                                                        _>(|row_index: int|
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        row_index), rows.len())) &&
                                                            ::builtin::spec_eq(rows.spec_index(row_index), row_addr));
                                            lemma_row_index_to_addr_is_valid(self, row_index);
                                        });
                            }
                            {
                                ::builtin::assert_forall_by(|row_addr: u64|
                                        {
                                            ::builtin::requires(#[verus::internal(trigger)] valid_row_addrs.contains(row_addr));
                                            ::builtin::ensures(rows.to_set().contains(row_addr));
                                            let row_index = self.row_addr_to_index(row_addr);
                                            ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            row_index), rows.len())));
                                            ::builtin::assert_(::builtin::spec_eq(rows.spec_index(row_index),
                                                    row_addr));
                                        });
                            }
                        });
                }
                rows.unique_seq_to_set();
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_validate_row_addr_effects(tm: TableMetadata,
            addr: u64) {
            ::builtin::requires([tm.valid(),
                        #[verus::internal(trigger)] tm.validate_row_addr(addr)]);
            ::builtin::ensures([(tm.start).spec_le(addr),
                        ((addr).spec_add(tm.row_size)).spec_le(tm.end),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    tm.row_addr_to_index(addr)), tm.num_rows))]);
            let row_index = tm.row_addr_to_index(addr);
            lemma_mul_inequality((row_index).spec_add(::builtin::spec_literal_nat("1")),
                ::builtin::spec_cast_integer::<_, int>(tm.num_rows),
                ::builtin::spec_cast_integer::<_, int>(tm.row_size));
            {
                ::builtin::assert_by(::builtin::spec_eq((addr).spec_add(tm.row_size),
                        (tm.start).spec_add((((row_index).spec_add(::builtin::spec_literal_nat("1")))).spec_mul(tm.row_size))),
                    {
                        lemma_mul_is_distributive_add_other_way(::builtin::spec_cast_integer::<_,
                                    int>(tm.row_size),
                            ::builtin::spec_cast_integer::<_, int>(row_index),
                            ::builtin::spec_literal_integer("1"));
                        lemma_mul_basics(::builtin::spec_cast_integer::<_,
                                    int>(tm.row_size));
                    });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_validate_row_addr_nonoverlapping(tm: TableMetadata,
            addr1: u64, addr2: u64) {
            ::builtin::requires([tm.valid(),
                        #[verus::internal(trigger)] tm.validate_row_addr(addr1),
                        #[verus::internal(trigger)] tm.validate_row_addr(addr2)]);
            ::builtin::ensures([::builtin::imply(!::builtin::spec_eq(addr1,
                                    addr2),
                            {
                                (((addr1).spec_add(tm.row_size)).spec_le(addr2)) ||
                                    (((addr2).spec_add(tm.row_size)).spec_le(addr1))
                            }),
                        ::builtin::imply(!::builtin::spec_eq(addr1, addr2),
                            !::builtin::spec_eq(tm.row_addr_to_index(addr1),
                                    tm.row_addr_to_index(addr2)))]);
            let row_index1 = tm.row_addr_to_index(addr1);
            let row_index2 = tm.row_addr_to_index(addr2);
            if (row_index1).spec_lt(row_index2) {
                    lemma_mul_inequality((row_index1).spec_add(::builtin::spec_literal_nat("1")),
                        ::builtin::spec_cast_integer::<_, int>(row_index2),
                        ::builtin::spec_cast_integer::<_, int>(tm.row_size));
                }
            if (row_index1).spec_gt(row_index2) {
                    lemma_mul_inequality((row_index2).spec_add(::builtin::spec_literal_nat("1")),
                        ::builtin::spec_cast_integer::<_, int>(row_index1),
                        ::builtin::spec_cast_integer::<_, int>(tm.row_size));
                }
            lemma_mul_is_distributive_add_other_way(::builtin::spec_cast_integer::<_,
                        int>(tm.row_size),
                ::builtin::spec_cast_integer::<_, int>(row_index1),
                ::builtin::spec_literal_integer("1"));
            lemma_mul_is_distributive_add_other_way(::builtin::spec_cast_integer::<_,
                        int>(tm.row_size),
                ::builtin::spec_cast_integer::<_, int>(row_index2),
                ::builtin::spec_literal_integer("1"));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn lemma_row_index_to_addr_is_valid(tm: TableMetadata,
            row_index: int) {
            ::builtin::requires([tm.valid(),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    row_index), tm.num_rows))]);
            ::builtin::ensures([tm.validate_row_addr(#[verus::internal(trigger)] tm.spec_row_index_to_addr(row_index)),
                        ::builtin::spec_eq(tm.row_addr_to_index(tm.spec_row_index_to_addr(row_index)),
                            row_index)]);
            let addr = tm.spec_row_index_to_addr(row_index);
            {
                ::builtin::assert_by(((row_index).spec_mul(tm.row_size)).spec_le((tm.num_rows).spec_mul(tm.row_size)),
                    {
                        lemma_mul_inequality(row_index,
                            ::builtin::spec_cast_integer::<_, int>(tm.num_rows),
                            ::builtin::spec_cast_integer::<_, int>(tm.row_size));
                    });
            }
            {
                ::builtin::assert_by(::builtin::spec_eq(row_index,
                        tm.row_addr_to_index(addr)),
                    {
                        lemma_fundamental_div_mod_converse((addr).spec_sub(tm.start),
                            ::builtin::spec_cast_integer::<_, int>(tm.row_size),
                            row_index, ::builtin::spec_literal_integer("0"));
                    });
            }
        }
        #[verus::internal(reveal_group)]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn group_validate_row_addr() {
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_validate_row_addr_effects)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(broadcast_validate_row_addr_nonoverlapping)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
        }
    }
    pub mod util_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::seq_lib::*;
        use vstd::set_lib::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::traits_t::{
            size_of, PmSized, ConstPmSized, UnsafeSpecPmSized, PmSafe,
        };
        use crate::pmem::pmemutil_v::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn nat_seq_max(seq: Seq<nat>) -> nat {
            ::builtin::recommends([(::builtin::spec_literal_nat("0")).spec_lt(seq.len())]);
            ::builtin::decreases((seq.len()));
            if ::builtin::spec_eq(seq.len(), ::builtin::spec_literal_nat("1"))
                    {
                    seq.spec_index(::builtin::spec_literal_integer("0"))
                } else if ::builtin::spec_eq(seq.len(),
                       ::builtin::spec_literal_nat("0")) {
                   ::builtin::spec_literal_integer("0")
               } else {
                   let later_max = nat_seq_max(seq.drop_first());
                   if (seq.spec_index(::builtin::spec_literal_integer("0"))).spec_ge(later_max)
                           {
                           seq.spec_index(::builtin::spec_literal_integer("0"))
                       } else { later_max }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_subrange_of_extract_bytes_equal(mem: Seq<u8>,
            start1: nat, start2: nat, len1: nat, len2: nat) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(start1),
                                            start2), (start2).spec_add(len2)), (start1).spec_add(len1)),
                                mem.len()))]);
            ::builtin::ensures([({
                                let start_offset = (start2).spec_sub(start1);
                                ::builtin::ext_equal(extract_bytes(extract_bytes(mem,
                                            start1, len1),
                                        ::builtin::spec_cast_integer::<_, nat>(start_offset), len2),
                                    extract_bytes(mem, start2, len2))
                            })]);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_seqs_flatten_equal_suffix(s: Seq<Seq<u8>>) {
            ::builtin::requires([(s.len()).spec_ge(::builtin::spec_literal_nat("1"))]);
            ::builtin::ensures([({
                                let last =
                                    s.spec_index((s.len()).spec_sub(::builtin::spec_literal_nat("1")));
                                let prefix =
                                    s.subrange(::builtin::spec_literal_integer("0"),
                                        (s.len()).spec_sub(::builtin::spec_literal_nat("1")));
                                ::builtin::spec_eq(s.flatten(),
                                    (prefix.flatten()).spec_add(last))
                            })]);
            ::builtin::decreases((s.len()));
            if ::builtin::spec_eq(s.len(), ::builtin::spec_literal_nat("1")) {
                    let last =
                        s.spec_index(::builtin::spec_literal_integer("0"));
                    ::builtin::assert_(::builtin::spec_eq(s,
                            ::vstd::vstd::seq::Seq::empty().push(last)));
                    ::vstd::vstd::seq::Seq::empty().push(last).lemma_flatten_one_element();
                    ::builtin::assert_(::builtin::spec_eq(::vstd::vstd::seq::Seq::empty().push(last).flatten(),
                            last));
                } else {
                   let first =
                       s.spec_index(::builtin::spec_literal_integer("0"));
                   let last =
                       s.spec_index((s.len()).spec_sub(::builtin::spec_literal_nat("1")));
                   let middle =
                       s.subrange(::builtin::spec_literal_integer("0"),
                               (s.len()).spec_sub(::builtin::spec_literal_nat("1"))).drop_first();
                   let suffix = s.drop_first();
                   ::builtin::assert_(::builtin::spec_eq(middle,
                           suffix.subrange(::builtin::spec_literal_integer("0"),
                               (suffix.len()).spec_sub(::builtin::spec_literal_nat("1")))));
                   lemma_seqs_flatten_equal_suffix(suffix);
                   ::builtin::assert_(::builtin::spec_eq(suffix.flatten(),
                           (middle.flatten()).spec_add(last)));
                   ::builtin::assert_(::builtin::spec_eq((first).spec_add(suffix.flatten()),
                           ((first).spec_add(middle.flatten())).spec_add(last)));
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_injective_map_is_invertible<K, V>(map: Map<K, V>) {
            ::builtin::requires([map.is_injective()]);
            ::builtin::ensures([::builtin::spec_eq(map,
                            map.invert().invert())]);
            map.lemma_invert_is_injective();
            map.invert().lemma_invert_is_injective();
            ::builtin::assert_(::builtin::spec_eq(map.invert().dom(),
                    map.values()));
            lemma_injective_map_inverse(map);
            lemma_injective_map_inverse(map.invert());
            ::builtin::assert_(::builtin::ext_equal(map,
                    map.invert().invert()));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_injective_map_inverse<K, V>(map: Map<K, V>) {
            ::builtin::requires([map.is_injective()]);
            ::builtin::ensures([::builtin::forall(|k: K|
                                ::builtin::imply(map.contains_key(k),
                                    {
                                        let v = map.spec_index(k);
                                        ::builtin::spec_eq(map.invert().spec_index(v), k)
                                    }))]);
            {
                ::builtin::assert_forall_by(|k: K|
                        {
                            ::builtin::requires(map.contains_key(k));
                            ::builtin::ensures({
                                    let v = map.spec_index(k);
                                    ::builtin::spec_eq(map.invert().spec_index(v), k)
                                });
                            let v = map.spec_index(k);
                            if !::builtin::spec_eq(map.invert().spec_index(v), k) {
                                    let k_prime = map.invert().spec_index(v);
                                    ::builtin::assert_(map.contains_pair(k, v));
                                    ::builtin::assert_(map.contains_pair(k_prime, v));
                                    ::builtin::assert_(!::builtin::spec_eq(k, k_prime));
                                    ::builtin::assert_(false);
                                }
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_seq_len_when_no_dup_and_all_values_in_range(s: Seq<int>,
            min: int, max: int) {
            ::builtin::requires([s.no_duplicates(), (min).spec_le(max),
                        ::builtin::forall(|e: int|
                                ::builtin::imply(s.contains(e),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(min),
                                                e), max))))]);
            ::builtin::ensures([(s.len()).spec_le((max).spec_sub(min))]);
            let s_set = s.to_set();
            s.unique_seq_to_set();
            ::builtin::assert_(s_set.subset_of(set_int_range(min, max)));
            lemma_int_range(min, max);
            lemma_len_subset(s_set, set_int_range(min, max));
            ::builtin::assert_((s.len()).spec_le(set_int_range(min,
                            max).len()));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn clone_pmcopy_vec<T: PmCopy>(v: &Vec<T>) -> Vec<T> {
            ::builtin::ensures(|result: Vec<T>|
                    [::builtin::spec_eq((result.view()), (v.view()))]);
            let mut result = Vec::<T>::new();

            #[verifier::proof_block]
            {

                #[verus::internal(const_header_wrapper)]
                ||
                    {
                        ::builtin::assert_(::builtin::ext_equal((v.view()).take(::builtin::spec_literal_int("0")),
                                Seq::<T>::empty()))
                    };
            };
            {
                #[allow(non_snake_case)]
                let VERUS_loop_result =
                    match ::core::iter::IntoIterator::into_iter(0..v.len())
                        {
                            #[allow(non_snake_case)]
                            mut VERUS_exec_iter => {
                            #[allow(non_snake_case)]
                            #[verus::internal(spec)]
                            let mut VERUS_ghost_iter;

                            #[verifier::proof_block]
                            {
                                VERUS_ghost_iter =
                                    ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                            }

                            #[verus::internal(for_loop)]
                            loop {
                                ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                &VERUS_exec_iter),
                                            #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..v.len())),
                                                    true)),
                                            {
                                                let pos =
                                                    ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                ::builtin::spec_eq((result.view()),
                                                    (v.view()).take(::builtin::spec_cast_integer::<_,
                                                                int>(pos)))
                                            }]);
                                ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                {
                                    #[allow(non_snake_case)]
                                    let mut VERUS_loop_next;
                                    match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                        ::core::option::Option::Some(VERUS_loop_val) => {
                                            VERUS_loop_next = VERUS_loop_val;
                                        }
                                        ::core::option::Option::None => break,
                                    };
                                    let pos = VERUS_loop_next;
                                    let () =
                                        {

                                            #[verifier::proof_block]
                                            {

                                                #[verus::internal(const_header_wrapper)]
                                                ||
                                                    {
                                                        ::builtin::assert_(::builtin::ext_equal((v.view()).take(::builtin::spec_cast_integer::<_,
                                                                                int>(pos)).push((v.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                                int>(pos))),
                                                                (v.view()).take((pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                    };
                                            };
                                            result.push(v[pos].clone_provable());
                                        };
                                }

                                #[verifier::proof_block]
                                {
                                    VERUS_ghost_iter =
                                        ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                            &VERUS_exec_iter);
                                }
                            }
                        }
                    };
                VERUS_loop_result
            }

            #[verifier::proof_block]
            {

                #[verus::internal(const_header_wrapper)]
                ||
                    {
                        ::builtin::assert_(::builtin::ext_equal((v.view()).take(::builtin::spec_cast_integer::<_,
                                            int>((v.view()).len())), (v.view())))
                    };
            };
            result
        }
        #[inline]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn extend_vec_u8_from_slice(v: &mut Vec<u8>, s: &[u8]) {
            ::builtin::ensures([::builtin::spec_eq((v.view()),
                            ((old(v).view())).spec_add((s.view())))]);
            v.extend_from_slice(s);

            #[verifier::proof_block]
            {

                #[verus::internal(const_header_wrapper)]
                ||
                    {
                        ::builtin::assert_(::builtin::ext_equal((v.view()),
                                ((old(v).view())).spec_add((s.view()))))
                    };
            };
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_set_to_seq_contains_iff_set_contains<A>(s: Set<A>,
            v: A) {
            ::builtin::requires([s.finite()]);
            ::builtin::ensures([(s.contains(v)) == (s.to_seq().contains(v))]);
            ::builtin::decreases((s.len(),));
            if !::builtin::spec_eq(s.len(), ::builtin::spec_literal_nat("0"))
                    {
                    let x = s.choose();
                    let s2 = s.remove(x).to_seq();
                    ::builtin::assert_(::builtin::spec_eq(s.to_seq(),
                            (Seq::<A>::empty().push(x)).spec_add(s2)));
                    if ::builtin::spec_eq(v, x) {
                            ::builtin::assert_(s.contains(v));
                            ::builtin::assert_(::builtin::spec_eq(s.to_seq().spec_index(::builtin::spec_literal_integer("0")),
                                    v));
                            ::builtin::assert_(s.to_seq().contains(v));
                        } else {
                           lemma_set_to_seq_contains_iff_set_contains(s.remove(x), v);
                           if s.contains(v) {
                                   ::builtin::assert_(s.remove(x).contains(v));
                                   ::builtin::assert_(s.remove(x).to_seq().contains(v));
                                   let i =
                                       ::builtin::choose::<int,
                                               _>(|i: int|
                                               ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                               i), s2.len())) && ::builtin::spec_eq(s2.spec_index(i), v));
                                   ::builtin::assert_(::builtin::spec_eq(s.to_seq().spec_index((i).spec_add(::builtin::spec_literal_nat("1"))),
                                           v));
                                   ::builtin::assert_(s.to_seq().contains(v));
                               }
                       }
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_set_to_seq_has_same_length_with_no_duplicates<A>(s:
                Set<A>) {
            ::builtin::requires([s.finite()]);
            ::builtin::ensures([::builtin::spec_eq(s.to_seq().len(), s.len()),
                        s.to_seq().no_duplicates()]);
            ::builtin::decreases((s.len(),));
            let q = s.to_seq();
            if !::builtin::spec_eq(s.len(), ::builtin::spec_literal_nat("0"))
                    {
                    let x = s.choose();
                    lemma_set_to_seq_has_same_length_with_no_duplicates(s.remove(x));
                    {
                        ::builtin::assert_by(!s.remove(x).to_seq().contains(x),
                            {
                                lemma_set_to_seq_contains_iff_set_contains(s.remove(x), x);
                            });
                    }
                }
            q.unique_seq_to_set();
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_bijection_makes_sets_have_equal_size<A,
            B>(s1: Set<A>, s2: Set<B>, f: ::builtin::FnSpec<(A,), B>,
            g: ::builtin::FnSpec<(B,), A>) {
            ::builtin::requires([s1.finite(),
                        ::builtin::forall(|x: A|
                                ::builtin::imply(#[verus::internal(trigger)] s1.contains(x),
                                    s2.contains(f(x)) && ::builtin::spec_eq(x, g(f(x))))),
                        ::builtin::forall(|y: B|
                                ::builtin::imply(#[verus::internal(trigger)] s2.contains(y),
                                    s1.contains(g(y)) && ::builtin::spec_eq(y, f(g(y)))))]);
            ::builtin::ensures([s2.finite(),
                        ::builtin::spec_eq(s2.len(), s1.len())]);
            let q1 = s1.to_seq();
            {
                ::builtin::assert_forall_by(|x: A|
                        {
                            ::builtin::ensures((#[verus::internal(trigger)] q1.contains(x))
                                    == (s1.contains(x)));
                            lemma_set_to_seq_contains_iff_set_contains(s1, x);
                        });
            }
            {
                ::builtin::assert_by(::builtin::spec_eq(q1.len(), s1.len()) &&
                        q1.no_duplicates(),
                    {
                        lemma_set_to_seq_has_same_length_with_no_duplicates(s1);
                    });
            }
            let q2 =
                Seq::<B>::new(q1.len(),
                    ::builtin::closure_to_fn_spec(|i: int|
                            f(q1.spec_index(i))));
            {
                ::builtin::assert_by(::builtin::ext_equal(q2.to_set(), s2),
                    {
                        {
                            ::builtin::assert_forall_by(|y: B|
                                    {
                                        ::builtin::requires(#[verus::internal(trigger)] q2.to_set().contains(y));
                                        ::builtin::ensures(s2.contains(y));
                                        ::builtin::assert_(q2.contains(y));
                                        let i =
                                            ::builtin::choose::<int,
                                                    _>(|i: int|
                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    i), q2.len())) && ::builtin::spec_eq(q2.spec_index(i), y));
                                        ::builtin::assert_(::builtin::spec_eq(y,
                                                f(q1.spec_index(i))));
                                        ::builtin::assert_(q1.contains(q1.spec_index(i)));
                                        ::builtin::assert_(s1.contains(q1.spec_index(i)));
                                        ::builtin::assert_(s2.contains(f(q1.spec_index(i))));
                                    });
                        }
                        {
                            ::builtin::assert_forall_by(|y: B|
                                    {
                                        ::builtin::requires(#[verus::internal(trigger)] s2.contains(y));
                                        ::builtin::ensures(q2.to_set().contains(y));
                                        ::builtin::assert_(s1.contains(g(y)));
                                        let x = g(y);
                                        ::builtin::assert_(q1.contains(x));
                                        let i =
                                            ::builtin::choose::<int,
                                                    _>(|i: int|
                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    i), q1.len())) && ::builtin::spec_eq(q1.spec_index(i), x));
                                        ::builtin::assert_(::builtin::spec_eq(q2.spec_index(i),
                                                f(x)));
                                        ::builtin::assert_(q2.to_set().contains(f(x)));
                                        ::builtin::assert_(::builtin::spec_eq(f(x), y));
                                    });
                        }
                    });
            }
            {
                ::builtin::assert_by(q2.no_duplicates(),
                    {
                        {
                            ::builtin::assert_forall_by(|i: int, j: int|
                                    {
                                        ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i), q2.len())) &&
                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                j), q2.len())) && !::builtin::spec_eq(i, j));
                                        ::builtin::ensures(!::builtin::spec_eq(q2.spec_index(i),
                                                    q2.spec_index(j)));
                                        ::builtin::assert_(::builtin::spec_eq(q2.spec_index(i),
                                                    f(q1.spec_index(i))) &&
                                                ::builtin::spec_eq(q2.spec_index(j), f(q1.spec_index(j))));
                                        ::builtin::assert_(q1.contains(q1.spec_index(i)) &&
                                                q1.contains(q1.spec_index(j)));
                                        ::builtin::assert_(s1.contains(q1.spec_index(i)) &&
                                                s1.contains(q1.spec_index(j)));
                                        let x1 = g(q2.spec_index(i));
                                        let x2 = g(q2.spec_index(j));
                                        ::builtin::assert_(::builtin::spec_eq(x1, q1.spec_index(i))
                                                && ::builtin::spec_eq(x2, q1.spec_index(j)));
                                    });
                        }
                    });
            }
            {
                ::builtin::assert_by(::builtin::spec_eq(q2.len(), s2.len()),
                    { q2.unique_seq_to_set(); });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_fold_equivalent_to_map_fold<A, B,
            C>(c: C, s: Seq<A>, f: ::builtin::FnSpec<(A,), B>,
            g: ::builtin::FnSpec<(C, A), C>,
            h: ::builtin::FnSpec<(C, B), C>) {
            ::builtin::requires([::builtin::forall(|k: C, a: A|
                                ::builtin::imply(s.contains(a),
                                    ::builtin::spec_eq(#[verus::internal(trigger)] g(k, a),
                                        h(k, f(a)))))]);
            ::builtin::ensures([::builtin::spec_eq(s.fold_left(c, g),
                            s.map_values(f).fold_left(c, h))]);
            ::builtin::decreases((s.len(),));
            if !::builtin::spec_eq(s.len(), ::builtin::spec_literal_nat("0"))
                    {
                    lemma_fold_equivalent_to_map_fold(c, s.drop_last(), f, g,
                        h);
                    ::builtin::assert_(::builtin::ext_equal(s.drop_last().map_values(f),
                            s.map_values(f).drop_last()));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_if_filter_contains_then_original_contains<A>(s: Seq<A>,
            pred: ::builtin::FnSpec<(A,), bool>, x: A) {
            ::builtin::ensures([::builtin::imply(s.filter(pred).contains(x),
                            s.contains(x) && pred(x))]);
            ::builtin::decreases((s.len(),));
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(Seq::filter)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            if !::builtin::spec_eq(s.len(), ::builtin::spec_literal_nat("0"))
                    {
                    lemma_if_filter_contains_then_original_contains(s.drop_last(),
                        pred, x);
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_filter_preserves_no_duplicates<A>(s: Seq<A>,
            pred: ::builtin::FnSpec<(A,), bool>) {
            ::builtin::requires([s.no_duplicates()]);
            ::builtin::ensures([s.filter(pred).no_duplicates()]);
            ::builtin::decreases((s.len(),));
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(Seq::filter)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            if (s.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    lemma_filter_preserves_no_duplicates(s.drop_last(), pred);
                    ::builtin::assert_(s.drop_last().filter(pred).no_duplicates());
                    if s.drop_last().filter(pred).contains(s.last()) {
                            lemma_if_filter_contains_then_original_contains(s.drop_last(),
                                pred, s.last());
                            ::builtin::assert_(s.drop_last().contains(s.last()));
                            let i =
                                ::builtin::choose::<int,
                                        _>(|i: int|
                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), s.drop_last().len())) &&
                                            ::builtin::spec_eq(s.drop_last().spec_index(i), s.last()));
                            let j =
                                (s.len()).spec_sub(::builtin::spec_literal_nat("1"));
                            ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), s.len())) &&
                                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        j), s.len())) && !::builtin::spec_eq(i, j) &&
                                    ::builtin::spec_eq(s.spec_index(i), s.spec_index(j)));
                            ::builtin::assert_(false);
                        }
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn commutative_foldl<A, B>(f: ::builtin::FnSpec<(B, A), B>)
            -> bool {
            ::builtin::forall(|x: A, y: A, v: B|
                    ::builtin::spec_eq(#[verus::internal(trigger)] f(f(v, x),
                            y), f(f(v, y), x)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn convert_foldl_to_foldr<A, B>(f: ::builtin::FnSpec<(B, A), B>)
            -> (::builtin::FnSpec<(A, B), B>) {
            ::builtin::closure_to_fn_spec(|a: A, b: B| f(b, a))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_commutative_foldl_equivalent_to_corresponding_foldr<A,
            B>(s: Seq<A>, b: B, f: ::builtin::FnSpec<(B, A), B>) {
            ::builtin::requires([commutative_foldl(f)]);
            ::builtin::ensures([commutative_foldr(convert_foldl_to_foldr(f)),
                        ::builtin::spec_eq(s.fold_left(b, f),
                            s.fold_right(convert_foldl_to_foldr(f), b))]);
            ::builtin::decreases((s.len(),));
            if (s.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    let fr = convert_foldl_to_foldr(f);
                    lemma_commutative_foldl_equivalent_to_corresponding_foldr(s.drop_last(),
                        b, f);
                    s.drop_last().lemma_fold_right_commute_one(s.last(),
                        convert_foldl_to_foldr(f), b);
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_two_seqs_with_no_duplicates_and_same_to_set_are_permutations<A>(s1:
                Seq<A>, s2: Seq<A>) {
            ::builtin::requires([s1.no_duplicates(), s2.no_duplicates(),
                        ::builtin::spec_eq(s1.to_set(), s2.to_set())]);
            ::builtin::ensures([::builtin::spec_eq(s1.to_multiset(),
                            s2.to_multiset())]);
            s1.lemma_multiset_has_no_duplicates();
            s2.lemma_multiset_has_no_duplicates();
            let m1 = s1.to_multiset();
            let m2 = s2.to_multiset();
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(to_multiset_contains)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            {
                ::builtin::assert_forall_by(|x|
                        {
                            ::builtin::requires(m1.contains(x));
                            ::builtin::ensures(m2.contains(x) &&
                                    ::builtin::spec_eq(m2.count(x), m1.count(x)));
                            ::builtin::assert_(s1.contains(x));
                            ::builtin::assert_(s1.to_set().contains(x));
                            ::builtin::assert_(s2.to_set().contains(x));
                            ::builtin::assert_(s2.contains(x));
                        });
            }
            {
                ::builtin::assert_forall_by(|x|
                        {
                            ::builtin::requires(m2.contains(x));
                            ::builtin::ensures(m1.contains(x) &&
                                    ::builtin::spec_eq(m2.count(x), m1.count(x)));
                            ::builtin::assert_(s2.contains(x));
                            ::builtin::assert_(s2.to_set().contains(x));
                            ::builtin::assert_(s1.to_set().contains(x));
                            ::builtin::assert_(s1.contains(x));
                        });
            }
            ::builtin::assert_(::builtin::ext_equal(m1, m2));
        }
    }
}
pub mod journal {
    mod commit_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::crc_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmemutil_v::*;
        use crate::pmem::power_t::*;
        use crate::pmem::power_v::*;
        use crate::common::subrange_v::*;
        use super::entry_v::*;
        use super::impl_v::*;
        use super::inv_v::*;
        use super::recover_v::*;
        #[verus::internal(verus_macro)]
        impl<PM> Journal<PM> where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn lemma_write_journal_entry_initial_conditions(self,
                current_entry_index: usize, current_pos: u64,
                entry: JournalEntry) {
                ::builtin::requires([self.inv(),
                            ::builtin::is_variant((self.status.view()),
                                "WritingJournal"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.sm.journal_entries_start),
                                        current_pos), (self.powerpm.view()).read_state.len())),
                            ::builtin::spec_eq(entry,
                                (self.entries.entries.spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(current_entry_index)).view())),
                            ::builtin::spec_eq(parse_journal_entries((self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                int>(self.sm.journal_entries_start),
                                        ::builtin::spec_cast_integer::<_, int>(current_pos))),
                                Some((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                int>(current_entry_index)))),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        current_entry_index), (self.entries.view()).len())),
                            ::builtin::spec_eq(current_pos,
                                (self.sm.journal_entries_start).spec_add(space_needed_for_journal_entries_list((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                    int>(current_entry_index)))))]);
                ::builtin::ensures([::builtin::spec_eq((current_pos).spec_add(entry.space_needed()),
                                (self.sm.journal_entries_start).spec_add(space_needed_for_journal_entries_list((self.entries.view()).take((current_entry_index).spec_add(::builtin::spec_literal_nat("1")))))),
                            (::builtin::spec_literal_nat("0")).spec_le(current_pos),
                            ((current_pos).spec_add(entry.space_needed())).spec_le((self.sm.journal_entries_start).spec_add(self.journal_length)),
                            (::builtin::spec_eq((current_pos).spec_add(entry.space_needed()),
                                        (self.sm.journal_entries_start).spec_add(self.journal_length)))
                                ==
                                (::builtin::spec_eq(current_entry_index,
                                        ((self.entries.view()).len()).spec_sub(::builtin::spec_literal_nat("1"))))]);
                lemma_space_needed_for_journal_entries_list_increases((self.entries.view()),
                    ::builtin::spec_cast_integer::<_,
                            int>(current_entry_index));
                lemma_space_needed_for_journal_entries_list_at_least_num_entries((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                int>(current_entry_index)));
                lemma_space_needed_for_journal_entries_list_monotonic((self.entries.view()),
                    (current_entry_index).spec_add(::builtin::spec_literal_nat("1")),
                    ::builtin::spec_cast_integer::<_,
                            int>((self.entries.view()).len()));
                if (current_entry_index).spec_lt(((self.entries.view()).len()).spec_sub(::builtin::spec_literal_nat("1")))
                        {
                        lemma_space_needed_for_journal_entries_list_increases((self.entries.view()),
                            (current_entry_index).spec_add(::builtin::spec_literal_nat("1")));
                        lemma_space_needed_for_journal_entries_list_monotonic((self.entries.view()),
                            (current_entry_index).spec_add(::builtin::spec_literal_nat("1")),
                            (current_entry_index).spec_add(::builtin::spec_literal_nat("2")));
                        lemma_space_needed_for_journal_entries_list_monotonic((self.entries.view()),
                            (current_entry_index).spec_add(::builtin::spec_literal_nat("2")),
                            ::builtin::spec_cast_integer::<_,
                                    int>((self.entries.view()).len()));
                    }
                ::builtin::assert_(::builtin::ext_equal((self.entries.view()),
                        (self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                    int>((self.entries.view()).len()))));
                ::builtin::assert_(::builtin::spec_eq(entry,
                        (self.entries.view()).spec_index(::builtin::spec_cast_integer::<_,
                                    int>(current_entry_index))));
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn write_journal_entry<PermFactory>(&mut self,
                verus_tmp_original_durable_state: Ghost<Seq<u8>>,
                verus_tmp_original_read_state: Ghost<Seq<u8>>,
                current_entry_index: usize, current_pos: u64,
                crc_digest: &mut CrcDigest,
                verus_tmp_perm_factory: Tracked<&PermFactory>) -> u64 where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let original_durable_state;

                #[verifier::proof_block]
                {
                    original_durable_state =
                        verus_tmp_original_durable_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let original_read_state;

                #[verifier::proof_block]
                {
                    original_read_state = verus_tmp_original_read_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([old(self).inv(),
                            ::builtin::is_variant((old(self).status.view()),
                                "WritingJournal"),
                            recovers_to(original_durable_state, (old(self).vm.view()),
                                old(self).sm, old(self).constants),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(old(self).sm.journal_entries_start),
                                        current_pos), (old(self).powerpm.view()).read_state.len())),
                            ::builtin::spec_eq(parse_journal_entries((old(self).powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                int>(old(self).sm.journal_entries_start),
                                        ::builtin::spec_cast_integer::<_, int>(current_pos))),
                                Some((old(self).entries.view()).take(::builtin::spec_cast_integer::<_,
                                                int>(current_entry_index)))),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        current_entry_index), (old(self).entries.view()).len())),
                            ::builtin::spec_eq(current_pos,
                                (old(self).sm.journal_entries_start).spec_add(space_needed_for_journal_entries_list((old(self).entries.view()).take(::builtin::spec_cast_integer::<_,
                                                    int>(current_entry_index))))),
                            seqs_match_in_range(original_durable_state,
                                (old(self).powerpm.view()).durable_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            seqs_match_in_range(original_read_state,
                                (old(self).powerpm.view()).read_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            ::builtin::spec_eq(old(crc_digest).bytes_in_digest(),
                                (old(self).powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                            int>(old(self).sm.journal_entries_start),
                                    ::builtin::spec_cast_integer::<_, int>(current_pos))),
                            ::builtin::spec_eq(perm_factory.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures(|next_pos: u64|
                        [self.inv(),
                                ::builtin::spec_eq(self,
                                    (Self { powerpm: self.powerpm, ..*old(self) })),
                                ::builtin::spec_eq(self.powerpm.constants(),
                                    old(self).powerpm.constants()),
                                ::builtin::spec_eq(self.powerpm.id(),
                                    old(self).powerpm.id()),
                                ::builtin::spec_eq(next_pos,
                                    (current_pos).spec_add((self.entries.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(current_entry_index)).space_needed())),
                                seqs_match_in_range(original_durable_state,
                                    (self.powerpm.view()).durable_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                seqs_match_in_range(original_read_state,
                                    (self.powerpm.view()).read_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                ::builtin::spec_eq(parse_journal_entries((self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            ::builtin::spec_cast_integer::<_, int>(next_pos))),
                                    Some((self.entries.view()).take((current_entry_index).spec_add(::builtin::spec_literal_nat("1"))))),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(current_pos),
                                            next_pos),
                                        (self.sm.journal_entries_start).spec_add(self.journal_length))),
                                ::builtin::spec_eq(next_pos,
                                    (self.sm.journal_entries_start).spec_add(space_needed_for_journal_entries_list((self.entries.view()).take((current_entry_index).spec_add(::builtin::spec_literal_nat("1")))))),
                                (::builtin::spec_eq(next_pos,
                                            (self.sm.journal_entries_start).spec_add(self.journal_length)))
                                    ==
                                    (::builtin::spec_eq(current_entry_index,
                                            ((self.entries.view()).len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                ::builtin::spec_eq(crc_digest.bytes_in_digest(),
                                    (self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                int>(self.sm.journal_entries_start),
                                        ::builtin::spec_cast_integer::<_, int>(next_pos)))]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(axiom_bytes_len)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_can_result_from_write_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                let entry: &ConcreteJournalEntry =
                    &self.entries.entries[current_entry_index];
                let num_bytes: u64 = entry.bytes_to_write.len() as u64;

                #[verifier::proof_block]
                {
                    self.lemma_write_journal_entry_initial_conditions(current_entry_index,
                        current_pos, (entry.view()));
                }
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.powerpm.serialize_and_write::<PermFactory::Perm,
                    u64>(current_pos, &entry.start,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                crc_digest.write(&entry.start);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(crc_digest.bytes_in_digest(),
                                        (self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            (current_pos).spec_add(u64::spec_size_of()))),
                                    {
                                        lemma_concatenate_subranges((self.powerpm.view()).read_state,
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            ::builtin::spec_cast_integer::<_, int>(current_pos),
                                            (current_pos).spec_add(u64::spec_size_of()));
                                    });
                            }
                        };
                }
                let num_bytes_addr = current_pos + size_of::<u64>() as u64;
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.powerpm.serialize_and_write::<PermFactory::Perm,
                    u64>(num_bytes_addr, &num_bytes,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                crc_digest.write(&num_bytes);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(crc_digest.bytes_in_digest(),
                                        (self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            (num_bytes_addr).spec_add(u64::spec_size_of()))),
                                    {
                                        lemma_concatenate_subranges((self.powerpm.view()).read_state,
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            ::builtin::spec_cast_integer::<_, int>(num_bytes_addr),
                                            (num_bytes_addr).spec_add(u64::spec_size_of()));
                                    });
                            }
                        };
                }
                let bytes_to_write_addr =
                    num_bytes_addr + size_of::<u64>() as u64;
                let bytes_to_write_as_slice = entry.bytes_to_write.as_slice();
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.powerpm.write::<PermFactory::Perm>(bytes_to_write_addr,
                    bytes_to_write_as_slice,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                crc_digest.write_bytes(bytes_to_write_as_slice);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(crc_digest.bytes_in_digest(),
                                        (self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            (bytes_to_write_addr).spec_add(num_bytes))),
                                    {
                                        lemma_concatenate_subranges((self.powerpm.view()).read_state,
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            ::builtin::spec_cast_integer::<_, int>(bytes_to_write_addr),
                                            (bytes_to_write_addr).spec_add(num_bytes));
                                    });
                            }
                        };
                }
                let next_pos = bytes_to_write_addr + num_bytes;

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(parse_journal_entries((self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                        int>(self.sm.journal_entries_start),
                                                ::builtin::spec_cast_integer::<_, int>(next_pos))),
                                        Some((self.entries.view()).take((current_entry_index).spec_add(::builtin::spec_literal_nat("1"))))),
                                    {
                                        let old_entries_bytes =
                                            (self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                        int>(self.sm.journal_entries_start),
                                                ::builtin::spec_cast_integer::<_, int>(current_pos));
                                        let new_entries_bytes =
                                            (self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                        int>(self.sm.journal_entries_start),
                                                ::builtin::spec_cast_integer::<_, int>(next_pos));
                                        {
                                            ::builtin::assert_by(::builtin::spec_eq(old_entries_bytes,
                                                    (old(self).powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                                int>(self.sm.journal_entries_start),
                                                        ::builtin::spec_cast_integer::<_, int>(current_pos))), {});
                                        }
                                        ::builtin::assert_(::builtin::ext_equal(new_entries_bytes,
                                                (((old_entries_bytes).spec_add(entry.start.spec_to_bytes())).spec_add(num_bytes.spec_to_bytes())).spec_add((entry.bytes_to_write.view()))));
                                        {
                                            ::builtin::assert_by(::builtin::spec_eq(parse_journal_entries(new_entries_bytes),
                                                    Some((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                                        int>(current_entry_index)).push((entry.view())))),
                                                {
                                                    lemma_parse_journal_entries_append(old_entries_bytes,
                                                        (self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                                    int>(current_entry_index)), (entry.view()));
                                                });
                                        }
                                        ::builtin::assert_(::builtin::ext_equal((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                                int>(current_entry_index)).push((entry.view())),
                                                (self.entries.view()).take((current_entry_index).spec_add(::builtin::spec_literal_nat("1")))));
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {
                    lemma_apply_journal_entries_doesnt_change_size((self.view()).read_state,
                        (self.entries.view()), self.sm);
                }
                next_pos
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn write_journal_entries<PermFactory>(&mut self,
                verus_tmp_perm_factory: Tracked<&PermFactory>) -> u64 where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([old(self).inv(),
                            ::builtin::is_variant((old(self).status.view()),
                                "WritingJournal"),
                            ::builtin::spec_eq(perm_factory.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures(|journal_entries_crc: u64|
                        [self.inv(),
                                ::builtin::spec_eq(self,
                                    (Self { powerpm: self.powerpm, ..*old(self) })),
                                ::builtin::spec_eq(self.powerpm.constants(),
                                    old(self).powerpm.constants()),
                                ::builtin::spec_eq(self.powerpm.id(),
                                    old(self).powerpm.id()),
                                seqs_match_in_range((old(self).powerpm.view()).durable_state,
                                    (self.powerpm.view()).durable_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                seqs_match_in_range((old(self).powerpm.view()).read_state,
                                    (self.powerpm.view()).read_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                ::builtin::spec_eq(parse_journal_entries(extract_section((self.powerpm.view()).read_state,
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            ::builtin::spec_cast_integer::<_,
                                                    nat>(self.journal_length))), Some((self.entries.view()))),
                                ::builtin::spec_eq(journal_entries_crc,
                                    spec_crc_u64(extract_section((self.powerpm.view()).read_state,
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            ::builtin::spec_cast_integer::<_,
                                                    nat>(self.journal_length))))]);
                let mut current_entry_index: usize = 0;
                let mut current_pos = self.sm.journal_entries_start;
                let end_pos = current_pos + self.journal_length;
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (self.powerpm.view()).durable_state };
                #[verus::internal(spec)]
                let mut original_durable_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_original_durable_state = verus_tmp;
                    original_durable_state = verus_tmp_original_durable_state;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (self.powerpm.view()).read_state };
                #[verus::internal(spec)]
                let mut original_read_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_original_read_state = verus_tmp;
                    original_read_state = verus_tmp_original_read_state;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                int>(self.sm.journal_entries_start),
                                        ::builtin::spec_cast_integer::<_, int>(current_pos)),
                                    Seq::<u8>::empty()))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                int>(current_entry_index)), Seq::<JournalEntry>::empty()))
                        };
                };
                let mut crc_digest = CrcDigest::new();

                #[verifier::proof_block]
                {
                    lemma_space_needed_for_journal_entries_list_zero_iff_journal_empty((self.entries.view()));
                }
                while current_pos < end_pos {
                    ::builtin::invariant([self.inv(),
                                ::builtin::is_variant((self.status.view()),
                                    "WritingJournal"),
                                ::builtin::spec_eq(self.powerpm.constants(),
                                    old(self).powerpm.constants()),
                                ::builtin::spec_eq(self.powerpm.id(),
                                    old(self).powerpm.id()),
                                ::builtin::spec_eq(end_pos,
                                    (self.sm.journal_entries_start).spec_add(self.journal_length)),
                                recovers_to(original_durable_state, (self.vm.view()),
                                    self.sm, self.constants),
                                ::builtin::spec_eq(parse_journal_entries((self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                    int>(self.sm.journal_entries_start),
                                            ::builtin::spec_cast_integer::<_, int>(current_pos))),
                                    Some((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                    int>(current_entry_index)))),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            current_entry_index), (self.entries.view()).len())),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.sm.journal_entries_start),
                                            current_pos), end_pos)),
                                (::builtin::spec_eq(current_pos, end_pos)) ==
                                    (::builtin::spec_eq(current_entry_index,
                                            (self.entries.view()).len())),
                                ::builtin::spec_eq(current_pos,
                                    (self.sm.journal_entries_start).spec_add(space_needed_for_journal_entries_list((self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                        int>(current_entry_index))))),
                                seqs_match_in_range(original_durable_state,
                                    (self.powerpm.view()).durable_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                seqs_match_in_range(original_read_state,
                                    (self.powerpm.view()).read_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                ::builtin::spec_eq(self,
                                    (Self { powerpm: self.powerpm, ..*old(self) })),
                                ::builtin::spec_eq(crc_digest.bytes_in_digest(),
                                    (self.powerpm.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                int>(self.sm.journal_entries_start),
                                        ::builtin::spec_cast_integer::<_, int>(current_pos))),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (self.view()).powerpm_id),
                                ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                        ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                            #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                s2)))]);
                    current_pos =
                        self.write_journal_entry::<PermFactory>(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] original_durable_state),
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] original_read_state),
                            current_entry_index, current_pos, &mut crc_digest,
                            #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory));

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by((current_entry_index).spec_lt(u64::MAX),
                                        {
                                            lemma_space_needed_for_journal_entries_list_at_least_num_entries((self.entries.view()));
                                        });
                                }
                            };
                    }
                    current_entry_index = current_entry_index + 1;
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq((self.entries.view()),
                                    (self.entries.view()).take(::builtin::spec_cast_integer::<_,
                                                int>(current_entry_index))))
                        };
                };
                crc_digest.sum64()
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn write_journal_metadata<PermFactory>(&mut self,
                verus_tmp_perm_factory: Tracked<&PermFactory>) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([old(self).inv(),
                            ::builtin::is_variant((old(self).status.view()),
                                "WritingJournal"),
                            ::builtin::spec_eq(perm_factory.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.powerpm.constants(),
                                old(self).powerpm.constants()),
                            ::builtin::spec_eq(self.powerpm.id(),
                                old(self).powerpm.id()),
                            ::builtin::spec_eq(self,
                                (Self { powerpm: self.powerpm, ..*old(self) })),
                            (self.powerpm.view()).flush_predicted(),
                            seqs_match_in_range((old(self).powerpm.view()).durable_state,
                                (self.powerpm.view()).durable_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_end)),
                            seqs_match_in_range((old(self).powerpm.view()).read_state,
                                (self.powerpm.view()).read_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_end)),
                            ::builtin::spec_eq(recover_journal_length((self.powerpm.view()).read_state,
                                    self.sm), Some(self.journal_length)),
                            ::builtin::spec_eq(recover_journal_entries((self.powerpm.view()).read_state,
                                    self.sm, self.journal_length),
                                Some((self.entries.view())))]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_can_result_from_write_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                let journal_length_crc =
                    {
                        let mut digest = CrcDigest::new();
                        digest.write(&self.journal_length);
                        digest.sum64()
                    };
                let journal_entries_crc =
                    self.write_journal_entries::<PermFactory>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory));
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.powerpm.serialize_and_write::<PermFactory::Perm,
                    u64>(self.sm.journal_length_start, &self.journal_length,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.powerpm.serialize_and_write::<PermFactory::Perm,
                    u64>(self.sm.journal_length_crc_start, &journal_length_crc,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.powerpm.serialize_and_write::<PermFactory::Perm,
                    u64>(self.sm.journal_entries_crc_start,
                    &journal_entries_crc,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                self.powerpm.flush();

                #[verifier::proof_block]
                {
                    lemma_apply_journal_entries_doesnt_change_size((self.view()).read_state,
                        (self.entries.view()), self.sm);
                }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn mark_journal_committed<PermFactory,
                Perm>(&mut self,
                verus_tmp_original_durable_state: Ghost<Seq<u8>>,
                verus_tmp_original_read_state: Ghost<Seq<u8>>,
                verus_tmp_original_commit_state: Ghost<Seq<u8>>,
                verus_tmp_perm_factory: Tracked<&PermFactory>,
                verus_tmp_perm: Tracked<Perm>) where
                PermFactory: PermissionFactory<Seq<u8>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let original_durable_state;

                #[verifier::proof_block]
                {
                    original_durable_state =
                        verus_tmp_original_durable_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let original_read_state;

                #[verifier::proof_block]
                {
                    original_read_state = verus_tmp_original_read_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let original_commit_state;

                #[verifier::proof_block]
                {
                    original_commit_state =
                        verus_tmp_original_commit_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).inv(),
                            ::builtin::is_variant((old(self).status.view()),
                                "WritingJournal"),
                            (old(self).powerpm.view()).flush_predicted(),
                            recovers_to(original_durable_state, (old(self).vm.view()),
                                old(self).sm, old(self).constants),
                            seqs_match_except_in_range(original_durable_state,
                                original_read_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            seqs_match_in_range(original_durable_state,
                                (old(self).powerpm.view()).durable_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            seqs_match_in_range(original_read_state,
                                (old(self).powerpm.view()).read_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            ::builtin::spec_eq(apply_journal_entries(original_read_state,
                                    (old(self).entries.view()), old(self).sm),
                                Some(original_commit_state)),
                            ::builtin::spec_eq(recover_committed_cdb(original_read_state,
                                    old(self).sm), Some(false)),
                            recovers_to(original_read_state, (old(self).vm.view()),
                                old(self).sm, old(self).constants),
                            ::builtin::spec_eq(recover_journal_length((old(self).powerpm.view()).read_state,
                                    old(self).sm), Some(old(self).journal_length)),
                            ::builtin::spec_eq(recover_journal_entries((old(self).powerpm.view()).read_state,
                                    old(self).sm, old(self).journal_length),
                                Some((old(self).entries.view()))),
                            ::builtin::spec_eq(perm.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply({
                                            (spec_recovery_equivalent_for_app(s1,
                                                        original_durable_state)) &&
                                                (spec_recovery_equivalent_for_app(s2,
                                                        original_commit_state))
                                        },
                                        #[verus::internal(trigger)] perm.check_permission(s1, s2))),
                            recovers_to(original_commit_state, (old(self).vm.view()),
                                old(self).sm, old(self).constants),
                            ::builtin::spec_eq(perm_factory.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.powerpm.constants(),
                                old(self).powerpm.constants()),
                            ::builtin::spec_eq(self.powerpm.id(),
                                old(self).powerpm.id()),
                            ::builtin::spec_eq(self,
                                (Self {
                                        status: ::builtin::Ghost::new(JournalStatus::Committed),
                                        powerpm: self.powerpm,
                                        ..*old(self)
                                    })),
                            seqs_match_in_range(original_durable_state,
                                (self.powerpm.view()).durable_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_end)),
                            seqs_match_in_range(original_read_state,
                                (self.powerpm.view()).read_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_end)),
                            (self.powerpm.view()).flush_predicted(),
                            ::builtin::spec_eq(recover_committed_cdb((self.powerpm.view()).read_state,
                                    self.sm), Some(true)),
                            ::builtin::spec_eq(recover_journal_length((self.powerpm.view()).read_state,
                                    self.sm), Some(self.journal_length)),
                            ::builtin::spec_eq(recover_journal_entries((self.powerpm.view()).read_state,
                                    self.sm, self.journal_length), Some((self.entries.view()))),
                            ({
                                    ((if let Some(j) =
                                                        (recover_journal((self.powerpm.view()).read_state)) {
                                                    (::builtin::spec_eq(j.constants, self.constants)) &&
                                                        (seqs_match_in_range(j.state, original_commit_state,
                                                                ::builtin::spec_cast_integer::<_,
                                                                        int>(self.sm.app_area_start),
                                                                ::builtin::spec_cast_integer::<_,
                                                                        int>(self.sm.app_area_end)))
                                                } else { false }))
                                })]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                let cdb = CDB_TRUE;
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        update_bytes((self.powerpm.view()).durable_state,
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.sm.committed_cdb_start), cdb.spec_to_bytes())
                };
                #[verus::internal(spec)]
                let mut desired_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_desired_state = verus_tmp;
                    desired_state = verus_tmp_desired_state;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by({
                                        ((if let Some(j) = (recover_journal(desired_state)) {
                                                        (::builtin::spec_eq(j.constants, self.constants)) &&
                                                            (seqs_match_in_range(j.state, original_commit_state,
                                                                    ::builtin::spec_cast_integer::<_,
                                                                            int>(self.sm.app_area_start),
                                                                    ::builtin::spec_cast_integer::<_,
                                                                            int>(self.sm.app_area_end)))
                                                    } else { false }))
                                    },
                                    {
                                        let s = desired_state;
                                        ::builtin::assert_(::builtin::spec_eq(recover_committed_cdb(s,
                                                    self.sm), Some(true)));
                                        ::builtin::assert_(::builtin::spec_eq(recover_storage_state(s,
                                                    self.sm),
                                                apply_journal_entries(s, (self.entries.view()), self.sm)));
                                        lemma_apply_journal_entries_maintains_matching_app_areas(original_read_state,
                                            s, (self.vm.view()), self.sm, (self.entries.view()));
                                    });
                            }
                        };
                }
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut unchanged_perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_unchanged_perm = verus_tmp;
                    unchanged_perm = verus_tmp_unchanged_perm;
                };
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = CombinedPermission::new(unchanged_perm, perm) };
                #[verus::internal(infer_mode)]
                let mut combined_perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_combined_perm = verus_tmp;
                    combined_perm = verus_tmp_combined_perm;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_forall_by(|s|
                                        {
                                            ::builtin::requires(#[verus::internal(trigger)] can_result_from_partial_write(s,
                                                    (self.powerpm.view()).durable_state,
                                                    ::builtin::spec_cast_integer::<_,
                                                            int>(self.sm.committed_cdb_start), cdb.spec_to_bytes()));
                                            ::builtin::ensures(combined_perm.check_permission((self.powerpm.view()).durable_state,
                                                    s));
                                            {
                                                ::builtin::assert_by(::builtin::spec_eq(s,
                                                            (self.powerpm.view()).durable_state) ||
                                                        ::builtin::spec_eq(s, desired_state),
                                                    {
                                                        ::builtin::assert_(::builtin::spec_eq((::builtin::spec_cast_integer::<_,
                                                                                int>(self.sm.committed_cdb_start)).spec_euclidean_mod(const_persistence_chunk_size()),
                                                                ::builtin::spec_literal_nat("0")));
                                                        lemma_only_two_crash_states_introduced_by_aligned_chunk_write(s,
                                                            (self.powerpm.view()).durable_state,
                                                            ::builtin::spec_cast_integer::<_,
                                                                    int>(self.sm.committed_cdb_start), cdb.spec_to_bytes());
                                                    });
                                            }
                                        });
                            }
                        };
                }
                self.powerpm.serialize_and_write::<CombinedPermission<Seq<u8>,
                    PermFactory::Perm, Perm>,
                    u64>(self.sm.committed_cdb_start, &cdb,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] combined_perm));
                self.powerpm.flush();

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq((self.powerpm.view()).read_state,
                                    desired_state))
                        };
                };
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] JournalStatus::Committed);
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn install_journal_entry_during_commit<PermFactory>(&mut self,
                num_entries_installed: usize,
                verus_tmp_original_read_state: Ghost<Seq<u8>>,
                verus_tmp_original_commit_state: Ghost<Seq<u8>>,
                verus_tmp_desired_commit_state: Ghost<Seq<u8>>,
                verus_tmp_perm_factory: Tracked<&PermFactory>) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let original_read_state;

                #[verifier::proof_block]
                {
                    original_read_state = verus_tmp_original_read_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let original_commit_state;

                #[verifier::proof_block]
                {
                    original_commit_state =
                        verus_tmp_original_commit_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let desired_commit_state;

                #[verifier::proof_block]
                {
                    desired_commit_state = verus_tmp_desired_commit_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([old(self).inv(),
                            ::builtin::is_variant((old(self).status.view()),
                                "Committed"),
                            (num_entries_installed).spec_lt((old(self).entries.view()).len()),
                            ::builtin::spec_eq(recover_version_metadata(original_read_state),
                                Some((old(self).vm.view()))),
                            ::builtin::spec_eq(recover_static_metadata(original_read_state,
                                    (old(self).vm.view())), Some(old(self).sm)),
                            ::builtin::spec_eq(recover_committed_cdb(original_read_state,
                                    old(self).sm), Some(true)),
                            ::builtin::spec_eq(recover_journal_length(original_read_state,
                                    old(self).sm), Some(old(self).journal_length)),
                            ::builtin::spec_eq(recover_journal_entries(original_read_state,
                                    old(self).sm, old(self).journal_length),
                                Some((old(self).entries.view()))),
                            journal_entries_valid((old(self).entries.view()),
                                old(self).sm),
                            ::builtin::is_variant(apply_journal_entries(original_read_state,
                                    (old(self).entries.view()), old(self).sm), "Some"),
                            ::builtin::is_variant(recover_journal(original_read_state),
                                "Some"),
                            ::builtin::spec_eq(recover_version_metadata((old(self).powerpm.view()).durable_state),
                                Some((old(self).vm.view()))),
                            ::builtin::spec_eq(recover_static_metadata((old(self).powerpm.view()).durable_state,
                                    (old(self).vm.view())), Some(old(self).sm)),
                            ::builtin::spec_eq(recover_committed_cdb((old(self).powerpm.view()).durable_state,
                                    old(self).sm), Some(true)),
                            ::builtin::spec_eq(recover_journal_length((old(self).powerpm.view()).durable_state,
                                    old(self).sm), Some(old(self).journal_length)),
                            ::builtin::spec_eq(recover_journal_entries((old(self).powerpm.view()).durable_state,
                                    old(self).sm, old(self).journal_length),
                                Some((old(self).entries.view()))),
                            ::builtin::spec_eq(recover_journal((old(self).powerpm.view()).durable_state),
                                recover_journal(original_read_state)),
                            seqs_match_except_in_range(original_read_state,
                                (old(self).powerpm.view()).durable_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            seqs_match_except_in_range(original_read_state,
                                (old(self).powerpm.view()).read_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            ::builtin::spec_eq(apply_journal_entries((old(self).powerpm.view()).read_state,
                                    (old(self).entries.view()).skip(::builtin::spec_cast_integer::<_,
                                                int>(num_entries_installed)), old(self).sm),
                                Some(desired_commit_state)),
                            ::builtin::spec_eq(desired_commit_state,
                                apply_journal_entries(original_read_state,
                                        (old(self).entries.view()), old(self).sm).unwrap()),
                            seqs_match_in_range(original_commit_state,
                                desired_commit_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(old(self).sm.app_area_end)),
                            recovers_to(original_commit_state, (old(self).vm.view()),
                                old(self).sm, old(self).constants),
                            ::builtin::spec_eq(perm_factory.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self,
                                (Self { powerpm: self.powerpm, ..*old(self) })),
                            ::builtin::spec_eq(self.powerpm.constants(),
                                old(self).powerpm.constants()),
                            ::builtin::spec_eq(self.powerpm.id(),
                                old(self).powerpm.id()),
                            journal_entries_valid((self.entries.view()), self.sm),
                            ::builtin::is_variant(apply_journal_entries(original_read_state,
                                    (self.entries.view()), self.sm), "Some"),
                            ::builtin::spec_eq(recover_version_metadata((self.powerpm.view()).durable_state),
                                Some((self.vm.view()))),
                            ::builtin::spec_eq(recover_static_metadata((self.powerpm.view()).durable_state,
                                    (self.vm.view())), Some(self.sm)),
                            ::builtin::spec_eq(recover_committed_cdb((self.powerpm.view()).durable_state,
                                    self.sm), Some(true)),
                            ::builtin::spec_eq(recover_journal_length((self.powerpm.view()).durable_state,
                                    self.sm), Some(self.journal_length)),
                            ::builtin::spec_eq(recover_journal_entries((self.powerpm.view()).durable_state,
                                    self.sm, self.journal_length), Some((self.entries.view()))),
                            ::builtin::spec_eq(recover_journal((self.powerpm.view()).durable_state),
                                recover_journal(original_read_state)),
                            seqs_match_except_in_range(original_read_state,
                                (self.powerpm.view()).durable_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_end)),
                            seqs_match_except_in_range(original_read_state,
                                (self.powerpm.view()).read_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_end)),
                            ::builtin::spec_eq(apply_journal_entries((self.powerpm.view()).read_state,
                                    (self.entries.view()).skip((num_entries_installed).spec_add(::builtin::spec_literal_nat("1"))),
                                    self.sm), Some(desired_commit_state))]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_can_result_from_write_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                let entry: &ConcreteJournalEntry =
                    &self.entries.entries[num_entries_installed];
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        recover_journal_entries_bytes((self.powerpm.view()).durable_state,
                                self.sm, self.journal_length).unwrap()
                };
                #[verus::internal(spec)]
                let mut entries_bytes;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_entries_bytes = verus_tmp;
                    entries_bytes = verus_tmp_entries_bytes;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(parse_journal_entries(entries_bytes),
                                    Some((self.entries.view()))))
                        };
                };

                #[verifier::proof_block]
                {
                    lemma_addresses_in_entry_dont_affect_recovery((self.powerpm.view()).durable_state,
                        (self.vm.view()), self.sm, entries_bytes,
                        (self.entries.view()),
                        ::builtin::spec_cast_integer::<_,
                                int>(num_entries_installed));
                    {
                        ::builtin::assert_by((entry.view()).fits(self.sm),
                            {
                                lemma_journal_entries_valid_implies_one_valid((self.entries.view()),
                                    self.sm,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(num_entries_installed));
                            });
                    }
                    {
                        ::builtin::assert_forall_by(|s|
                                {
                                    ::builtin::requires(can_result_from_partial_write(s,
                                            (self.powerpm.view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(entry.start),
                                            (entry.bytes_to_write.view())));
                                    ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission((self.powerpm.view()).durable_state,
                                            s));
                                    lemma_if_addresses_unreachable_in_recovery_then_recovery_unchanged_by_write(s,
                                        (self.powerpm.view()).durable_state,
                                        ::builtin::spec_cast_integer::<_, int>(entry.start),
                                        (entry.bytes_to_write.view()), (entry.view()).addrs(),
                                        ::builtin::closure_to_fn_spec(|s| recover_journal(s)));
                                    ::builtin::assert_(::builtin::spec_eq(recover_journal(s),
                                            recover_journal((self.powerpm.view()).durable_state)));
                                });
                    }
                }
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.powerpm.write::<PermFactory::Perm>(entry.start,
                    entry.bytes_to_write.as_slice(),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));

                #[verifier::proof_block]
                {
                    {
                        ::builtin::assert_by(::builtin::spec_eq(recover_journal((self.powerpm.view()).durable_state),
                                recover_journal((old(self).powerpm.view()).durable_state)),
                            {
                                lemma_if_addresses_unreachable_in_recovery_then_recovery_unchanged_by_write((self.powerpm.view()).durable_state,
                                    (old(self).powerpm.view()).durable_state,
                                    ::builtin::spec_cast_integer::<_, int>(entry.start),
                                    (entry.bytes_to_write.view()), (entry.view()).addrs(),
                                    ::builtin::closure_to_fn_spec(|s| recover_journal(s)));
                            });
                    }
                    ::builtin::assert_(::builtin::spec_eq(Some((self.powerpm.view()).read_state),
                            apply_journal_entry((old(self).powerpm.view()).read_state,
                                (entry.view()), self.sm)));
                    ::builtin::assert_(::builtin::spec_eq(recover_journal((self.powerpm.view()).durable_state),
                            recover_journal((old(self).powerpm.view()).durable_state)));
                    ::builtin::assert_(::builtin::spec_eq(recover_journal_length((self.powerpm.view()).durable_state,
                                self.sm), Some(self.journal_length)));
                    ::builtin::assert_(::builtin::ext_equal((self.entries.view()).skip(::builtin::spec_cast_integer::<_,
                                            int>(num_entries_installed)).spec_index(::builtin::spec_literal_integer("0")),
                            (self.entries.view()).spec_index(::builtin::spec_cast_integer::<_,
                                        int>(num_entries_installed))));
                    ::builtin::assert_(::builtin::ext_equal((self.entries.view()).skip(::builtin::spec_cast_integer::<_,
                                            int>(num_entries_installed)).skip(::builtin::spec_literal_integer("1")),
                            (self.entries.view()).skip((num_entries_installed).spec_add(::builtin::spec_literal_nat("1")))));
                    lemma_apply_journal_entries_doesnt_change_size((self.view()).read_state,
                        (self.entries.view()), self.sm);
                }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn install_journal_entries_during_commit<PermFactory>(&mut self,
                verus_tmp_original_commit_state: Ghost<Seq<u8>>,
                verus_tmp_perm_factory: Tracked<&PermFactory>) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let original_commit_state;

                #[verifier::proof_block]
                {
                    original_commit_state =
                        verus_tmp_original_commit_state.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([old(self).inv(),
                            ::builtin::is_variant((old(self).status.view()),
                                "Committed"), (old(self).powerpm.view()).flush_predicted(),
                            ::builtin::spec_eq(recover_journal_length((old(self).powerpm.view()).read_state,
                                    old(self).sm), Some(old(self).journal_length)),
                            ::builtin::spec_eq(recover_journal_entries((old(self).powerpm.view()).read_state,
                                    old(self).sm, old(self).journal_length),
                                Some((old(self).entries.view()))),
                            ({
                                    ((if let Some(j) =
                                                        (recover_journal((old(self).powerpm.view()).read_state)) {
                                                    (::builtin::spec_eq(j.constants, old(self).constants)) &&
                                                        (seqs_match_in_range(j.state, original_commit_state,
                                                                ::builtin::spec_cast_integer::<_,
                                                                        int>(old(self).sm.app_area_start),
                                                                ::builtin::spec_cast_integer::<_,
                                                                        int>(old(self).sm.app_area_end)))
                                                } else { false }))
                                }),
                            recovers_to(original_commit_state, (old(self).vm.view()),
                                old(self).sm, old(self).constants),
                            ::builtin::spec_eq(perm_factory.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self,
                                (Self { powerpm: self.powerpm, ..*old(self) })),
                            ::builtin::spec_eq(self.powerpm.constants(),
                                old(self).powerpm.constants()),
                            ::builtin::spec_eq(self.powerpm.id(),
                                old(self).powerpm.id()),
                            (self.powerpm.view()).flush_predicted(),
                            seqs_match_in_range((self.powerpm.view()).read_state,
                                original_commit_state,
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_start),
                                ::builtin::spec_cast_integer::<_,
                                        int>(self.sm.app_area_end)),
                            ({
                                    ((if let Some(j) =
                                                        (recover_journal((self.powerpm.view()).read_state)) {
                                                    (::builtin::spec_eq(j.constants, self.constants)) &&
                                                        (::builtin::spec_eq(j.state,
                                                                (self.powerpm.view()).read_state))
                                                } else { false }))
                                })]);
                let mut num_entries_installed: usize = 0;
                let end: usize = self.entries.len();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        apply_journal_entries((self.powerpm.view()).read_state,
                                (self.entries.view()), self.sm).unwrap()
                };
                #[verus::internal(spec)]
                let mut desired_commit_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_desired_commit_state = verus_tmp;
                    desired_commit_state = verus_tmp_desired_commit_state;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.entries.view()).skip(::builtin::spec_literal_integer("0")),
                                    (self.entries.view())))
                        };
                };
                while num_entries_installed < end {
                    ::builtin::invariant([self.inv(),
                                ::builtin::is_variant((self.status.view()), "Committed"),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_eq(::builtin::spec_chained_le(::builtin::spec_chained_value(num_entries_installed),
                                            end), (self.entries.view()).len())),
                                ::builtin::spec_eq(recover_version_metadata((old(self).powerpm.view()).read_state),
                                    Some((self.vm.view()))),
                                ::builtin::spec_eq(recover_static_metadata((old(self).powerpm.view()).read_state,
                                        (self.vm.view())), Some(self.sm)),
                                ::builtin::spec_eq(recover_committed_cdb((old(self).powerpm.view()).read_state,
                                        self.sm), Some(true)),
                                ::builtin::spec_eq(recover_journal_length((old(self).powerpm.view()).read_state,
                                        self.sm), Some(self.journal_length)),
                                ::builtin::spec_eq(recover_journal_entries((old(self).powerpm.view()).read_state,
                                        self.sm, self.journal_length), Some((self.entries.view()))),
                                journal_entries_valid((self.entries.view()), self.sm),
                                ::builtin::is_variant(apply_journal_entries((old(self).powerpm.view()).read_state,
                                        (self.entries.view()), self.sm), "Some"),
                                ::builtin::is_variant(recover_journal((old(self).powerpm.view()).read_state),
                                    "Some"),
                                ::builtin::spec_eq(recover_version_metadata((self.powerpm.view()).durable_state),
                                    Some((self.vm.view()))),
                                ::builtin::spec_eq(recover_static_metadata((self.powerpm.view()).durable_state,
                                        (self.vm.view())), Some(self.sm)),
                                ::builtin::spec_eq(recover_committed_cdb((self.powerpm.view()).durable_state,
                                        self.sm), Some(true)),
                                ::builtin::spec_eq(recover_journal_length((self.powerpm.view()).durable_state,
                                        self.sm), Some(self.journal_length)),
                                ::builtin::spec_eq(recover_journal_entries((self.powerpm.view()).durable_state,
                                        self.sm, self.journal_length), Some((self.entries.view()))),
                                ::builtin::spec_eq(recover_journal((self.powerpm.view()).durable_state),
                                    recover_journal((old(self).powerpm.view()).read_state)),
                                seqs_match_except_in_range((old(self).powerpm.view()).read_state,
                                    (self.powerpm.view()).durable_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                seqs_match_except_in_range((old(self).powerpm.view()).read_state,
                                    (self.powerpm.view()).read_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                ::builtin::spec_eq(apply_journal_entries((self.powerpm.view()).read_state,
                                        (self.entries.view()).skip(::builtin::spec_cast_integer::<_,
                                                    int>(num_entries_installed)), self.sm),
                                    Some(desired_commit_state)),
                                ::builtin::spec_eq(desired_commit_state,
                                    apply_journal_entries((old(self).powerpm.view()).read_state,
                                            (self.entries.view()), self.sm).unwrap()),
                                seqs_match_in_range(original_commit_state,
                                    desired_commit_state,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.sm.app_area_end)),
                                recovers_to(original_commit_state, (old(self).vm.view()),
                                    old(self).sm, old(self).constants),
                                ::builtin::spec_eq(self,
                                    (Self { powerpm: self.powerpm, ..*old(self) })),
                                ::builtin::spec_eq(self.powerpm.constants(),
                                    old(self).powerpm.constants()),
                                ::builtin::spec_eq(self.powerpm.id(),
                                    old(self).powerpm.id()),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (self.view()).powerpm_id),
                                ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                        ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                            #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                s2)))]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (self.powerpm.view()).durable_state };
                    #[verus::internal(spec)]
                    let mut durable_state_at_start_of_loop;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_state_at_start_of_loop = verus_tmp;
                        durable_state_at_start_of_loop =
                            verus_tmp_durable_state_at_start_of_loop;
                    };
                    self.install_journal_entry_during_commit::<PermFactory>(num_entries_installed,
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (old(self).powerpm.view()).read_state),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] original_commit_state),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] desired_commit_state),
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory));

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.entries.view()).skip(::builtin::spec_cast_integer::<_,
                                                    int>(num_entries_installed)),
                                        (::vstd::vstd::seq::Seq::empty().push((self.entries.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                int>(num_entries_installed)))).spec_add((self.entries.view()).skip((num_entries_installed).spec_add(::builtin::spec_literal_nat("1"))))))
                            };
                    };
                    num_entries_installed = num_entries_installed + 1;
                }
                self.powerpm.flush();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn lemma_commit_initial_conditions(&self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([::builtin::is_variant(apply_journal_entries((self.powerpm.view()).read_state,
                                    (self.entries.view()), self.sm), "Some"),
                            ::builtin::spec_eq(recover_committed_cdb((self.powerpm.view()).read_state,
                                    self.sm), Some(false)),
                            recovers_to((self.powerpm.view()).read_state,
                                (self.vm.view()), self.sm, self.constants),
                            recovers_to((self.view()).commit_state, (self.vm.view()),
                                self.sm, self.constants)]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                lemma_apply_journal_entries_some_iff_journal_entries_valid((self.powerpm.view()).read_state,
                    (self.entries.view()), self.sm);
                {
                    ::builtin::assert_by({
                            (::builtin::spec_eq(recover_committed_cdb((self.powerpm.view()).read_state,
                                            self.sm), Some(false))) &&
                                (recovers_to((self.powerpm.view()).read_state,
                                        (self.vm.view()), self.sm, self.constants))
                        },
                        {
                            ::builtin::assert_(::builtin::spec_eq(recover_version_metadata((self.powerpm.view()).durable_state),
                                    recover_version_metadata((self.powerpm.view()).read_state)));
                            ::builtin::assert_(::builtin::spec_eq(recover_static_metadata((self.powerpm.view()).durable_state,
                                        (self.vm.view())),
                                    recover_static_metadata((self.powerpm.view()).read_state,
                                        (self.vm.view()))));
                            ::builtin::assert_(::builtin::spec_eq(recover_committed_cdb((self.powerpm.view()).durable_state,
                                        self.sm),
                                    recover_committed_cdb((self.powerpm.view()).read_state,
                                        self.sm)));
                        });
                }
                {
                    ::builtin::assert_by(recovers_to((self.view()).commit_state,
                            (self.vm.view()), self.sm, self.constants),
                        {
                            lemma_apply_journal_entries_only_affects_app_area((self.powerpm.view()).read_state,
                                (self.vm.view()), self.sm, (self.entries.view()));
                            ::builtin::assert_(::builtin::spec_eq(recover_version_metadata((self.powerpm.view()).read_state),
                                    recover_version_metadata((self.view()).commit_state)));
                            ::builtin::assert_(::builtin::spec_eq(recover_static_metadata((self.powerpm.view()).read_state,
                                        (self.vm.view())),
                                    recover_static_metadata((self.view()).commit_state,
                                        (self.vm.view()))));
                            ::builtin::assert_(::builtin::spec_eq(recover_committed_cdb((self.powerpm.view()).read_state,
                                        self.sm),
                                    recover_committed_cdb((self.view()).commit_state,
                                        self.sm)));
                        });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn commit<PermFactory,
                Perm>(&mut self,
                verus_tmp_perm_factory: Tracked<&PermFactory>,
                verus_tmp_perm: Tracked<Perm>) where
                PermFactory: PermissionFactory<Seq<u8>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).valid(),
                            ::builtin::spec_eq(perm.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply({
                                            (Self::recovery_equivalent_for_app(s1,
                                                        (old(self).view()).durable_state)) &&
                                                (Self::recovery_equivalent_for_app(s2,
                                                        (old(self).view()).commit_state))
                                        },
                                        #[verus::internal(trigger)] perm.check_permission(s1, s2))),
                            ::builtin::spec_eq(perm_factory.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([self.valid(), (self.view()).valid(),
                            self.recover_idempotent(),
                            (self.view()).committed_from((old(self).view()))]);

                #[verifier::proof_block]
                { self.lemma_commit_initial_conditions(); }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] JournalStatus::WritingJournal);
                self.write_journal_metadata::<PermFactory>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory));
                self.mark_journal_committed::<PermFactory,
                    Perm>(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (old(self).powerpm.view()).durable_state),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (old(self).powerpm.view()).read_state),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (old(self).view()).commit_state),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                self.install_journal_entries_during_commit::<PermFactory>(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (old(self).view()).commit_state),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory));

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_forall_by(|s1: Seq<u8>, s2: Seq<u8>|
                                        {
                                            ::builtin::requires(spec_recovery_equivalent_for_app(s1,
                                                    s2));
                                            ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                    s2));
                                            Self::lemma_recover_doesnt_change_size(s1);
                                        });
                            }
                        };
                }
                Self::clear_log::<PermFactory>(&mut self.powerpm,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory),
                    self.vm, &self.sm);
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] JournalStatus::Quiescent);
                self.journal_length = 0;
                self.journaled_addrs =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] Set::<int>::empty());
                self.entries.clear();
            }
        }
    }
    mod entry_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::subrange_v::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmemutil_v::*;
        use super::recover_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct JournalEntry {
            pub start: int,
            pub bytes_to_write: Seq<u8>,
        }
        #[verus::internal(verus_macro)]
        impl JournalEntry {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn end(self) -> int {
                (self.start).spec_add(self.bytes_to_write.len())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn addrs(self) -> Set<int> {
                Set::<int>::new(::builtin::closure_to_fn_spec(|i|
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.start),
                                        i), self.end()))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn fits(self, sm: JournalStaticMetadata) -> bool {
                (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    sm.app_area_start), self.start))) &&
                    ((self.end()).spec_le(sm.app_area_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn space_needed(self) -> nat {
                ((u64::spec_size_of()).spec_add(u64::spec_size_of())).spec_add(self.bytes_to_write.len())
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn apply_journal_entry(bytes: Seq<u8>, entry: JournalEntry,
            sm: JournalStaticMetadata) -> Option<Seq<u8>> {
            if entry.fits(sm) {
                    Some(update_bytes(bytes, entry.start, entry.bytes_to_write))
                } else { None }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn apply_journal_entries(bytes: Seq<u8>,
            entries: Seq<JournalEntry>, sm: JournalStaticMetadata)
            -> Option<Seq<u8>> {
            ::builtin::decreases((entries.len()));
            if ::builtin::spec_eq(entries.len(),
                        ::builtin::spec_literal_nat("0")) {
                    Some(bytes)
                } else {
                   match apply_journal_entry(bytes,
                           entries.spec_index(::builtin::spec_literal_integer("0")),
                           sm) {
                       None => None,
                       Some(updated_bytes) =>
                           apply_journal_entries(updated_bytes,
                               entries.skip(::builtin::spec_literal_integer("1")), sm),
                   }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn journal_entries_valid(entries: Seq<JournalEntry>,
            sm: JournalStaticMetadata) -> bool {
            ::builtin::decreases((entries.len()));
            if ::builtin::spec_eq(entries.len(),
                        ::builtin::spec_literal_nat("0")) {
                    true
                } else {
                   entries.spec_index(::builtin::spec_literal_integer("0")).fits(sm)
                       &&
                       journal_entries_valid(entries.skip(::builtin::spec_literal_integer("1")),
                           sm)
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_journal_entries_valid_implies_one_valid(entries:
                Seq<JournalEntry>, sm: JournalStaticMetadata,
            which_entry: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    which_entry), entries.len())),
                        journal_entries_valid(entries, sm)]);
            ::builtin::ensures([entries.spec_index(which_entry).fits(sm)]);
            ::builtin::decreases((entries.len(),));
            if (which_entry).spec_gt(::builtin::spec_literal_nat("0")) {
                    lemma_journal_entries_valid_implies_one_valid(entries.skip(::builtin::spec_literal_integer("1")),
                        sm,
                        (which_entry).spec_sub(::builtin::spec_literal_nat("1")));
                    ::builtin::assert_(::builtin::ext_equal(entries.spec_index(which_entry),
                            entries.skip(::builtin::spec_literal_integer("1")).spec_index((which_entry).spec_sub(::builtin::spec_literal_nat("1")))));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn space_needed_for_journal_entries_list(entries:
                Seq<JournalEntry>) -> int {
            ::builtin::decreases((entries.len()));
            if ::builtin::spec_eq(entries.len(),
                        ::builtin::spec_literal_nat("0")) {
                    ::builtin::spec_literal_integer("0")
                } else {
                   (entries.last().space_needed()).spec_add(space_needed_for_journal_entries_list(entries.drop_last()))
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_space_needed_for_journal_entries_list_zero_iff_journal_empty(entries:
                Seq<JournalEntry>) {
            ::builtin::ensures([if ::builtin::spec_eq(entries.len(),
                                    ::builtin::spec_literal_nat("0")) {
                                ::builtin::spec_eq(space_needed_for_journal_entries_list(entries),
                                    ::builtin::spec_literal_nat("0"))
                            } else {
                               (space_needed_for_journal_entries_list(entries)).spec_gt(::builtin::spec_literal_nat("0"))
                           }]);
            ::builtin::decreases((entries.len()));
            if (entries.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    lemma_space_needed_for_journal_entries_list_zero_iff_journal_empty(entries.drop_last());
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn journaled_addrs_complete(entries: Seq<JournalEntry>,
            journaled_addrs: Set<int>) -> bool {
            ::builtin::forall(|entry, addr|
                    ::builtin::with_triggers(((entries.contains(entry),
                                journaled_addrs.contains(addr)),),
                        ::builtin::imply(entries.contains(entry) &&
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(entry.start),
                                            addr), entry.end())), journaled_addrs.contains(addr))))
        }
        #[verus::internal(verus_macro)]
        pub struct ConcreteJournalEntry {
            pub start: u64,
            pub bytes_to_write: Vec<u8>,
        }
        #[verus::internal(verus_macro)]
        impl View for ConcreteJournalEntry {
            type V = JournalEntry;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn view(&self) -> JournalEntry {
                JournalEntry {
                    start: ::builtin::spec_cast_integer::<_, int>(self.start),
                    bytes_to_write: (self.bytes_to_write.view()),
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl DeepView for ConcreteJournalEntry {
            type V = JournalEntry;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn deep_view(&self) -> JournalEntry { (self.view()) }
        }
        #[verus::internal(verus_macro)]
        impl ConcreteJournalEntry {
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new(start: u64, bytes_to_write: Vec<u8>) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq((result.view()),
                                    (JournalEntry {
                                            start: ::builtin::spec_cast_integer::<_, int>(start),
                                            bytes_to_write: (bytes_to_write.view()),
                                        }))]);
                Self { start, bytes_to_write }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct ConcreteJournalEntries {
            pub entries: Vec<ConcreteJournalEntry>,
        }
        #[verus::internal(verus_macro)]
        impl View for ConcreteJournalEntries {
            type V = Seq<JournalEntry>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn view(&self) -> Seq<JournalEntry> { self.entries.deep_view() }
        }
        #[verus::internal(verus_macro)]
        impl ConcreteJournalEntries {
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new() -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq((result.view()),
                                    Seq::<JournalEntry>::empty())]);
                let result =
                    Self { entries: Vec::<ConcreteJournalEntry>::new() };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((result.view()),
                                    Seq::<JournalEntry>::empty()))
                        };
                };
                result
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn push(&mut self, e: ConcreteJournalEntry) {
                ::builtin::ensures([::builtin::spec_eq((self.view()),
                                (old(self).view()).push((e.view())))]);
                self.entries.push(e);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()),
                                    (old(self).view()).push((e.view()))))
                        };
                };
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn len(&self) -> usize {
                ::builtin::ensures(|result: usize|
                        [::builtin::spec_eq(result, (self.view()).len())]);
                self.entries.len()
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn clear(&mut self) {
                ::builtin::ensures([::builtin::spec_eq((self.view()),
                                Seq::<JournalEntry>::empty())]);
                self.entries.clear();

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()),
                                    Seq::<JournalEntry>::empty()))
                        };
                };
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_apply_journal_entries_only_affects_app_area(state:
                Seq<u8>, vm: JournalVersionMetadata,
            sm: JournalStaticMetadata, entries: Seq<JournalEntry>) {
            ::builtin::requires([validate_metadata(vm, sm, state.len()),
                        ::builtin::is_variant(apply_journal_entries(state, entries,
                                sm), "Some")]);
            ::builtin::ensures([({
                                let state2 =
                                    apply_journal_entries(state, entries, sm).unwrap();
                                seqs_match_except_in_range(state, state2,
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_end))
                            })]);
            ::builtin::decreases((entries.len()));
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            if (::builtin::spec_literal_nat("0")).spec_lt(entries.len()) {
                    let state_next =
                        apply_journal_entry(state,
                                entries.spec_index(::builtin::spec_literal_integer("0")),
                                sm).unwrap();
                    ::builtin::assert_(seqs_match_except_in_range(state,
                            state_next,
                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_end)));
                    lemma_apply_journal_entries_only_affects_app_area(state_next,
                        vm, sm, entries.skip(::builtin::spec_literal_integer("1")));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_apply_journal_entries_maintains_matching_app_areas(state1:
                Seq<u8>, state2: Seq<u8>, vm: JournalVersionMetadata,
            sm: JournalStaticMetadata, entries: Seq<JournalEntry>) {
            ::builtin::requires([validate_metadata(vm, sm, state1.len()),
                        ::builtin::is_variant(apply_journal_entries(state1, entries,
                                sm), "Some"),
                        seqs_match_in_range(state1, state2,
                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_end))]);
            ::builtin::ensures([({
                                let state1_final =
                                    apply_journal_entries(state1, entries, sm);
                                let state2_final =
                                    apply_journal_entries(state2, entries, sm);
                                ((if let Some(state1_final) = (state1_final) {
                                                ((if let Some(state2_final) = (state2_final) {
                                                                ((seqs_match_in_range(state1_final, state2_final,
                                                                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                                                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_end))) &&
                                                                            (seqs_match_except_in_range(state1, state1_final,
                                                                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                                                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_end))))
                                                                    &&
                                                                    (seqs_match_except_in_range(state2, state2_final,
                                                                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                                                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_end)))
                                                            } else { false }))
                                            } else { false }))
                            })]);
            ::builtin::decreases((entries.len()));
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            if (::builtin::spec_literal_nat("0")).spec_lt(entries.len()) {
                    let entry =
                        entries.spec_index(::builtin::spec_literal_integer("0"));
                    let state1_next =
                        apply_journal_entry(state1, entry, sm).unwrap();
                    let state2_next =
                        apply_journal_entry(state2, entry, sm).unwrap();
                    {
                        ::builtin::assert_by(seqs_match_in_range(state1_next,
                                state2_next,
                                ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                ::builtin::spec_cast_integer::<_, int>(sm.app_area_end)),
                            {
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                                lemma_concatenate_three_subranges(state1_next,
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                    entry.start, entry.end(),
                                    ::builtin::spec_cast_integer::<_, int>(state1.len()));
                                lemma_concatenate_three_subranges(state2_next,
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                    entry.start, entry.end(),
                                    ::builtin::spec_cast_integer::<_, int>(state2.len()));
                            });
                    }
                    lemma_apply_journal_entries_maintains_matching_app_areas(state1_next,
                        state2_next, vm, sm,
                        entries.skip(::builtin::spec_literal_integer("1")));
                }
            lemma_apply_journal_entries_only_affects_app_area(state1, vm, sm,
                entries);
            lemma_apply_journal_entries_only_affects_app_area(state2, vm, sm,
                entries);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_addresses_in_entry_dont_affect_apply_journal_entries(state1:
                Seq<u8>, state2: Seq<u8>, vm: JournalVersionMetadata,
            sm: JournalStaticMetadata, entries: Seq<JournalEntry>,
            which_entry: int) {
            ::builtin::requires([validate_metadata(vm, sm, state1.len()),
                        ::builtin::spec_eq(state1.len(), state2.len()),
                        journal_entries_valid(entries, sm),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    which_entry), entries.len())),
                        ::builtin::forall(|other_addr: int|
                                ::builtin::with_triggers(((state2.spec_index(other_addr),),),
                                    ::builtin::imply({
                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                other_addr), state1.len()))) &&
                                                (!entries.spec_index(which_entry).addrs().contains(other_addr))
                                        },
                                        ::builtin::spec_eq(state1.spec_index(other_addr),
                                            state2.spec_index(other_addr)))))]);
            ::builtin::ensures([::builtin::spec_eq(apply_journal_entries(state2,
                                entries, sm), apply_journal_entries(state1, entries, sm))]);
            ::builtin::decreases((entries.len()));
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(update_bytes)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            let state1_next =
                apply_journal_entry(state1,
                        entries.spec_index(::builtin::spec_literal_integer("0")),
                        sm).unwrap();
            let state2_next =
                apply_journal_entry(state2,
                        entries.spec_index(::builtin::spec_literal_integer("0")),
                        sm).unwrap();
            if ::builtin::spec_eq(which_entry,
                        ::builtin::spec_literal_nat("0")) {
                    ::builtin::assert_(::builtin::ext_equal(state1_next,
                            state2_next));
                } else {
                   lemma_addresses_in_entry_dont_affect_apply_journal_entries(state1_next,
                       state2_next, vm, sm,
                       entries.skip(::builtin::spec_literal_integer("1")),
                       (which_entry).spec_sub(::builtin::spec_literal_nat("1")));
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_apply_journal_entry_doesnt_change_size(state:
                Seq<u8>, entry: JournalEntry, sm: JournalStaticMetadata) {
            ::builtin::requires([::builtin::is_variant(apply_journal_entry(state,
                                entry, sm), "Some")]);
            ::builtin::ensures([::builtin::spec_eq(state.len(),
                            apply_journal_entry(state, entry, sm).unwrap().len())]);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(update_bytes)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_apply_journal_entries_doesnt_change_size(state:
                Seq<u8>, entries: Seq<JournalEntry>,
            sm: JournalStaticMetadata) {
            ::builtin::requires([::builtin::is_variant(apply_journal_entries(state,
                                    entries, sm), "Some") ||
                            journal_entries_valid(entries, sm)]);
            ::builtin::ensures([::builtin::spec_eq(state.len(),
                            apply_journal_entries(state, entries, sm).unwrap().len())]);
            ::builtin::decreases((entries.len()));
            lemma_apply_journal_entries_some_iff_journal_entries_valid(state,
                entries, sm);
            if (entries.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    let next_state =
                        apply_journal_entry(state,
                                entries.spec_index(::builtin::spec_literal_integer("0")),
                                sm).unwrap();
                    lemma_apply_journal_entry_doesnt_change_size(state,
                        entries.spec_index(::builtin::spec_literal_integer("0")),
                        sm);
                    lemma_apply_journal_entries_doesnt_change_size(next_state,
                        entries.skip(::builtin::spec_literal_integer("1")), sm);
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_addresses_in_entry_dont_affect_recovery(state:
                Seq<u8>, vm: JournalVersionMetadata,
            sm: JournalStaticMetadata, entries_bytes: Seq<u8>,
            entries: Seq<JournalEntry>, which_entry: int) {
            ::builtin::requires([::builtin::spec_eq(recover_version_metadata(state),
                            Some(vm)),
                        ::builtin::spec_eq(recover_static_metadata(state, vm),
                            Some(sm)),
                        ::builtin::spec_eq(recover_committed_cdb(state, sm),
                            Some(true)),
                        ::builtin::spec_eq(recover_journal_length(state, sm),
                            Some(::builtin::spec_cast_integer::<_,
                                        u64>(entries_bytes.len()))),
                        ::builtin::spec_eq(recover_journal_entries_bytes(state, sm,
                                ::builtin::spec_cast_integer::<_,
                                        u64>(entries_bytes.len())), Some(entries_bytes)),
                        ::builtin::spec_eq(parse_journal_entries(entries_bytes),
                            Some(entries)), journal_entries_valid(entries, sm),
                        ::builtin::is_variant(recover_journal(state), "Some"),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    which_entry), entries.len()))]);
            ::builtin::ensures([addresses_not_accessed_by_recovery(state,
                            entries.spec_index(which_entry).addrs(),
                            ::builtin::closure_to_fn_spec(|s| recover_journal(s)))]);
            let addrs = entries.spec_index(which_entry).addrs();
            {
                ::builtin::assert_forall_by(|s2: Seq<u8>|
                        {
                            ::builtin::requires({
                                    (::builtin::spec_eq(s2.len(), state.len())) &&
                                        (::builtin::forall(|i: int|
                                                    ::builtin::with_triggers(((s2.spec_index(i),),),
                                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                            i), state.len())) && !addrs.contains(i),
                                                            ::builtin::spec_eq(state.spec_index(i),
                                                                s2.spec_index(i))))))
                                });
                            ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] recover_journal(s2),
                                    recover_journal(state)));
                            lemma_addresses_in_entry_dont_affect_apply_journal_entries(state,
                                s2, vm, sm, entries, which_entry);
                            lemma_apply_journal_entries_success_implies_bounded_addrs_for_entry(sm,
                                state, entries, which_entry);
                            ::builtin::assert_(::builtin::forall(|i|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), sm.app_area_start)), !addrs.contains(i))));
                            ::builtin::assert_(::builtin::ext_equal(state.subrange(::builtin::spec_literal_integer("0"),
                                        ::builtin::spec_cast_integer::<_, int>(sm.app_area_start)),
                                    s2.subrange(::builtin::spec_literal_integer("0"),
                                        ::builtin::spec_cast_integer::<_,
                                                int>(sm.app_area_start))));
                            ::builtin::assert_(seqs_match_in_range(state, s2,
                                    ::builtin::spec_literal_integer("0"),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start)));
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_apply_journal_entries_success_implies_bounded_addrs_for_entry(sm:
                JournalStaticMetadata, state: Seq<u8>,
            entries: Seq<JournalEntry>, which_entry: int) {
            ::builtin::requires([::builtin::is_variant(apply_journal_entries(state,
                                entries, sm), "Some"),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    which_entry), entries.len()))]);
            ::builtin::ensures([entries.spec_index(which_entry).fits(sm)]);
            ::builtin::decreases((entries.len()));
            if (::builtin::spec_literal_nat("0")).spec_lt(which_entry) {
                    let next_state =
                        apply_journal_entry(state,
                                entries.spec_index(::builtin::spec_literal_integer("0")),
                                sm).unwrap();
                    lemma_apply_journal_entries_success_implies_bounded_addrs_for_entry(sm,
                        next_state,
                        entries.skip(::builtin::spec_literal_integer("1")),
                        (which_entry).spec_sub(::builtin::spec_literal_nat("1")));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_parse_journal_entry_relation_to_next(entries_bytes:
                Seq<u8>, start: int) {
            ::builtin::requires([::builtin::is_variant(parse_journal_entries(entries_bytes.skip(start)),
                            "Some"),
                        ::builtin::is_variant(parse_journal_entry(entries_bytes.skip(start)),
                            "Some"),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    start), entries_bytes.len()))]);
            ::builtin::ensures([({
                                let (entry, num_bytes) =
                                    parse_journal_entry(entries_bytes.skip(start)).unwrap();
                                (((((((parse_journal_entries(entries_bytes.skip(start)).unwrap().len()).spec_gt(::builtin::spec_literal_nat("0")))
                                                                            && ((::builtin::spec_literal_nat("0")).spec_le(num_bytes)))
                                                                    &&
                                                                    (((start).spec_add(num_bytes)).spec_le(entries_bytes.len())))
                                                            &&
                                                            (::builtin::is_variant(parse_journal_entries(entries_bytes.skip((start).spec_add(num_bytes))),
                                                                    "Some"))) &&
                                                    (::builtin::spec_eq(parse_journal_entries(entries_bytes.skip(start)).unwrap().spec_index(::builtin::spec_literal_integer("0")),
                                                            entry))) &&
                                            (::builtin::spec_eq(parse_journal_entries(entries_bytes.skip((start).spec_add(num_bytes))).unwrap(),
                                                    parse_journal_entries(entries_bytes.skip(start)).unwrap().skip(::builtin::spec_literal_integer("1")))))
                                    &&
                                    ((::builtin::spec_eq((start).spec_add(num_bytes),
                                                    entries_bytes.len())) ==
                                            (::builtin::spec_eq(parse_journal_entries(entries_bytes.skip(start)).unwrap().len(),
                                                    ::builtin::spec_literal_nat("1"))))
                            })]);
            let (entry, num_bytes) =
                parse_journal_entry(entries_bytes.skip(start)).unwrap();
            ::builtin::assert_(::builtin::ext_equal(entries_bytes.skip((start).spec_add(num_bytes)),
                    entries_bytes.skip(start).skip(num_bytes)));
            ::builtin::assert_(::builtin::ext_equal(parse_journal_entries(entries_bytes.skip((start).spec_add(num_bytes))).unwrap(),
                    parse_journal_entries(entries_bytes.skip(start)).unwrap().skip(::builtin::spec_literal_integer("1"))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_parse_journal_entry_implications(entries_bytes:
                Seq<u8>, entries: Seq<JournalEntry>, current_pos: int,
            num_entries_read: int) {
            ::builtin::requires([::builtin::spec_eq(parse_journal_entries(entries_bytes),
                            Some(entries)),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    num_entries_read), entries.len())),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    current_pos), entries_bytes.len())),
                        ::builtin::spec_eq(parse_journal_entries(entries_bytes.skip(current_pos)),
                            Some(entries.skip(num_entries_read))),
                        ::builtin::is_variant(parse_journal_entry(entries_bytes.skip(current_pos)),
                            "Some")]);
            ::builtin::ensures([({
                                let (entry, num_bytes) =
                                    parse_journal_entry(entries_bytes.skip(current_pos)).unwrap();
                                (((::builtin::spec_eq((num_entries_read).spec_add(::builtin::spec_literal_nat("1")),
                                                            entries.len())) ==
                                                    (::builtin::spec_eq((current_pos).spec_add(num_bytes),
                                                            entries_bytes.len()))) &&
                                            (::builtin::spec_eq(entries.spec_index(num_entries_read),
                                                    entry))) &&
                                    (::builtin::spec_eq(parse_journal_entries(entries_bytes.skip((current_pos).spec_add(num_bytes))),
                                            Some(entries.skip((num_entries_read).spec_add(::builtin::spec_literal_nat("1"))))))
                            })]);
            lemma_parse_journal_entry_relation_to_next(entries_bytes,
                current_pos);
            ::builtin::assert_(::builtin::ext_equal(entries.skip((num_entries_read).spec_add(::builtin::spec_literal_nat("1"))),
                    entries.skip(num_entries_read).skip(::builtin::spec_literal_integer("1"))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_parse_journal_entries_append(entries_bytes:
                Seq<u8>, entries: Seq<JournalEntry>,
            new_entry: JournalEntry) {
            ::builtin::requires([::builtin::spec_eq(parse_journal_entries(entries_bytes),
                            Some(entries)),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    new_entry.start), u64::MAX)),
                        (new_entry.bytes_to_write.len()).spec_le(u64::MAX)]);
            ::builtin::ensures([({
                                let new_entries_bytes =
                                    (((entries_bytes).spec_add((::builtin::spec_cast_integer::<_,
                                                                        u64>(new_entry.start)).spec_to_bytes())).spec_add((::builtin::spec_cast_integer::<_,
                                                                u64>(new_entry.bytes_to_write.len())).spec_to_bytes())).spec_add(new_entry.bytes_to_write);
                                ::builtin::spec_eq(parse_journal_entries(new_entries_bytes),
                                    Some(entries.push(new_entry)))
                            })]);
            ::builtin::decreases((entries.len(),));
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            let new_entries_bytes =
                (((entries_bytes).spec_add((::builtin::spec_cast_integer::<_,
                                                    u64>(new_entry.start)).spec_to_bytes())).spec_add((::builtin::spec_cast_integer::<_,
                                            u64>(new_entry.bytes_to_write.len())).spec_to_bytes())).spec_add(new_entry.bytes_to_write);
            if ::builtin::spec_eq(entries_bytes.len(),
                        ::builtin::spec_literal_nat("0")) {
                    let addr_bytes =
                        extract_section(new_entries_bytes,
                            ::builtin::spec_literal_integer("0"), u64::spec_size_of());
                    ::builtin::assert_(::builtin::ext_equal(addr_bytes,
                            (::builtin::spec_cast_integer::<_,
                                            u64>(new_entry.start)).spec_to_bytes()));
                    let length_bytes =
                        extract_section(new_entries_bytes,
                            ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()),
                            u64::spec_size_of());
                    ::builtin::assert_(::builtin::ext_equal(length_bytes,
                            (::builtin::spec_cast_integer::<_,
                                            u64>(new_entry.bytes_to_write.len())).spec_to_bytes()));
                    let data_offset =
                        (u64::spec_size_of()).spec_add(u64::spec_size_of());
                    ::builtin::assert_(::builtin::ext_equal(extract_section(new_entries_bytes,
                                ::builtin::spec_cast_integer::<_, int>(data_offset),
                                new_entry.bytes_to_write.len()), new_entry.bytes_to_write));
                    ::builtin::assert_(::builtin::spec_eq(parse_journal_entry(new_entries_bytes),
                            Some((new_entry,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(new_entries_bytes.len())))));
                    ::builtin::assert_(::builtin::ext_equal(entries,
                            Seq::<JournalEntry>::empty()));
                    ::builtin::assert_(::builtin::spec_eq(parse_journal_entries(new_entries_bytes.skip(::builtin::spec_cast_integer::<_,
                                            int>(new_entries_bytes.len()))),
                            Some(Seq::<JournalEntry>::empty())));
                    ::builtin::assert_(::builtin::ext_equal(Seq::<JournalEntry>::empty().push(new_entry),
                            (::vstd::vstd::seq::Seq::empty().push(new_entry)).spec_add(Seq::<JournalEntry>::empty())));
                } else {
                   let (entry, num_bytes) =
                       parse_journal_entry(entries_bytes).unwrap();
                   let remaining_entries =
                       parse_journal_entries(entries_bytes.skip(num_bytes)).unwrap();
                   let (alt_entry, alt_num_bytes) =
                       parse_journal_entry(new_entries_bytes).unwrap();
                   let addr_bytes =
                       extract_section(new_entries_bytes,
                           ::builtin::spec_literal_integer("0"), u64::spec_size_of());
                   ::builtin::assert_(::builtin::ext_equal(addr_bytes,
                           extract_section(entries_bytes,
                               ::builtin::spec_literal_integer("0"),
                               u64::spec_size_of())));
                   let length_bytes =
                       extract_section(new_entries_bytes,
                           ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()),
                           u64::spec_size_of());
                   ::builtin::assert_(::builtin::ext_equal(length_bytes,
                           extract_section(entries_bytes,
                               ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()),
                               u64::spec_size_of())));
                   let length = u64::spec_from_bytes(length_bytes);
                   let data_offset =
                       (u64::spec_size_of()).spec_add(u64::spec_size_of());
                   ::builtin::assert_(::builtin::ext_equal(extract_section(new_entries_bytes,
                               ::builtin::spec_cast_integer::<_, int>(data_offset),
                               ::builtin::spec_cast_integer::<_, nat>(length)),
                           extract_section(entries_bytes,
                               ::builtin::spec_cast_integer::<_, int>(data_offset),
                               ::builtin::spec_cast_integer::<_, nat>(length))));
                   ::builtin::assert_(::builtin::spec_eq(alt_entry, entry));
                   ::builtin::assert_(::builtin::spec_eq(alt_num_bytes,
                           num_bytes));
                   lemma_parse_journal_entries_append(entries_bytes.skip(num_bytes),
                       remaining_entries, new_entry);
                   ::builtin::assert_(::builtin::ext_equal((((entries_bytes.skip(num_bytes)).spec_add((::builtin::spec_cast_integer::<_,
                                                               u64>(new_entry.start)).spec_to_bytes())).spec_add((::builtin::spec_cast_integer::<_,
                                                       u64>(new_entry.bytes_to_write.len())).spec_to_bytes())).spec_add(new_entry.bytes_to_write),
                           new_entries_bytes.skip(num_bytes)));
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_apply_journal_entries_some_iff_journal_entries_valid(bytes:
                Seq<u8>, entries: Seq<JournalEntry>,
            sm: JournalStaticMetadata) {
            ::builtin::ensures([(::builtin::is_variant(apply_journal_entries(bytes,
                                        entries, sm), "Some")) ==
                            (journal_entries_valid(entries, sm))]);
            ::builtin::decreases((entries.len(),));
            if ::builtin::spec_eq(entries.len(),
                        ::builtin::spec_literal_nat("0")) {
                    return;
                } else {
                   if entries.spec_index(::builtin::spec_literal_integer("0")).fits(sm)
                           {
                           let next_bytes =
                               apply_journal_entry(bytes,
                                       entries.spec_index(::builtin::spec_literal_integer("0")),
                                       sm).unwrap();
                           lemma_apply_journal_entries_some_iff_journal_entries_valid(next_bytes,
                               entries.skip(::builtin::spec_literal_integer("1")), sm);
                       }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_apply_journal_entries_commutes_with_update_bytes(s:
                Seq<u8>, entries: Seq<JournalEntry>,
            journaled_addrs: Set<int>, addr: int, bytes_to_write: Seq<u8>,
            sm: JournalStaticMetadata) {
            ::builtin::requires([journal_entries_valid(entries, sm),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_eq(::builtin::spec_chained_le(::builtin::spec_chained_value(sm.app_area_start),
                                    sm.app_area_end), s.len())),
                        journaled_addrs_complete(entries, journaled_addrs),
                        ::builtin::forall(|i: int|
                                ::builtin::with_triggers(((journaled_addrs.contains(i),),),
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(addr),
                                                    i), (addr).spec_add(bytes_to_write.len()))),
                                        !journaled_addrs.contains(i))))]);
            ::builtin::ensures([({
                                ((if let Some(s2) = (apply_journal_entries(s, entries, sm))
                                                {
                                                ::builtin::spec_eq(apply_journal_entries(update_bytes(s,
                                                            addr, bytes_to_write), entries, sm),
                                                    Some(update_bytes(s2, addr, bytes_to_write)))
                                            } else { false }))
                            })]);
            ::builtin::decreases((entries.len(),));
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(update_bytes)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            if (::builtin::spec_literal_nat("0")).spec_lt(entries.len()) {
                    let next_state =
                        apply_journal_entry(s,
                                entries.spec_index(::builtin::spec_literal_integer("0")),
                                sm).unwrap();
                    {
                        ::builtin::assert_by(journaled_addrs_complete(entries.skip(::builtin::spec_literal_integer("1")),
                                journaled_addrs),
                            {
                                {
                                    ::builtin::assert_forall_by(|entry, addr|
                                            {
                                                ::builtin::requires(::builtin::with_triggers(((entries.skip(::builtin::spec_literal_integer("1")).contains(entry),
                                                                journaled_addrs.contains(addr)),),
                                                        entries.skip(::builtin::spec_literal_integer("1")).contains(entry)
                                                            &&
                                                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(entry.start),
                                                                        addr), entry.end()))));
                                                ::builtin::ensures(journaled_addrs.contains(addr));
                                                ::builtin::assert_(entries.contains(entry));
                                            });
                                }
                            });
                    }
                    lemma_apply_journal_entries_commutes_with_update_bytes(next_state,
                        entries.skip(::builtin::spec_literal_integer("1")),
                        journaled_addrs, addr, bytes_to_write, sm);
                    #[verifier::spec]
                    let s1 =
                        ::vstd::vstd::seq_lib::check_argument_is_seq(apply_journal_entry(update_bytes(s,
                                        addr, bytes_to_write),
                                    entries.spec_index(::builtin::spec_literal_integer("0")),
                                    sm).unwrap());
                    #[verifier::spec]
                    let s2 =
                        ::vstd::vstd::seq_lib::check_argument_is_seq(update_bytes(next_state,
                                addr, bytes_to_write));
                    ::vstd::vstd::prelude::assert_by(::vstd::vstd::prelude::equal(s1,
                            s2),
                        {
                            ::vstd::vstd::prelude::assert_(s1.len() == s2.len());
                            ::vstd::vstd::prelude::assert_forall_by(|i:
                                        ::vstd::vstd::prelude::int|
                                    {
                                        ::vstd::vstd::prelude::requires((::builtin::spec_literal_nat("0")).spec_le(i)
                                                && (i).spec_lt(s1.len()));
                                        ::vstd::vstd::prelude::ensures(::vstd::vstd::prelude::equal(s1.index(i),
                                                s2.index(i)));
                                        {
                                            {
                                                ::builtin::assert_(entries.contains(entries.spec_index(::builtin::spec_literal_integer("0"))));
                                                if ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(addr),
                                                                    i), (addr).spec_add(bytes_to_write.len()))) {
                                                        ::builtin::assert_(!journaled_addrs.contains(i));
                                                    }
                                            }
                                        }
                                    });
                            ::vstd::vstd::prelude::assert_(::vstd::vstd::prelude::ext_equal(s1,
                                    s2));
                        });
                    ;
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_updating_journal_area_doesnt_affect_apply_journal_entries(s1:
                Seq<u8>, s2: Seq<u8>, entries: Seq<JournalEntry>,
            vm: JournalVersionMetadata, sm: JournalStaticMetadata) {
            ::builtin::requires([validate_metadata(vm, sm, s1.len()),
                        ::builtin::spec_eq(s1.len(), s2.len()),
                        ::builtin::is_variant(apply_journal_entries(s1, entries,
                                sm), "Some"),
                        seqs_match_in_range(s1, s2,
                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_end))]);
            ::builtin::ensures([({
                                let s1_updated = apply_journal_entries(s1, entries, sm);
                                let s2_updated = apply_journal_entries(s2, entries, sm);
                                (::builtin::is_variant(s2_updated, "Some")) &&
                                    (seqs_match_in_range(s1_updated.unwrap(),
                                            s2_updated.unwrap(),
                                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                            ::builtin::spec_cast_integer::<_, int>(sm.app_area_end)))
                            })]);
            ::builtin::decreases((entries.len(),));
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            if (::builtin::spec_literal_nat("0")).spec_lt(entries.len()) {
                    let entry =
                        entries.spec_index(::builtin::spec_literal_integer("0"));
                    let s1_next = apply_journal_entry(s1, entry, sm).unwrap();
                    let s2_next = apply_journal_entry(s2, entry, sm).unwrap();
                    {
                        ::builtin::assert_by(::builtin::spec_eq(s1_next.subrange(::builtin::spec_cast_integer::<_,
                                            int>(sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_end)),
                                s2_next.subrange(::builtin::spec_cast_integer::<_,
                                            int>(sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_end))),
                            {
                                lemma_concatenate_three_subranges(s1_next,
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_, int>(entry.start),
                                    entry.end(),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_end));
                                lemma_concatenate_three_subranges(s2_next,
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start),
                                    ::builtin::spec_cast_integer::<_, int>(entry.start),
                                    entry.end(),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_end));
                            });
                    }
                    lemma_updating_journal_area_doesnt_affect_apply_journal_entries(s1_next,
                        s2_next, entries.skip(::builtin::spec_literal_integer("1")),
                        vm, sm);
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_space_needed_for_journal_entries_list_monotonic(entries:
                Seq<JournalEntry>, i: int, j: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), j), entries.len()))]);
            ::builtin::ensures([(space_needed_for_journal_entries_list(entries.take(i))).spec_le(space_needed_for_journal_entries_list(entries.take(j)))]);
            ::builtin::decreases(((j).spec_sub(i)));
            if (i).spec_lt(j) {
                    lemma_space_needed_for_journal_entries_list_monotonic(entries,
                        (i).spec_add(::builtin::spec_literal_nat("1")), j);
                    ::builtin::assert_(::builtin::ext_equal(entries.take((i).spec_add(::builtin::spec_literal_nat("1"))).drop_last(),
                            entries.take(i)));
                    ::builtin::assert_(::builtin::ext_equal(entries.take((i).spec_add(::builtin::spec_literal_nat("1"))).last(),
                            entries.spec_index(i)));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_space_needed_for_journal_entries_list_increases(entries:
                Seq<JournalEntry>, i: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    i), entries.len()))]);
            ::builtin::ensures([::builtin::spec_eq(space_needed_for_journal_entries_list(entries.take((i).spec_add(::builtin::spec_literal_nat("1")))),
                            (space_needed_for_journal_entries_list(entries.take(i))).spec_add(entries.spec_index(i).space_needed()))]);
            ::builtin::assert_(::builtin::ext_equal(entries.take((i).spec_add(::builtin::spec_literal_nat("1"))).drop_last(),
                    entries.take(i)));
            ::builtin::assert_(::builtin::ext_equal(entries.take((i).spec_add(::builtin::spec_literal_nat("1"))).last(),
                    entries.spec_index(i)));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_space_needed_for_journal_entries_list_at_least_num_entries(entries:
                Seq<JournalEntry>) {
            ::builtin::ensures([(entries.len()).spec_le(space_needed_for_journal_entries_list(entries))]);
            ::builtin::decreases((entries.len()));
            if (entries.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    lemma_space_needed_for_journal_entries_list_at_least_num_entries(entries.drop_last());
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_effect_of_append_on_apply_journal_entries(s:
                Seq<u8>, entries: Seq<JournalEntry>, new_entry: JournalEntry,
            sm: JournalStaticMetadata) {
            ::builtin::requires([::builtin::is_variant(apply_journal_entries(s,
                                entries, sm), "Some"),
                        ::builtin::is_variant(apply_journal_entry(apply_journal_entries(s,
                                        entries, sm).unwrap(), new_entry, sm), "Some"),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_eq(::builtin::spec_chained_le(::builtin::spec_chained_value(sm.app_area_start),
                                    sm.app_area_end), s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(apply_journal_entries(s,
                                entries.push(new_entry), sm),
                            apply_journal_entry(apply_journal_entries(s, entries,
                                        sm).unwrap(), new_entry, sm))]);
            ::builtin::decreases((entries.len(),));
            if ::builtin::spec_eq(entries.len(),
                        ::builtin::spec_literal_nat("0")) {
                    let s_next = apply_journal_entry(s, new_entry, sm).unwrap();
                    ::builtin::assert_(::builtin::spec_eq(entries.push(new_entry).spec_index(::builtin::spec_literal_integer("0")),
                            new_entry));
                    ::builtin::assert_(::builtin::spec_eq(apply_journal_entry(s,
                                entries.push(new_entry).spec_index(::builtin::spec_literal_integer("0")),
                                sm), Some(s_next)));
                    ::builtin::assert_(::builtin::spec_eq(apply_journal_entries(s_next,
                                entries.push(new_entry).skip(::builtin::spec_literal_integer("1")),
                                sm), Some(s_next)));
                } else {
                   ::builtin::reveal_hide_({
                           #[verus::internal(reveal_fn)]
                           fn __VERUS_REVEAL_INTERNAL__() {
                               ::builtin::reveal_hide_internal_path_(update_bytes)
                           }
                           __VERUS_REVEAL_INTERNAL__
                       }, 1);
                   ::builtin::assert_(::builtin::spec_eq(entries.push(new_entry).spec_index(::builtin::spec_literal_integer("0")),
                           entries.spec_index(::builtin::spec_literal_integer("0"))));
                   let s_next =
                       apply_journal_entry(s,
                               entries.spec_index(::builtin::spec_literal_integer("0")),
                               sm).unwrap();
                   ::builtin::assert_(::builtin::spec_eq(apply_journal_entry(s,
                               entries.push(new_entry).spec_index(::builtin::spec_literal_integer("0")),
                               sm), Some(s_next)));
                   lemma_effect_of_append_on_apply_journal_entries(s_next,
                       entries.skip(::builtin::spec_literal_integer("1")),
                       new_entry, sm);
                   ::builtin::assert_(::builtin::ext_equal(entries.push(new_entry).skip(::builtin::spec_literal_integer("1")),
                           entries.skip(::builtin::spec_literal_integer("1")).push(new_entry)));
               }
        }
    }
    mod impl_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::subrange_v::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::power_t::*;
        use super::entry_v::*;
        use super::inv_v::*;
        use super::recover_v::*;
        use super::spec_v::*;
        #[verus::internal(verus_macro)]
        pub struct Journal<PM> where PM: PersistentMemoryRegion {
            pub(super) powerpm: PoWERPersistentMemoryRegion<PM>,
            pub(super) vm: Ghost<JournalVersionMetadata>,
            pub(super) sm: JournalStaticMetadata,
            pub(super) status: Ghost<JournalStatus>,
            pub(super) constants: JournalConstants,
            pub(super) journal_length: u64,
            pub(super) journaled_addrs: Ghost<Set<int>>,
            pub(super) entries: ConcreteJournalEntries,
        }
        #[verus::internal(verus_macro)]
        impl<PM> Journal<PM> where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn view(&self) -> JournalView {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                JournalView {
                    constants: self.constants,
                    pm_constants: self.powerpm.constants(),
                    durable_state: (self.powerpm.view()).durable_state,
                    read_state: (self.powerpm.view()).read_state,
                    commit_state: apply_journal_entries((self.powerpm.view()).read_state,
                            (self.entries.view()), self.sm).unwrap(),
                    remaining_capacity: (self.constants.journal_capacity).spec_sub(self.journal_length),
                    journaled_addrs: (self.journaled_addrs.view()),
                    powerpm_id: self.powerpm.id(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                (self.inv()) &&
                    (::builtin::is_variant((self.status.view()), "Quiescent"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn recover(bytes: Seq<u8>) -> Option<RecoveredJournal> {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                recover_journal(bytes)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn recover_idempotent(self) -> bool {
                ::builtin::spec_eq(Self::recover((self.view()).durable_state),
                    Some(RecoveredJournal {
                            constants: (self.view()).constants,
                            state: (self.view()).durable_state,
                        }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn state_recovery_idempotent(state: Seq<u8>,
                constants: JournalConstants) -> bool {
                ::builtin::spec_eq(Self::recover(state),
                    Some(RecoveredJournal { constants, state }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn recovery_equivalent_for_app(state1: Seq<u8>,
                state2: Seq<u8>) -> bool {
                ((if let Some(j1) = (Self::recover(state1)) {
                                ((if let Some(j2) = (Self::recover(state2)) {
                                                ((::builtin::spec_chained_cmp(::builtin::spec_chained_eq(::builtin::spec_chained_eq(::builtin::spec_chained_value(j1.state.len()),
                                                                            state1.len()), state2.len()))) &&
                                                            (::builtin::spec_eq(j1.constants, j2.constants))) &&
                                                    (seqs_match_in_range(j1.state, j2.state,
                                                            ::builtin::spec_cast_integer::<_,
                                                                    int>(j1.constants.app_area_start),
                                                            ::builtin::spec_cast_integer::<_,
                                                                    int>(j1.constants.app_area_end)))
                                            } else { false }))
                            } else { false }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn remaining_capacity(&self) -> u64 {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: u64|
                        [::builtin::spec_eq(result,
                                    (self.view()).remaining_capacity)]);
                self.constants.journal_capacity - self.journal_length
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_valid_implications(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([self.recover_idempotent(),
                            (self.view()).valid()]);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn journal_entry_overhead() -> u64 {
                ::builtin::ensures(|result: u64|
                        [::builtin::spec_eq(result, spec_journal_entry_overhead()),
                                (result).spec_le(::builtin::spec_literal_nat("100"))]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                (size_of::<u64>() + size_of::<u64>()) as u64
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_pm_region_ref(&self) -> &PM {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: &PM|
                        [result.inv(),
                                ::builtin::spec_eq(result.constants(),
                                    (self.view()).pm_constants),
                                ::builtin::spec_eq((result.view()).read_state,
                                    (self.view()).read_state), (result.view()).valid()]);

                #[verifier::proof_block]
                { self.powerpm.lemma_inv_implies_view_valid(); }
                self.powerpm.get_pm_region_ref()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn constants(&self) -> &JournalConstants {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: &JournalConstants|
                        [::builtin::spec_eq(result, (self.view()).constants)]);
                &self.constants
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn abort(&mut self) {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures([self.valid(), (self.view()).valid(),
                            self.recover_idempotent(),
                            ::builtin::spec_eq((self.view()),
                                (old(self).view()).abort())]);
                self.journal_length = 0;
                self.journaled_addrs =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] Set::<int>::empty());
                self.entries = ConcreteJournalEntries::new();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn flush(&mut self) {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures([self.valid(),
                            ::builtin::spec_eq((self.view()), (old(self).view())),
                            ::builtin::spec_eq((self.view()).durable_state,
                                (self.view()).read_state)]);
                self.powerpm.flush();
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_journal_entry_overhead() -> nat {
            #[verus::internal(open_visibility_qualifier)]
            pub(super) use crate as _;
            ::builtin::spec_cast_integer::<_,
                    nat>(((u64::spec_size_of()).spec_add(u64::spec_size_of())))
        }
    }
    mod inv_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmemspec_t::*;
        use crate::common::subrange_v::*;
        use crate::pmem::power_t::*;
        use super::entry_v::*;
        use super::impl_v::*;
        use super::recover_v::*;
        #[verus::internal(verus_macro)]
        pub(super) enum JournalStatus {
            Quiescent,
            WritingJournal,
            Committed,
        }
        #[verus::internal(verus_macro)]
        impl<PM> Journal<PM> where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_constants_match(self) -> bool {
                ((((::builtin::spec_eq(self.constants.app_version_number,
                                                    self.sm.app_version_number)) &&
                                            (::builtin::spec_eq(self.constants.app_program_guid,
                                                    self.sm.app_program_guid))) &&
                                    (::builtin::spec_eq(self.constants.journal_capacity,
                                            (self.sm.journal_entries_end).spec_sub(self.sm.journal_entries_start))))
                            &&
                            (::builtin::spec_eq(self.constants.app_area_start,
                                    self.sm.app_area_start))) &&
                    (::builtin::spec_eq(self.constants.app_area_end,
                            self.sm.app_area_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv(self) -> bool {
                let pmv = self.powerpm.view();
                (((((((self.powerpm.inv()) && ((self.view()).valid())) &&
                                                            (pmv.valid())) && (self.inv_constants_match())) &&
                                            (::builtin::spec_eq(self.constants.app_area_end,
                                                    pmv.len()))) &&
                                    (::builtin::spec_eq(recover_version_metadata(pmv.durable_state),
                                            Some((self.vm.view()))))) &&
                            (::builtin::spec_eq(recover_static_metadata(pmv.durable_state,
                                        (self.vm.view())), Some(self.sm)))) &&
                    (((if let Some(committed) =
                                            (recover_committed_cdb(pmv.durable_state, self.sm)) {
                                        ((((match (self.status.view()) {
                                                                            JournalStatus::Quiescent => {
                                                                                (!committed) &&
                                                                                    (seqs_match_except_in_range(pmv.durable_state,
                                                                                            pmv.read_state,
                                                                                            ::builtin::spec_cast_integer::<_,
                                                                                                    int>(self.sm.app_area_start),
                                                                                            ::builtin::spec_cast_integer::<_,
                                                                                                    int>(self.sm.app_area_end)))
                                                                            }
                                                                            JournalStatus::WritingJournal => !committed,
                                                                            JournalStatus::Committed => committed,
                                                                        }) &&
                                                                    (journal_entries_valid((self.entries.view()), self.sm))) &&
                                                            (journaled_addrs_complete((self.entries.view()),
                                                                    (self.journaled_addrs.view())))) &&
                                                    ((self.journal_length).spec_le(self.constants.journal_capacity)))
                                            &&
                                            (::builtin::spec_eq(self.journal_length,
                                                    space_needed_for_journal_entries_list((self.entries.view()))))
                                    } else { false })))
            }
        }
    }
    mod recover_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::align_v::*;
        use crate::common::recover_v::*;
        use crate::common::subrange_v::*;
        use crate::common::util_v::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::power_t::*;
        use crate::pmem::traits_t::*;
        use deps_hack::PmCopy;
        use super::entry_v::*;
        use super::impl_v::*;
        use super::spec_v::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        pub const ABSOLUTE_POS_OF_VERSION_METADATA: u64 = 0;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        pub const JOURNAL_PROGRAM_GUID: u128 =
            0xf41bb8dd3ccc4a77bb76c8f3a5319d6a;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        pub const JOURNAL_PROGRAM_VERSION_NUMBER: u64 = 1;
        #[repr(C)]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub(super) struct JournalVersionMetadata {
            pub program_guid: u128,
            pub version_number: u64,
        }
        unsafe impl pmcopy for JournalVersionMetadata where u128: pmcopy,
            u64: pmcopy {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for JournalVersionMetadata {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                let offset: ::builtin::nat =
                    ::builtin::spec_literal_integer("0");
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u128>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    (offset).spec_add(spec_padding_needed(offset,
                            <JournalVersionMetadata>::spec_align_of()));
                offset
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                let alignment_seq =
                    <_ as
                            ::vstd::vstd::view::View>::view(&[<u128>::spec_align_of(),
                                    <u64>::spec_align_of()]);
                nat_seq_max(alignment_seq)
            }
        }
        unsafe impl PmSized for JournalVersionMetadata {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for JournalVersionMetadata {
            const SIZE: usize =
                {
                    let offset: usize = 0;
                    let offset: usize =
                        offset + <u128>::SIZE +
                            padding_needed(offset, <u128>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset +
                            padding_needed(offset, <JournalVersionMetadata>::ALIGN);
                    offset
                };
            const ALIGN: usize =
                {
                    let mut largest_alignment: usize = 0;
                    if largest_alignment <= <u128>::ALIGN {
                            largest_alignment = <u128>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    largest_alignment
                };
        }
        const SIZE_CHECK_JOURNALVERSIONMETADATA: usize =
            (core::mem::size_of::<JournalVersionMetadata>() ==
                            <JournalVersionMetadata>::SIZE) as usize - 1;
        const ALIGN_CHECK_JOURNALVERSIONMETADATA: usize =
            (core::mem::align_of::<JournalVersionMetadata>() ==
                            <JournalVersionMetadata>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for JournalVersionMetadata {}
        impl Clone for JournalVersionMetadata {
            fn clone(&self) -> Self {
                Self {
                    program_guid: self.program_guid.clone(),
                    version_number: self.version_number.clone(),
                }
            }
        }
        impl PartialEq for JournalVersionMetadata {
            fn eq(&self, other: &Self) -> bool {
                self.program_guid == other.program_guid &&
                    self.version_number == other.version_number
            }
        }
        impl Eq for JournalVersionMetadata {}
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_journalversionmetadata_clone(b: &JournalVersionMetadata)
            -> JournalVersionMetadata {
            ::builtin::ensures(|res: JournalVersionMetadata|
                    [::builtin::spec_eq(*b, res)]);
            b.clone()
        }
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_journalversionmetadata_eq(lhs: &JournalVersionMetadata,
            rhs: &JournalVersionMetadata) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
            lhs.eq(rhs)
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for JournalVersionMetadata {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> JournalVersionMetadata {
                ::builtin::ensures(|res: JournalVersionMetadata|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for JournalVersionMetadata {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self.eq(other)
            }
        }
        impl PmCopy for JournalVersionMetadata {}
        #[automatically_derived]
        impl ::core::marker::Copy for JournalVersionMetadata { }
        #[automatically_derived]
        impl ::core::default::Default for JournalVersionMetadata {
            #[inline]
            fn default() -> JournalVersionMetadata {
                JournalVersionMetadata {
                    program_guid: ::core::default::Default::default(),
                    version_number: ::core::default::Default::default(),
                }
            }
        }
        #[repr(C)]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub(super) struct JournalStaticMetadata {
            pub app_program_guid: u128,
            pub app_version_number: u64,
            pub committed_cdb_start: u64,
            pub journal_length_start: u64,
            pub journal_length_crc_start: u64,
            pub journal_entries_crc_start: u64,
            pub journal_entries_start: u64,
            pub journal_entries_end: u64,
            pub app_area_start: u64,
            pub app_area_end: u64,
        }
        unsafe impl pmcopy for JournalStaticMetadata where u128: pmcopy,
            u64: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy,
            u64: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for JournalStaticMetadata {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                let offset: ::builtin::nat =
                    ::builtin::spec_literal_integer("0");
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u128>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    (offset).spec_add(spec_padding_needed(offset,
                            <JournalStaticMetadata>::spec_align_of()));
                offset
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                let alignment_seq =
                    <_ as
                            ::vstd::vstd::view::View>::view(&[<u128>::spec_align_of(),
                                    <u64>::spec_align_of(), <u64>::spec_align_of(),
                                    <u64>::spec_align_of(), <u64>::spec_align_of(),
                                    <u64>::spec_align_of(), <u64>::spec_align_of(),
                                    <u64>::spec_align_of(), <u64>::spec_align_of(),
                                    <u64>::spec_align_of()]);
                nat_seq_max(alignment_seq)
            }
        }
        unsafe impl PmSized for JournalStaticMetadata {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for JournalStaticMetadata {
            const SIZE: usize =
                {
                    let offset: usize = 0;
                    let offset: usize =
                        offset + <u128>::SIZE +
                            padding_needed(offset, <u128>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset +
                            padding_needed(offset, <JournalStaticMetadata>::ALIGN);
                    offset
                };
            const ALIGN: usize =
                {
                    let mut largest_alignment: usize = 0;
                    if largest_alignment <= <u128>::ALIGN {
                            largest_alignment = <u128>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    largest_alignment
                };
        }
        const SIZE_CHECK_JOURNALSTATICMETADATA: usize =
            (core::mem::size_of::<JournalStaticMetadata>() ==
                            <JournalStaticMetadata>::SIZE) as usize - 1;
        const ALIGN_CHECK_JOURNALSTATICMETADATA: usize =
            (core::mem::align_of::<JournalStaticMetadata>() ==
                            <JournalStaticMetadata>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for JournalStaticMetadata {}
        impl Clone for JournalStaticMetadata {
            fn clone(&self) -> Self {
                Self {
                    app_program_guid: self.app_program_guid.clone(),
                    app_version_number: self.app_version_number.clone(),
                    committed_cdb_start: self.committed_cdb_start.clone(),
                    journal_length_start: self.journal_length_start.clone(),
                    journal_length_crc_start: self.journal_length_crc_start.clone(),
                    journal_entries_crc_start: self.journal_entries_crc_start.clone(),
                    journal_entries_start: self.journal_entries_start.clone(),
                    journal_entries_end: self.journal_entries_end.clone(),
                    app_area_start: self.app_area_start.clone(),
                    app_area_end: self.app_area_end.clone(),
                }
            }
        }
        impl PartialEq for JournalStaticMetadata {
            fn eq(&self, other: &Self) -> bool {
                self.app_program_guid == other.app_program_guid &&
                                                    self.app_version_number == other.app_version_number &&
                                                self.committed_cdb_start == other.committed_cdb_start &&
                                            self.journal_length_start == other.journal_length_start &&
                                        self.journal_length_crc_start ==
                                            other.journal_length_crc_start &&
                                    self.journal_entries_crc_start ==
                                        other.journal_entries_crc_start &&
                                self.journal_entries_start == other.journal_entries_start &&
                            self.journal_entries_end == other.journal_entries_end &&
                        self.app_area_start == other.app_area_start &&
                    self.app_area_end == other.app_area_end
            }
        }
        impl Eq for JournalStaticMetadata {}
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_journalstaticmetadata_clone(b: &JournalStaticMetadata)
            -> JournalStaticMetadata {
            ::builtin::ensures(|res: JournalStaticMetadata|
                    [::builtin::spec_eq(*b, res)]);
            b.clone()
        }
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_journalstaticmetadata_eq(lhs: &JournalStaticMetadata,
            rhs: &JournalStaticMetadata) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
            lhs.eq(rhs)
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for JournalStaticMetadata {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> JournalStaticMetadata {
                ::builtin::ensures(|res: JournalStaticMetadata|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for JournalStaticMetadata {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self.eq(other)
            }
        }
        impl PmCopy for JournalStaticMetadata {}
        #[automatically_derived]
        impl ::core::marker::Copy for JournalStaticMetadata { }
        #[automatically_derived]
        impl ::core::default::Default for JournalStaticMetadata {
            #[inline]
            fn default() -> JournalStaticMetadata {
                JournalStaticMetadata {
                    app_program_guid: ::core::default::Default::default(),
                    app_version_number: ::core::default::Default::default(),
                    committed_cdb_start: ::core::default::Default::default(),
                    journal_length_start: ::core::default::Default::default(),
                    journal_length_crc_start: ::core::default::Default::default(),
                    journal_entries_crc_start: ::core::default::Default::default(),
                    journal_entries_start: ::core::default::Default::default(),
                    journal_entries_end: ::core::default::Default::default(),
                    app_area_start: ::core::default::Default::default(),
                    app_area_end: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for JournalStaticMetadata {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let names: &'static _ =
                    &["app_program_guid", "app_version_number",
                                "committed_cdb_start", "journal_length_start",
                                "journal_length_crc_start", "journal_entries_crc_start",
                                "journal_entries_start", "journal_entries_end",
                                "app_area_start", "app_area_end"];
                let values: &[&dyn ::core::fmt::Debug] =
                    &[&self.app_program_guid, &self.app_version_number,
                                &self.committed_cdb_start, &self.journal_length_start,
                                &self.journal_length_crc_start,
                                &self.journal_entries_crc_start,
                                &self.journal_entries_start, &self.journal_entries_end,
                                &self.app_area_start, &&self.app_area_end];
                ::core::fmt::Formatter::debug_struct_fields_finish(f,
                    "JournalStaticMetadata", names, values)
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_version_metadata_start() -> int {
            ::builtin::spec_literal_integer("0")
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_version_metadata_end() -> int {
            ::builtin::spec_cast_integer::<_,
                    int>(JournalVersionMetadata::spec_size_of())
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_version_metadata_crc_start() -> int {
            round_up_to_alignment(spec_journal_version_metadata_end(),
                ::builtin::spec_cast_integer::<_, int>(u64::spec_align_of()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_version_metadata_crc_end() -> int {
            (spec_journal_version_metadata_crc_start()).spec_add(::builtin::spec_cast_integer::<_,
                        int>(u64::spec_size_of()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_static_metadata_start() -> int {
            round_up_to_alignment(spec_journal_version_metadata_crc_end(),
                ::builtin::spec_cast_integer::<_,
                        int>(JournalStaticMetadata::spec_align_of()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_static_metadata_end() -> int {
            (spec_journal_static_metadata_start()).spec_add(JournalStaticMetadata::spec_size_of())
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_static_metadata_crc_start() -> int {
            round_up_to_alignment(spec_journal_static_metadata_end(),
                ::builtin::spec_cast_integer::<_, int>(u64::spec_align_of()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_journal_static_metadata_crc_end() -> int {
            (spec_journal_static_metadata_crc_start()).spec_add(::builtin::spec_cast_integer::<_,
                        int>(u64::spec_size_of()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn validate_version_metadata(m: JournalVersionMetadata)
            -> bool {
            ((spec_journal_version_metadata_end()).spec_le(spec_journal_version_metadata_crc_start()))
                && (::builtin::spec_eq(m.program_guid, JOURNAL_PROGRAM_GUID))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_version_metadata(bytes: Seq<u8>)
            -> Option<JournalVersionMetadata> {
            if (spec_journal_version_metadata_crc_end()).spec_gt(bytes.len())
                    {
                    None
                } else {
                   match recover_object::<JournalVersionMetadata>(bytes,
                           spec_journal_version_metadata_start(),
                           spec_journal_version_metadata_crc_start()) {
                       Some(vm) =>
                           if validate_version_metadata(vm) { Some(vm) } else { None },
                       None => None,
                   }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn validate_static_metadata(sm: JournalStaticMetadata,
            vm: JournalVersionMetadata) -> bool {
            if ::builtin::spec_eq(vm.version_number,
                        JOURNAL_PROGRAM_VERSION_NUMBER) {
                    (((((((((((((spec_journal_version_metadata_crc_end()).spec_le(spec_journal_static_metadata_start()))
                                                                                                                &&
                                                                                                                (((spec_journal_static_metadata_start()).spec_add(JournalStaticMetadata::spec_size_of())).spec_le(spec_journal_static_metadata_end())))
                                                                                                        &&
                                                                                                        ((spec_journal_static_metadata_end()).spec_le(spec_journal_static_metadata_crc_start())))
                                                                                                &&
                                                                                                (::builtin::spec_eq((spec_journal_static_metadata_crc_start()).spec_add(u64::spec_size_of()),
                                                                                                        spec_journal_static_metadata_crc_end()))) &&
                                                                                        ((spec_journal_static_metadata_crc_end()).spec_le(sm.committed_cdb_start)))
                                                                                &&
                                                                                (((sm.committed_cdb_start).spec_add(u64::spec_size_of())).spec_le(sm.journal_length_start)))
                                                                        &&
                                                                        (is_aligned(::builtin::spec_cast_integer::<_,
                                                                                        int>(sm.committed_cdb_start),
                                                                                ::builtin::spec_cast_integer::<_,
                                                                                        int>(const_persistence_chunk_size())))) &&
                                                                (((sm.journal_length_start).spec_add(u64::spec_size_of())).spec_le(sm.journal_length_crc_start)))
                                                        &&
                                                        (((sm.journal_length_crc_start).spec_add(u64::spec_size_of())).spec_le(sm.journal_entries_crc_start)))
                                                &&
                                                (((sm.journal_entries_crc_start).spec_add(u64::spec_size_of())).spec_le(sm.journal_entries_start)))
                                        &&
                                        ((sm.journal_entries_start).spec_le(sm.journal_entries_end)))
                                && ((sm.journal_entries_end).spec_le(sm.app_area_start))) &&
                        ((sm.app_area_start).spec_le(sm.app_area_end))
                } else { false }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_static_metadata(bytes: Seq<u8>,
            vm: JournalVersionMetadata) -> Option<JournalStaticMetadata> {
            if (spec_journal_static_metadata_crc_end()).spec_gt(bytes.len()) {
                    None
                } else {
                   match recover_object::<JournalStaticMetadata>(bytes,
                           spec_journal_static_metadata_start(),
                           spec_journal_static_metadata_crc_start()) {
                       Some(sm) =>
                           if validate_static_metadata(sm, vm) &&
                                       ::builtin::spec_eq(sm.app_area_end, bytes.len()) {
                                   Some(sm)
                               } else { None },
                       None => None,
                   }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn validate_metadata(vm: JournalVersionMetadata,
            sm: JournalStaticMetadata, num_bytes: nat) -> bool {
            ((((validate_version_metadata(vm)) &&
                                        (validate_static_metadata(sm, vm))) &&
                                ((spec_journal_version_metadata_crc_end()).spec_le(num_bytes)))
                        &&
                        ((spec_journal_static_metadata_crc_end()).spec_le(num_bytes)))
                && (::builtin::spec_eq(sm.app_area_end, num_bytes))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_journal_length(bytes: Seq<u8>,
            sm: JournalStaticMetadata) -> Option<u64> {
            match recover_object::<u64>(bytes,
                    ::builtin::spec_cast_integer::<_,
                            int>(sm.journal_length_start),
                    ::builtin::spec_cast_integer::<_,
                            int>(sm.journal_length_crc_start)) {
                None => None,
                Some(journal_length) =>
                    if ((sm.journal_entries_start).spec_add(journal_length)).spec_le(sm.journal_entries_end)
                            {
                            Some(journal_length)
                        } else { None },
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_journal_entries_bytes(bytes: Seq<u8>,
            sm: JournalStaticMetadata, journal_length: u64)
            -> Option<Seq<u8>> {
            recover_bytes(bytes,
                ::builtin::spec_cast_integer::<_,
                        int>(sm.journal_entries_start),
                ::builtin::spec_cast_integer::<_, nat>(journal_length),
                ::builtin::spec_cast_integer::<_,
                        int>(sm.journal_entries_crc_start))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn parse_journal_entry(entries_bytes: Seq<u8>)
            -> Option<(JournalEntry, int)> {
            ::builtin::decreases((entries_bytes.len()));
            if ((u64::spec_size_of()).spec_add(u64::spec_size_of())).spec_gt(entries_bytes.len())
                    {
                    None
                } else {
                   let addr_bytes =
                       extract_section(entries_bytes,
                           ::builtin::spec_literal_integer("0"), u64::spec_size_of());
                   let addr = u64::spec_from_bytes(addr_bytes);
                   let length_bytes =
                       extract_section(entries_bytes,
                           ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()),
                           u64::spec_size_of());
                   let length = u64::spec_from_bytes(length_bytes);
                   let data_offset =
                       (u64::spec_size_of()).spec_add(u64::spec_size_of());
                   if ((data_offset).spec_add(length)).spec_gt(entries_bytes.len())
                           {
                           None
                       } else {
                          let data =
                              extract_section(entries_bytes,
                                  ::builtin::spec_cast_integer::<_, int>(data_offset),
                                  ::builtin::spec_cast_integer::<_, nat>(length));
                          let entry =
                              JournalEntry {
                                  start: ::builtin::spec_cast_integer::<_, int>(addr),
                                  bytes_to_write: data,
                              };
                          Some((entry, (data_offset).spec_add(length)))
                      }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn parse_journal_entries(entries_bytes: Seq<u8>)
            -> Option<Seq<JournalEntry>> {
            ::builtin::decreases((entries_bytes.len()));
            if ::builtin::spec_eq(entries_bytes.len(),
                        ::builtin::spec_literal_nat("0")) {
                    Some(Seq::<JournalEntry>::empty())
                } else {
                   match parse_journal_entry(entries_bytes) {
                       None => None,
                       Some((entry, num_bytes)) =>
                           match parse_journal_entries(entries_bytes.skip(num_bytes)) {
                               None => None,
                               Some(remaining_journal) =>
                                   Some((::vstd::vstd::seq::Seq::empty().push(entry)).spec_add(remaining_journal)),
                           },
                   }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_journal_entries(bytes: Seq<u8>,
            sm: JournalStaticMetadata, journal_length: u64)
            -> Option<Seq<JournalEntry>> {
            match recover_journal_entries_bytes(bytes, sm, journal_length) {
                None => None,
                Some(entries_bytes) => parse_journal_entries(entries_bytes),
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_storage_state_case_committed(bytes: Seq<u8>,
            sm: JournalStaticMetadata) -> Option<Seq<u8>> {
            match recover_journal_length(bytes, sm) {
                None => None,
                Some(journal_length) => {
                    match recover_journal_entries(bytes, sm, journal_length) {
                        None => None,
                        Some(journal_entries) =>
                            apply_journal_entries(bytes, journal_entries, sm),
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_committed_cdb(bytes: Seq<u8>,
            sm: JournalStaticMetadata) -> Option<bool> {
            recover_cdb(bytes,
                ::builtin::spec_cast_integer::<_,
                        int>(sm.committed_cdb_start))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_storage_state(bytes: Seq<u8>,
            sm: JournalStaticMetadata) -> Option<Seq<u8>> {
            match recover_committed_cdb(bytes, sm) {
                None => None,
                Some(c) =>
                    if c {
                            recover_storage_state_case_committed(bytes, sm)
                        } else { Some(bytes) },
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_journal(bytes: Seq<u8>)
            -> Option<RecoveredJournal> {
            match recover_version_metadata(bytes) {
                None => None,
                Some(vm) =>
                    match recover_static_metadata(bytes, vm) {
                        None => None,
                        Some(sm) =>
                            match recover_storage_state(bytes, sm) {
                                None => None,
                                Some(state) =>
                                    Some(RecoveredJournal {
                                            constants: JournalConstants {
                                                app_program_guid: sm.app_program_guid,
                                                app_version_number: sm.app_version_number,
                                                journal_capacity: ::builtin::spec_cast_integer::<_,
                                                        u64>(((sm.journal_entries_end).spec_sub(sm.journal_entries_start))),
                                                app_area_start: sm.app_area_start,
                                                app_area_end: sm.app_area_end,
                                            },
                                            state,
                                        }),
                            },
                    },
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn spec_recovery_equivalent_for_app(state1: Seq<u8>,
            state2: Seq<u8>) -> bool {
            ((if let Some(j1) = (recover_journal(state1)) {
                            ((if let Some(j2) = (recover_journal(state2)) {
                                            (::builtin::spec_eq(j1.constants, j2.constants)) &&
                                                (seqs_match_in_range(j1.state, j2.state,
                                                        ::builtin::spec_cast_integer::<_,
                                                                int>(j1.constants.app_area_start),
                                                        ::builtin::spec_cast_integer::<_,
                                                                int>(j1.constants.app_area_end)))
                                        } else { false }))
                        } else { false }))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recovers_to(s: Seq<u8>, vm: JournalVersionMetadata,
            sm: JournalStaticMetadata, constants: JournalConstants) -> bool {
            (((::builtin::spec_eq(recover_version_metadata(s), Some(vm))) &&
                                (::builtin::spec_eq(recover_static_metadata(s, vm),
                                        Some(sm)))) &&
                        (::builtin::spec_eq(recover_committed_cdb(s, sm),
                                Some(false)))) &&
                (((if let Some(j) = (recover_journal(s)) {
                                    (::builtin::spec_eq(j.constants, constants)) &&
                                        (::builtin::spec_eq(j.state, s))
                                } else { false })))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_recovery_doesnt_depend_on_journal_contents_when_uncommitted(s1:
                Seq<u8>, s2: Seq<u8>, vm: JournalVersionMetadata,
            sm: JournalStaticMetadata, constants: JournalConstants) {
            ::builtin::requires([recovers_to(s1, vm, sm, constants),
                        seqs_match_except_in_range(s1, s2,
                            ::builtin::spec_cast_integer::<_,
                                    int>(sm.journal_length_start),
                            ::builtin::spec_cast_integer::<_,
                                    int>(sm.journal_entries_end))]);
            ::builtin::ensures([recovers_to(s2, vm, sm, constants)]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        impl<PM> Journal<PM> where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_recover_doesnt_change_size(bytes: Seq<u8>) {
                ::builtin::ensures([((if let Some(j) = (Self::recover(bytes))
                                            {
                                            ::builtin::spec_eq(j.state.len(), bytes.len())
                                        } else { true }))]);
                if ::builtin::is_variant(recover_journal(bytes), "None") {
                        return;
                    }
                let vm = recover_version_metadata(bytes).unwrap();
                let sm = recover_static_metadata(bytes, vm).unwrap();
                if ::builtin::spec_eq(recover_committed_cdb(bytes, sm),
                            Some(false)) {
                        return;
                    }
                let journal_length =
                    recover_journal_length(bytes, sm).unwrap();
                let entries =
                    recover_journal_entries(bytes, sm, journal_length).unwrap();
                lemma_apply_journal_entries_doesnt_change_size(bytes, entries,
                    sm);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_recover_from_commit_idempotent(self) {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures([::builtin::spec_eq(Self::recover((self.view()).commit_state),
                                Some(RecoveredJournal {
                                        constants: (self.view()).constants,
                                        state: (self.view()).commit_state,
                                    }))]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                lemma_apply_journal_entries_some_iff_journal_entries_valid((self.view()).read_state,
                    (self.entries.view()), self.sm);
                lemma_apply_journal_entries_only_affects_app_area((self.view()).read_state,
                    (self.vm.view()), self.sm, (self.entries.view()));
            }
        }
    }
    mod setup_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmemutil_v::*;
        use crate::pmem::traits_t::size_of;
        use crate::pmem::power_t::*;
        use crate::common::align_v::*;
        use crate::common::subrange_v::*;
        use super::impl_v::*;
        use super::recover_v::*;
        use super::spec_v::*;
        use vstd::arithmetic::overflow::CheckedU64;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        struct AddressesForSetup {
            journal_version_metadata_start: u64,
            journal_version_metadata_crc_start: u64,
            journal_static_metadata_start: u64,
            journal_static_metadata_end: u64,
            journal_static_metadata_crc_start: u64,
            journal_dynamic_area_start: u64,
            committed_cdb_start: u64,
            journal_length_start: u64,
            journal_length_crc_start: u64,
            journal_entries_crc_start: u64,
            journal_entries_start: u64,
            journal_entries_end: u64,
        }
        #[verus::internal(verus_macro)]
        impl AddressesForSetup {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn valid(&self, journal_capacity: u64) -> bool {
                (((((((((((((((((((::builtin::spec_eq(self.journal_version_metadata_start,
                                                                                                                                                                            spec_journal_version_metadata_start())) &&
                                                                                                                                                                    (((self.journal_version_metadata_start).spec_add(JournalVersionMetadata::spec_size_of())).spec_le(self.journal_version_metadata_crc_start)))
                                                                                                                                                            &&
                                                                                                                                                            (::builtin::spec_eq(self.journal_version_metadata_crc_start,
                                                                                                                                                                    spec_journal_version_metadata_crc_start()))) &&
                                                                                                                                                    (is_aligned(::builtin::spec_cast_integer::<_,
                                                                                                                                                                    int>(self.journal_version_metadata_crc_start),
                                                                                                                                                            ::builtin::spec_cast_integer::<_,
                                                                                                                                                                    int>(u64::spec_size_of())))) &&
                                                                                                                                            (::builtin::spec_eq(self.journal_version_metadata_crc_start,
                                                                                                                                                    round_up_to_alignment((self.journal_version_metadata_start).spec_add(JournalVersionMetadata::spec_size_of()),
                                                                                                                                                        ::builtin::spec_cast_integer::<_,
                                                                                                                                                                int>(u64::spec_align_of()))))) &&
                                                                                                                                    (((self.journal_version_metadata_crc_start).spec_add(u64::spec_size_of())).spec_le(self.journal_static_metadata_start)))
                                                                                                                            &&
                                                                                                                            (::builtin::spec_eq(self.journal_static_metadata_start,
                                                                                                                                    spec_journal_static_metadata_start()))) &&
                                                                                                                    (is_aligned(::builtin::spec_cast_integer::<_,
                                                                                                                                    int>(self.journal_static_metadata_start),
                                                                                                                            ::builtin::spec_cast_integer::<_,
                                                                                                                                    int>(JournalStaticMetadata::spec_align_of())))) &&
                                                                                                            (::builtin::spec_eq((self.journal_static_metadata_start).spec_add(JournalStaticMetadata::spec_size_of()),
                                                                                                                    self.journal_static_metadata_end))) &&
                                                                                                    ((self.journal_static_metadata_end).spec_le(self.journal_static_metadata_crc_start)))
                                                                                            &&
                                                                                            (::builtin::spec_eq(self.journal_static_metadata_crc_start,
                                                                                                    spec_journal_static_metadata_crc_start()))) &&
                                                                                    (is_aligned(::builtin::spec_cast_integer::<_,
                                                                                                    int>(self.journal_static_metadata_crc_start),
                                                                                            ::builtin::spec_cast_integer::<_,
                                                                                                    int>(u64::spec_size_of())))) &&
                                                                            (((self.journal_static_metadata_crc_start).spec_add(u64::spec_size_of())).spec_le(self.journal_dynamic_area_start)))
                                                                    &&
                                                                    ((self.journal_dynamic_area_start).spec_le(self.committed_cdb_start)))
                                                            &&
                                                            (is_aligned(::builtin::spec_cast_integer::<_,
                                                                            int>(self.committed_cdb_start),
                                                                    ::builtin::spec_cast_integer::<_,
                                                                            int>(const_persistence_chunk_size())))) &&
                                                    (((self.committed_cdb_start).spec_add(u64::spec_size_of())).spec_le(self.journal_length_start)))
                                            &&
                                            (((self.journal_length_start).spec_add(u64::spec_size_of())).spec_le(self.journal_length_crc_start)))
                                    &&
                                    (((self.journal_length_crc_start).spec_add(u64::spec_size_of())).spec_le(self.journal_entries_crc_start)))
                            &&
                            (((self.journal_entries_crc_start).spec_add(u64::spec_size_of())).spec_le(self.journal_entries_start)))
                    &&
                    (::builtin::spec_eq((self.journal_entries_start).spec_add(journal_capacity),
                            self.journal_entries_end))
            }
        }
        #[verus::internal(verus_macro)]
        impl<PM> Journal<PM> where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_space_needed_for_setup(journal_capacity: nat) -> nat {
                let journal_version_metadata_start: int =
                    ::builtin::spec_literal_integer("0");
                let journal_version_metadata_end =
                    ::builtin::spec_cast_integer::<_,
                            int>(JournalVersionMetadata::spec_size_of());
                let (journal_version_metadata_crc_start,
                        journal_version_metadata_crc_end) =
                    spec_reserve_space::<u64>(journal_version_metadata_end);
                let (journal_static_metadata_start,
                        journal_static_metadata_end) =
                    spec_reserve_space::<JournalStaticMetadata>(journal_version_metadata_crc_end);
                let (journal_static_metadata_crc_start,
                        journal_static_metadata_crc_end) =
                    spec_reserve_space::<u64>(journal_static_metadata_end);
                let (committed_cdb_start, committed_cdb_end) =
                    spec_reserve_space::<u64>(journal_static_metadata_crc_end);
                let (journal_length_start, journal_length_end) =
                    spec_reserve_space::<u64>(committed_cdb_end);
                let (journal_length_crc_start, journal_length_crc_end) =
                    spec_reserve_space::<u64>(journal_length_end);
                let (journal_entries_crc_start, journal_entries_crc_end) =
                    spec_reserve_space::<u64>(journal_length_crc_end);
                let (journal_entries_start, journal_entries_end) =
                    spec_reserve_specified_space(journal_entries_crc_end,
                        ::builtin::spec_cast_integer::<_, int>(journal_capacity),
                        ::builtin::spec_cast_integer::<_,
                                int>(u64::spec_size_of()));
                ::builtin::spec_cast_integer::<_, nat>(journal_entries_end)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn space_needed_for_setup(journal_capacity: &CheckedU64)
                -> CheckedU64 {
                ::builtin::ensures(|result: CheckedU64|
                        [::builtin::spec_eq((result.view()),
                                    Self::spec_space_needed_for_setup((journal_capacity.view()))),
                                ((journal_capacity.view())).spec_le((result.view()))]);
                let journal_version_metadata_end =
                    CheckedU64::new(size_of::<JournalVersionMetadata>() as u64);
                let (journal_version_metadata_crc_start,
                        journal_version_metadata_crc_end) =
                    reserve_space::<u64>(&journal_version_metadata_end);
                let (journal_static_metadata_start,
                        journal_static_metadata_end) =
                    reserve_space::<JournalStaticMetadata>(&journal_version_metadata_crc_end);
                let (journal_static_metadata_crc_start,
                        journal_static_metadata_crc_end) =
                    reserve_space::<u64>(&journal_static_metadata_end);
                let (committed_cdb_start, committed_cdb_end) =
                    reserve_space::<u64>(&journal_static_metadata_crc_end);
                let (journal_length_start, journal_length_end) =
                    reserve_space::<u64>(&committed_cdb_end);
                let (journal_length_crc_start, journal_length_crc_end) =
                    reserve_space::<u64>(&journal_length_end);
                let (journal_entries_crc_start, journal_entries_crc_end) =
                    reserve_space::<u64>(&journal_length_crc_end);
                let (journal_entries_start, journal_entries_end) =
                    reserve_specified_space_checked_u64(&journal_entries_crc_end,
                        &journal_capacity, size_of::<u64>() as u64);
                journal_entries_end
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn get_addresses_for_setup(journal_capacity: u64)
                -> Option<AddressesForSetup> {
                ::builtin::ensures(|result: Option<AddressesForSetup>|
                        [match result {
                                    Some(addrs) => {
                                        (addrs.valid(journal_capacity)) &&
                                            (::builtin::spec_eq(addrs.journal_entries_end,
                                                    Self::spec_space_needed_for_setup(::builtin::spec_cast_integer::<_,
                                                                nat>(journal_capacity))))
                                    }
                                    None =>
                                        (u64::MAX).spec_lt(Self::spec_space_needed_for_setup(::builtin::spec_cast_integer::<_,
                                                        nat>(journal_capacity))),
                                }]);
                let journal_version_metadata_end =
                    CheckedU64::new(size_of::<JournalVersionMetadata>() as u64);
                let (journal_version_metadata_crc_start,
                        journal_version_metadata_crc_end) =
                    reserve_space::<u64>(&journal_version_metadata_end);
                let (journal_static_metadata_start,
                        journal_static_metadata_end) =
                    reserve_space::<JournalStaticMetadata>(&journal_version_metadata_crc_end);
                let (journal_static_metadata_crc_start,
                        journal_static_metadata_crc_end) =
                    reserve_space::<u64>(&journal_static_metadata_end);
                let (committed_cdb_start, committed_cdb_end) =
                    reserve_space::<u64>(&journal_static_metadata_crc_end);
                let (journal_length_start, journal_length_end) =
                    reserve_space::<u64>(&committed_cdb_end);
                let (journal_length_crc_start, journal_length_crc_end) =
                    reserve_space::<u64>(&journal_length_end);
                let (journal_entries_crc_start, journal_entries_crc_end) =
                    reserve_space::<u64>(&journal_length_crc_end);
                let (journal_entries_start, journal_entries_end) =
                    reserve_specified_space(&journal_entries_crc_end,
                        journal_capacity, size_of::<u64>() as u64);
                if journal_entries_end.is_overflowed() {
                        None
                    } else {
                       Some(AddressesForSetup {
                               journal_version_metadata_start: 0,
                               journal_version_metadata_crc_start: journal_version_metadata_crc_start.unwrap(),
                               journal_static_metadata_start: journal_static_metadata_start.unwrap(),
                               journal_static_metadata_end: journal_static_metadata_end.unwrap(),
                               journal_static_metadata_crc_start: journal_static_metadata_crc_start.unwrap(),
                               journal_dynamic_area_start: committed_cdb_start.unwrap(),
                               committed_cdb_start: committed_cdb_start.unwrap(),
                               journal_length_start: journal_length_start.unwrap(),
                               journal_length_crc_start: journal_length_crc_start.unwrap(),
                               journal_entries_crc_start: journal_entries_crc_start.unwrap(),
                               journal_entries_start: journal_entries_start.unwrap(),
                               journal_entries_end: journal_entries_end.unwrap(),
                           })
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn lemma_setup_works(bytes: Seq<u8>, jc: JournalConstants,
                addrs: AddressesForSetup, vm: JournalVersionMetadata,
                sm: JournalStaticMetadata) {
                ::builtin::requires([addrs.valid(jc.journal_capacity),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(addrs.journal_entries_end),
                                            jc.app_area_start), jc.app_area_end), bytes.len())),
                            validate_metadata(vm, sm, bytes.len()),
                            ::builtin::spec_eq(vm.program_guid, JOURNAL_PROGRAM_GUID),
                            ::builtin::spec_eq(vm.version_number,
                                JOURNAL_PROGRAM_VERSION_NUMBER),
                            ::builtin::spec_eq(sm.app_program_guid,
                                jc.app_program_guid),
                            ::builtin::spec_eq(sm.app_version_number,
                                jc.app_version_number),
                            ::builtin::spec_eq(sm.committed_cdb_start,
                                addrs.committed_cdb_start),
                            ::builtin::spec_eq(sm.journal_length_start,
                                addrs.journal_length_start),
                            ::builtin::spec_eq(sm.journal_length_crc_start,
                                addrs.journal_length_crc_start),
                            ::builtin::spec_eq(sm.journal_entries_start,
                                addrs.journal_entries_start),
                            ::builtin::spec_eq(sm.journal_entries_end,
                                addrs.journal_entries_end),
                            ::builtin::spec_eq(sm.app_area_start, jc.app_area_start),
                            ::builtin::spec_eq(sm.app_area_end, jc.app_area_end),
                            ::builtin::spec_eq(sm.app_area_end, bytes.len()),
                            ({
                                    ((((::builtin::spec_eq(bytes.subrange(spec_journal_version_metadata_start(),
                                                                            spec_journal_version_metadata_end()), vm.spec_to_bytes()))
                                                                &&
                                                                (::builtin::spec_eq(bytes.subrange(spec_journal_version_metadata_crc_start(),
                                                                            spec_journal_version_metadata_crc_end()),
                                                                        spec_crc_bytes(vm.spec_to_bytes())))) &&
                                                        (::builtin::spec_eq(bytes.subrange(spec_journal_static_metadata_start(),
                                                                    spec_journal_static_metadata_end()), sm.spec_to_bytes())))
                                                &&
                                                (::builtin::spec_eq(bytes.subrange(spec_journal_static_metadata_crc_start(),
                                                            spec_journal_static_metadata_crc_end()),
                                                        spec_crc_bytes(sm.spec_to_bytes())))) &&
                                        (::builtin::spec_eq(extract_section(bytes,
                                                    ::builtin::spec_cast_integer::<_,
                                                            int>(sm.committed_cdb_start), u64::spec_size_of()),
                                                u64::spec_to_bytes(CDB_FALSE)))
                                })]);
                ::builtin::ensures([({
                                    ((if let Some(j) = (recover_journal(bytes)) {
                                                    ((::builtin::spec_eq(j.constants, jc)) &&
                                                                (::builtin::spec_eq(j.constants.journal_capacity,
                                                                        (addrs.journal_entries_end).spec_sub(addrs.journal_entries_start))))
                                                        && (::builtin::spec_eq(bytes, j.state))
                                                } else { false }))
                                })]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn setup(pm: &mut PM, jc: &JournalConstants)
                -> Result<(), JournalError> {
                ::builtin::requires([old(pm).inv()]);
                ::builtin::ensures(|result: Result<(), JournalError>|
                        [pm.inv(),
                                ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                match result {
                                    Ok(constants) => {
                                        (((((pm.view()).flush_predicted()) &&
                                                                    (::builtin::spec_eq(Self::recover((pm.view()).durable_state),
                                                                            Some(RecoveredJournal {
                                                                                    constants: *jc,
                                                                                    state: (pm.view()).durable_state,
                                                                                })))) && ((jc.app_area_start).spec_le(jc.app_area_end))) &&
                                                    (::builtin::spec_eq(jc.app_area_end, (pm.view()).len()))) &&
                                            (seqs_match_in_range((old(pm).view()).read_state,
                                                    (pm.view()).read_state,
                                                    ::builtin::spec_cast_integer::<_, int>(jc.app_area_start),
                                                    ::builtin::spec_cast_integer::<_, int>(jc.app_area_end)))
                                    }
                                    Err(JournalError::InvalidSetupParameters) => {
                                        (::builtin::spec_eq((pm.view()), (old(pm).view()))) &&
                                            ({
                                                    ((jc.app_area_start).spec_gt(jc.app_area_end)) ||
                                                        (!::builtin::spec_eq(jc.app_area_end, (pm.view()).len()))
                                                })
                                    }
                                    Err(JournalError::NotEnoughSpace) => {
                                        (::builtin::spec_eq((pm.view()), (old(pm).view()))) &&
                                            ((jc.app_area_start).spec_lt(Self::spec_space_needed_for_setup(::builtin::spec_cast_integer::<_,
                                                                nat>(jc.journal_capacity))))
                                    }
                                    Err(_) => false,
                                }]);
                if jc.app_area_start > jc.app_area_end {
                        return Err(JournalError::InvalidSetupParameters);
                    }
                let pm_size = pm.get_region_size();
                if jc.app_area_end != pm_size {
                        return Err(JournalError::InvalidSetupParameters);
                    }
                let addrs =
                    match Self::get_addresses_for_setup(jc.journal_capacity) {
                        Some(addrs) => addrs,
                        None => { return Err(JournalError::NotEnoughSpace); }
                    };
                if addrs.journal_entries_end > jc.app_area_start {
                        return Err(JournalError::NotEnoughSpace);
                    }

                #[verifier::proof_block]
                {
                    {
                        ::builtin::assert_by((pm.view()).valid(),
                            { pm.lemma_inv_implies_view_valid(); });
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(addrs.valid(jc.journal_capacity));
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_can_result_from_write_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                let vm =
                    JournalVersionMetadata {
                        program_guid: JOURNAL_PROGRAM_GUID,
                        version_number: JOURNAL_PROGRAM_VERSION_NUMBER,
                    };
                pm.serialize_and_write(addrs.journal_version_metadata_start,
                    &vm);
                let vm_crc = calculate_crc(&vm);
                pm.serialize_and_write(addrs.journal_version_metadata_crc_start,
                    &vm_crc);
                let sm =
                    JournalStaticMetadata {
                        app_program_guid: jc.app_program_guid,
                        app_version_number: jc.app_version_number,
                        committed_cdb_start: addrs.committed_cdb_start,
                        journal_length_start: addrs.journal_length_start,
                        journal_length_crc_start: addrs.journal_length_crc_start,
                        journal_entries_crc_start: addrs.journal_entries_crc_start,
                        journal_entries_start: addrs.journal_entries_start,
                        journal_entries_end: addrs.journal_entries_end,
                        app_area_start: jc.app_area_start,
                        app_area_end: jc.app_area_end,
                    };
                pm.serialize_and_write(addrs.journal_static_metadata_start,
                    &sm);
                let sm_crc = calculate_crc(&sm);
                pm.serialize_and_write(addrs.journal_static_metadata_crc_start,
                    &sm_crc);
                let committed_cdb = CDB_FALSE;
                pm.serialize_and_write(addrs.committed_cdb_start,
                    &committed_cdb);

                #[verifier::proof_block]
                {
                    Self::lemma_setup_works((pm.view()).read_state, *jc, addrs,
                        vm, sm);
                }
                pm.flush();
                Ok(())
            }
        }
    }
    mod spec_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmemspec_t::*;
        use crate::common::subrange_v::*;
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct JournalConstants {
            pub app_version_number: u64,
            pub app_program_guid: u128,
            pub journal_capacity: u64,
            pub app_area_start: u64,
            pub app_area_end: u64,
        }
        #[verus::internal(verus_macro)]
        impl JournalConstants {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                            self.app_area_start), self.app_area_end))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn clone(&self) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq(result, self)]);
                Self {
                    app_version_number: self.app_version_number,
                    app_program_guid: self.app_program_guid,
                    journal_capacity: self.journal_capacity,
                    app_area_start: self.app_area_start,
                    app_area_end: self.app_area_end,
                }
            }
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct JournalView {
            pub constants: JournalConstants,
            pub pm_constants: PersistentMemoryConstants,
            pub durable_state: Seq<u8>,
            pub read_state: Seq<u8>,
            pub commit_state: Seq<u8>,
            pub remaining_capacity: int,
            pub journaled_addrs: Set<int>,
            pub powerpm_id: int,
        }
        #[verus::internal(verus_macro)]
        impl JournalView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(&self) -> bool {
                (((((self.constants.valid()) && (self.pm_constants.valid()))
                                            &&
                                            (::builtin::spec_eq(self.durable_state.len(),
                                                    self.read_state.len()))) &&
                                    (::builtin::spec_eq(self.read_state.len(),
                                            self.commit_state.len()))) &&
                            ((self.remaining_capacity).spec_ge(::builtin::spec_literal_nat("0"))))
                    &&
                    ((self.constants.app_area_end).spec_le(self.durable_state.len()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn len(&self) -> nat { self.durable_state.len() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn matches_in_range(self, other: JournalView, start: int,
                end: int) -> bool {
                ((((((self.valid()) && (other.valid())) &&
                                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(self.constants.app_area_start),
                                                                        start), end), self.constants.app_area_end)))) &&
                                            (seqs_match_in_range(self.durable_state,
                                                    other.durable_state, start, end))) &&
                                    (seqs_match_in_range(self.read_state, other.read_state,
                                            start, end))) &&
                            (seqs_match_in_range(self.commit_state, other.commit_state,
                                    start, end))) &&
                    (::builtin::forall(|addr: int|
                                ::builtin::imply((start).spec_le(addr) &&
                                        (addr).spec_lt(end),
                                    ::builtin::spec_eq(self.journaled_addrs.contains(addr),
                                        #[verus::internal(trigger)] other.journaled_addrs.contains(addr)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn matches_except_in_range(self, other: JournalView,
                start: int, end: int) -> bool {
                (((::builtin::spec_eq(self.constants, other.constants)) &&
                                    (::builtin::spec_eq(self.pm_constants, other.pm_constants)))
                            &&
                            (self.matches_in_range(other,
                                    ::builtin::spec_cast_integer::<_,
                                            int>(self.constants.app_area_start), start))) &&
                    (self.matches_in_range(other, end,
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.constants.app_area_end)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn abort(self) -> Self {
                JournalView {
                    commit_state: self.read_state,
                    remaining_capacity: ::builtin::spec_cast_integer::<_,
                            int>(self.constants.journal_capacity),
                    journaled_addrs: Set::<int>::empty(),
                    ..self
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn committed_from(self, old_self: Self) -> bool {
                (::builtin::spec_eq(self,
                            JournalView {
                                durable_state: self.commit_state,
                                read_state: self.commit_state,
                                commit_state: self.commit_state,
                                remaining_capacity: ::builtin::spec_cast_integer::<_,
                                        int>(self.constants.journal_capacity),
                                journaled_addrs: Set::<int>::empty(),
                                ..old_self
                            })) &&
                    (seqs_match_in_range(old_self.commit_state,
                            self.commit_state,
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.constants.app_area_start),
                            ::builtin::spec_cast_integer::<_,
                                    int>(self.constants.app_area_end)))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_journal_view_matches_in_range_can_narrow_range(jv1:
                JournalView, jv2: JournalView, outer_start: int,
            outer_end: int, inner_start: int, inner_end: int) {
            ::builtin::requires([#[verus::internal(trigger)] jv2.matches_in_range(jv1,
                            outer_start, outer_end),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                outer_start), inner_start), inner_end), outer_end),
                                jv1.len()))]);
            ::builtin::ensures([#[verus::internal(trigger)] jv2.matches_in_range(jv1,
                            inner_start, inner_end)]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn broadcast_journal_view_matches_in_range_transitive(jv1:
                JournalView, jv2: JournalView, jv3: JournalView,
            outer_start: int, outer_end: int, inner_start: int,
            inner_end: int) {
            ::builtin::requires([jv3.matches_in_range(jv2, inner_start,
                            inner_end),
                        #[verus::internal(trigger)] jv2.matches_in_range(jv1,
                            outer_start, outer_end),
                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                outer_start), inner_start), inner_end), outer_end),
                                jv1.len()))]);
            ::builtin::ensures([#[verus::internal(trigger)] jv3.matches_in_range(jv1,
                            inner_start, inner_end)]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
        }
        #[verus::internal(verus_macro)]
        pub enum JournalError {
            CRCError,
            InvalidSetupParameters,
            NotEnoughSpace,
        }
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct RecoveredJournal {
            pub constants: JournalConstants,
            pub state: Seq<u8>,
        }
    }
    mod start_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmemutil_v::*;
        use crate::pmem::traits_t::size_of;
        use crate::pmem::power_t::*;
        use crate::common::align_v::*;
        use crate::common::recover_v::*;
        use crate::common::subrange_v::*;
        use super::entry_v::*;
        use super::impl_v::*;
        use super::inv_v::*;
        use super::recover_v::*;
        use super::spec_v::*;
        use vstd::bytes::u64_from_le_bytes;
        use vstd::slice::slice_subrange;
        #[verus::internal(verus_macro)]
        impl<PM> Journal<PM> where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn read_version_metadata(pm: &PM)
                -> Option<JournalVersionMetadata> {
                ::builtin::requires([pm.inv(),
                            recover_version_metadata((pm.view()).read_state).is_some(),
                            ((pm.view()).len()).spec_le(u64::MAX)]);
                ::builtin::ensures(|result: Option<JournalVersionMetadata>|
                        [match result {
                                    None => !pm.constants().impervious_to_corruption(),
                                    Some(vm) =>
                                        ::builtin::spec_eq(recover_version_metadata((pm.view()).read_state),
                                            Some(vm)),
                                }]);
                let journal_version_metadata_end =
                    size_of::<JournalVersionMetadata>() as u64;
                let journal_version_metadata_crc_addr =
                    exec_round_up_to_alignment::<u64>(journal_version_metadata_end);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(spec_journal_version_metadata_start(),
                                    ::builtin::spec_literal_nat("0")))
                        };
                };
                exec_recover_object(pm, 0, journal_version_metadata_crc_addr)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn read_static_metadata(pm: &PM, vm: &JournalVersionMetadata)
                -> Option<JournalStaticMetadata> {
                ::builtin::requires([pm.inv(), validate_version_metadata(*vm),
                            recover_static_metadata((pm.view()).read_state,
                                    *vm).is_some(), ((pm.view()).len()).spec_le(u64::MAX)]);
                ::builtin::ensures(|result: Option<JournalStaticMetadata>|
                        [match result {
                                    None => !pm.constants().impervious_to_corruption(),
                                    Some(sm) =>
                                        ::builtin::spec_eq(recover_static_metadata((pm.view()).read_state,
                                                *vm), Some(sm)),
                                }]);
                if vm.version_number != 1 {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return None;
                    }
                if vm.program_guid != JOURNAL_PROGRAM_GUID {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return None;
                    }
                let journal_version_metadata_end =
                    size_of::<JournalVersionMetadata>() as u64;
                let journal_version_metadata_crc_addr =
                    exec_round_up_to_alignment::<u64>(journal_version_metadata_end);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(journal_version_metadata_crc_addr,
                                    spec_journal_version_metadata_crc_start()))
                        };
                };
                let journal_version_metadata_crc_end =
                    journal_version_metadata_crc_addr + size_of::<u64>() as u64;

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(journal_version_metadata_crc_end,
                                    spec_journal_version_metadata_crc_end()))
                        };
                };
                let journal_static_metadata_start =
                    exec_round_up_to_alignment::<JournalStaticMetadata>(journal_version_metadata_crc_end);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(journal_static_metadata_start,
                                    spec_journal_static_metadata_start()))
                        };
                };
                let journal_static_metadata_end =
                    journal_static_metadata_start +
                        size_of::<JournalStaticMetadata>() as u64;

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(journal_static_metadata_end,
                                    spec_journal_static_metadata_end()))
                        };
                };
                let journal_static_metadata_crc_start =
                    exec_round_up_to_alignment::<u64>(journal_static_metadata_end);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(journal_static_metadata_crc_start,
                                    spec_journal_static_metadata_crc_start()))
                        };
                };
                exec_recover_object(pm, journal_static_metadata_start,
                    journal_static_metadata_crc_start)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn read_committed_cdb(pm: &PM, vm: &JournalVersionMetadata,
                sm: &JournalStaticMetadata) -> Option<bool> {
                ::builtin::requires([pm.inv(),
                            ((pm.view()).len()).spec_le(u64::MAX),
                            recover_committed_cdb((pm.view()).read_state,
                                    *sm).is_some(),
                            validate_metadata(*vm, *sm, (pm.view()).len())]);
                ::builtin::ensures(|result: Option<bool>|
                        [match result {
                                    None => !pm.constants().impervious_to_corruption(),
                                    Some(b) =>
                                        ::builtin::spec_eq(recover_committed_cdb((pm.view()).read_state,
                                                *sm), Some(b)),
                                }]);
                exec_recover_cdb(pm, sm.committed_cdb_start)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn read_journal_length(pm: &PM,
                verus_tmp_vm: Ghost<JournalVersionMetadata>,
                sm: &JournalStaticMetadata) -> Option<u64> {
                #[verus::internal(header_unwrap_parameter)]
                let vm;

                #[verifier::proof_block]
                { vm = verus_tmp_vm.view() };
                ::builtin::requires([pm.inv(),
                            recover_journal_length((pm.view()).read_state,
                                    *sm).is_some(),
                            validate_metadata(vm, *sm, (pm.view()).len()),
                            ((pm.view()).len()).spec_le(u64::MAX)]);
                ::builtin::ensures(|result: Option<u64>|
                        [match result {
                                    None => !pm.constants().impervious_to_corruption(),
                                    Some(journal_length) =>
                                        ::builtin::spec_eq(recover_journal_length((pm.view()).read_state,
                                                *sm), Some(journal_length)),
                                }]);
                exec_recover_object(pm, sm.journal_length_start,
                    sm.journal_length_crc_start)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn read_journal_entries_bytes(pm: &PM,
                verus_tmp_vm: Ghost<JournalVersionMetadata>,
                sm: &JournalStaticMetadata, journal_length: u64)
                -> Option<Vec<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let vm;

                #[verifier::proof_block]
                { vm = verus_tmp_vm.view() };
                ::builtin::requires([pm.inv(),
                            validate_metadata(vm, *sm, (pm.view()).len()),
                            ::builtin::spec_eq(recover_journal_length((pm.view()).read_state,
                                    *sm), Some(journal_length)),
                            ::builtin::is_variant(recover_journal_entries_bytes((pm.view()).read_state,
                                    *sm, journal_length), "Some"),
                            ((pm.view()).len()).spec_le(u64::MAX)]);
                ::builtin::ensures(|result: Option<Vec<u8>>|
                        [match result {
                                    None => !pm.constants().impervious_to_corruption(),
                                    Some(b) => {
                                        (::builtin::spec_eq(recover_journal_entries_bytes((pm.view()).read_state,
                                                        *sm, journal_length), Some((b.view())))) &&
                                            (::builtin::spec_eq(b.len(), journal_length))
                                    }
                                }]);
                exec_recover_bytes(pm, sm.journal_entries_start,
                    journal_length, sm.journal_entries_crc_start)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn install_journal_entry_during_start<PermFactory>(powerpm:
                    &mut PoWERPersistentMemoryRegion<PM>,
                verus_tmp_perm_factory: Tracked<&PermFactory>,
                verus_tmp_vm: Ghost<JournalVersionMetadata>,
                sm: &JournalStaticMetadata, start: usize, write_addr: u64,
                bytes_to_write: &[u8],
                verus_tmp_entries_bytes: Ghost<Seq<u8>>,
                verus_tmp_num_entries_installed: Ghost<int>,
                verus_tmp_entries: Ghost<Seq<JournalEntry>>,
                verus_tmp_commit_state: Ghost<Seq<u8>>) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                #[verus::internal(header_unwrap_parameter)]
                let vm;

                #[verifier::proof_block]
                { vm = verus_tmp_vm.view() };
                #[verus::internal(header_unwrap_parameter)]
                let entries_bytes;

                #[verifier::proof_block]
                { entries_bytes = verus_tmp_entries_bytes.view() };
                #[verus::internal(header_unwrap_parameter)]
                let num_entries_installed;

                #[verifier::proof_block]
                {
                    num_entries_installed =
                        verus_tmp_num_entries_installed.view()
                };
                #[verus::internal(header_unwrap_parameter)]
                let entries;

                #[verifier::proof_block]
                { entries = verus_tmp_entries.view() };
                #[verus::internal(header_unwrap_parameter)]
                let commit_state;

                #[verifier::proof_block]
                { commit_state = verus_tmp_commit_state.view() };
                ::builtin::requires([old(powerpm).inv(),
                            (old(powerpm).view()).valid(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        sm.app_area_end), (old(powerpm).view()).len())),
                            ::builtin::spec_eq(recover_version_metadata((old(powerpm).view()).durable_state),
                                Some(vm)),
                            ::builtin::spec_eq(recover_static_metadata((old(powerpm).view()).durable_state,
                                    vm), Some(*sm)),
                            ::builtin::spec_eq(recover_committed_cdb((old(powerpm).view()).durable_state,
                                    *sm), Some(true)),
                            ::builtin::spec_eq(recover_journal_length((old(powerpm).view()).durable_state,
                                    *sm),
                                Some(::builtin::spec_cast_integer::<_,
                                            u64>(entries_bytes.len()))),
                            ::builtin::spec_eq(recover_journal_entries_bytes((old(powerpm).view()).durable_state,
                                    *sm,
                                    ::builtin::spec_cast_integer::<_,
                                            u64>(entries_bytes.len())), Some(entries_bytes)),
                            journal_entries_valid(entries, *sm),
                            ::builtin::spec_eq(apply_journal_entries((old(powerpm).view()).read_state,
                                    entries.skip(num_entries_installed), *sm),
                                Some(commit_state)),
                            ::builtin::spec_eq(parse_journal_entries(entries_bytes),
                                Some(entries)),
                            ::builtin::is_variant(recover_journal((old(powerpm).view()).durable_state),
                                "Some"),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), entries_bytes.len())),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        num_entries_installed), entries.len())),
                            ::builtin::spec_eq(entries.spec_index(::builtin::spec_cast_integer::<_,
                                                int>(num_entries_installed)).start, write_addr),
                            ::builtin::spec_eq(entries.spec_index(::builtin::spec_cast_integer::<_,
                                                int>(num_entries_installed)).bytes_to_write,
                                (bytes_to_write.view())),
                            ::builtin::spec_eq(perm_factory.id(), old(powerpm).id()),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([powerpm.inv(),
                            ::builtin::spec_eq(powerpm.constants(),
                                old(powerpm).constants()),
                            ::builtin::spec_eq(powerpm.id(), old(powerpm).id()),
                            ::builtin::spec_eq((powerpm.view()).len(),
                                (old(powerpm).view()).len()), (powerpm.view()).valid(),
                            ::builtin::spec_eq(recover_journal((powerpm.view()).durable_state),
                                recover_journal((old(powerpm).view()).durable_state)),
                            ::builtin::spec_eq(apply_journal_entries((powerpm.view()).read_state,
                                    entries.skip((num_entries_installed).spec_add(::builtin::spec_literal_nat("1"))),
                                    *sm), Some(commit_state)),
                            seqs_match_in_range((old(powerpm).view()).durable_state,
                                (powerpm.view()).durable_state,
                                ::builtin::spec_literal_integer("0"),
                                ::builtin::spec_cast_integer::<_, int>(sm.app_area_start)),
                            seqs_match_in_range((old(powerpm).view()).read_state,
                                (powerpm.view()).read_state,
                                ::builtin::spec_literal_integer("0"),
                                ::builtin::spec_cast_integer::<_,
                                        int>(sm.app_area_start))]);

                #[verifier::proof_block]
                {
                    lemma_addresses_in_entry_dont_affect_recovery((powerpm.view()).durable_state,
                        vm, *sm, entries_bytes, entries, num_entries_installed);
                    {
                        ::builtin::assert_by(entries.spec_index(num_entries_installed).fits(*sm),
                            {
                                lemma_journal_entries_valid_implies_one_valid(entries, *sm,
                                    num_entries_installed);
                            });
                    }
                    {
                        ::builtin::assert_forall_by(|s|
                                {
                                    ::builtin::requires(can_result_from_partial_write(s,
                                            (powerpm.view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(write_addr),
                                            (bytes_to_write.view())));
                                    ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission((powerpm.view()).durable_state,
                                            s));
                                    lemma_if_addresses_unreachable_in_recovery_then_recovery_unchanged_by_write(s,
                                        (powerpm.view()).durable_state,
                                        ::builtin::spec_cast_integer::<_, int>(write_addr),
                                        (bytes_to_write.view()),
                                        entries.spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(num_entries_installed)).addrs(),
                                        ::builtin::closure_to_fn_spec(|s| recover_journal(s)));
                                    ::builtin::assert_(::builtin::spec_eq(recover_journal(s),
                                            recover_journal((powerpm.view()).durable_state)));
                                    Self::lemma_recover_doesnt_change_size((powerpm.view()).durable_state);
                                });
                    }
                }
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                powerpm.write::<PermFactory::Perm>(write_addr, bytes_to_write,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));

                #[verifier::proof_block]
                {
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_can_result_from_write_effect)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::assert_by(::builtin::spec_eq(recover_journal((powerpm.view()).durable_state),
                                recover_journal((old(powerpm).view()).durable_state)),
                            {
                                lemma_if_addresses_unreachable_in_recovery_then_recovery_unchanged_by_write((powerpm.view()).durable_state,
                                    (old(powerpm).view()).durable_state,
                                    ::builtin::spec_cast_integer::<_, int>(write_addr),
                                    (bytes_to_write.view()),
                                    entries.spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(num_entries_installed)).addrs(),
                                    ::builtin::closure_to_fn_spec(|s| recover_journal(s)));
                            });
                    }
                    ::builtin::assert_(::builtin::spec_eq(Some((powerpm.view()).read_state),
                            apply_journal_entry((old(powerpm).view()).read_state,
                                entries.spec_index(num_entries_installed), *sm)));
                    ::builtin::assert_(::builtin::spec_eq(recover_journal((powerpm.view()).durable_state),
                            recover_journal((old(powerpm).view()).durable_state)));
                    ::builtin::assert_(::builtin::spec_eq(recover_journal_length((powerpm.view()).durable_state,
                                *sm),
                            Some(::builtin::spec_cast_integer::<_,
                                        u64>(entries_bytes.len()))));
                    ::builtin::assert_(::builtin::ext_equal(entries.skip(num_entries_installed).spec_index(::builtin::spec_literal_integer("0")),
                            entries.spec_index(num_entries_installed)));
                    ::builtin::assert_(::builtin::ext_equal(entries.skip(num_entries_installed).skip(::builtin::spec_literal_integer("1")),
                            entries.skip((num_entries_installed).spec_add(::builtin::spec_literal_nat("1")))));
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn install_journal_entries_during_start<PermFactory>(powerpm:
                    &mut PoWERPersistentMemoryRegion<PM>,
                verus_tmp_perm_factory: Tracked<&PermFactory>,
                verus_tmp_vm: Ghost<JournalVersionMetadata>,
                sm: &JournalStaticMetadata, entries_bytes: &Vec<u8>,
                verus_tmp_entries: Ghost<Seq<JournalEntry>>) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                #[verus::internal(header_unwrap_parameter)]
                let vm;

                #[verifier::proof_block]
                { vm = verus_tmp_vm.view() };
                #[verus::internal(header_unwrap_parameter)]
                let entries;

                #[verifier::proof_block]
                { entries = verus_tmp_entries.view() };
                ::builtin::requires([old(powerpm).inv(),
                            (old(powerpm).view()).valid(),
                            (old(powerpm).view()).flush_predicted(),
                            ::builtin::spec_eq(recover_version_metadata((old(powerpm).view()).read_state),
                                Some(vm)),
                            ::builtin::spec_eq(recover_static_metadata((old(powerpm).view()).read_state,
                                    vm), Some(*sm)),
                            ::builtin::spec_eq(recover_committed_cdb((old(powerpm).view()).read_state,
                                    *sm), Some(true)),
                            ::builtin::spec_eq(recover_journal_length((old(powerpm).view()).read_state,
                                    *sm),
                                Some(::builtin::spec_cast_integer::<_,
                                            u64>(entries_bytes.len()))),
                            ::builtin::spec_eq(recover_journal_entries_bytes((old(powerpm).view()).read_state,
                                    *sm,
                                    ::builtin::spec_cast_integer::<_,
                                            u64>(entries_bytes.len())), Some((entries_bytes.view()))),
                            ::builtin::spec_eq(parse_journal_entries((entries_bytes.view())),
                                Some(entries)),
                            ::builtin::is_variant(apply_journal_entries((old(powerpm).view()).read_state,
                                    entries, *sm), "Some"),
                            ::builtin::is_variant(recover_journal((old(powerpm).view()).read_state),
                                "Some"),
                            ::builtin::spec_eq(perm_factory.id(), old(powerpm).id()),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([powerpm.inv(),
                            ::builtin::spec_eq(powerpm.constants(),
                                old(powerpm).constants()),
                            ::builtin::spec_eq(powerpm.id(), old(powerpm).id()),
                            ::builtin::spec_eq((powerpm.view()).len(),
                                (old(powerpm).view()).len()),
                            (powerpm.view()).flush_predicted(),
                            ::builtin::spec_eq(recover_version_metadata((powerpm.view()).read_state),
                                Some(vm)),
                            ::builtin::spec_eq(recover_static_metadata((powerpm.view()).read_state,
                                    vm), Some(*sm)),
                            ::builtin::spec_eq(recover_committed_cdb((powerpm.view()).read_state,
                                    *sm), Some(true)),
                            ::builtin::spec_eq(recover_journal_length((powerpm.view()).read_state,
                                    *sm),
                                Some(::builtin::spec_cast_integer::<_,
                                            u64>(entries_bytes.len()))),
                            ::builtin::spec_eq(recover_journal_entries_bytes((powerpm.view()).read_state,
                                    *sm,
                                    ::builtin::spec_cast_integer::<_,
                                            u64>(entries_bytes.len())), Some((entries_bytes.view()))),
                            ::builtin::spec_eq(apply_journal_entries((powerpm.view()).durable_state,
                                    entries, *sm), Some((powerpm.view()).read_state)),
                            ::builtin::spec_eq(apply_journal_entries((old(powerpm).view()).read_state,
                                    entries, *sm), Some((powerpm.view()).read_state)),
                            ::builtin::spec_eq(recover_journal((powerpm.view()).durable_state),
                                recover_journal((old(powerpm).view()).durable_state))]);
                let mut start: usize = 0;
                let end: usize = entries_bytes.len();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = ::builtin::spec_literal_integer("0") };
                #[verus::internal(spec)]
                let mut num_entries_installed;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let mut verus_tmp_num_entries_installed: int = verus_tmp;
                    num_entries_installed = verus_tmp_num_entries_installed;
                };
                let u64_size: usize = size_of::<u64>();
                let twice_u64_size: usize = u64_size + u64_size;
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        apply_journal_entries((powerpm.view()).read_state, entries,
                                *sm).unwrap()
                };
                #[verus::internal(spec)]
                let mut commit_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_commit_state = verus_tmp;
                    commit_state = verus_tmp_commit_state;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal(entries.skip(::builtin::spec_literal_integer("0")),
                                    entries))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((entries_bytes.view()).skip(::builtin::spec_literal_integer("0")),
                                    (entries_bytes.view())))
                        };
                };

                #[verifier::proof_block]
                {
                    lemma_apply_journal_entries_some_iff_journal_entries_valid((old(powerpm).view()).read_state,
                        entries, *sm);
                }
                while start < end {
                    ::builtin::invariant([powerpm.inv(),
                                ::builtin::spec_eq(powerpm.constants(),
                                    old(powerpm).constants()),
                                ::builtin::spec_eq(powerpm.id(), old(powerpm).id()),
                                (powerpm.view()).valid(),
                                ::builtin::spec_eq((powerpm.view()).len(),
                                    (old(powerpm).view()).len()),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_eq(::builtin::spec_chained_le(::builtin::spec_chained_value(start),
                                            end), entries_bytes.len())),
                                ::builtin::spec_eq(u64_size, u64::spec_size_of()),
                                ::builtin::spec_eq(twice_u64_size,
                                    (u64_size).spec_add(u64_size)),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            num_entries_installed), entries.len())),
                                (::builtin::spec_eq(num_entries_installed, entries.len()))
                                    == (::builtin::spec_eq(start, end)),
                                ::builtin::spec_eq((old(powerpm).view()).read_state,
                                    (old(powerpm).view()).durable_state),
                                ::builtin::spec_eq(recover_version_metadata((old(powerpm).view()).read_state),
                                    Some(vm)),
                                ::builtin::spec_eq(recover_static_metadata((old(powerpm).view()).read_state,
                                        vm), Some(*sm)),
                                ::builtin::spec_eq(recover_committed_cdb((old(powerpm).view()).read_state,
                                        *sm), Some(true)),
                                ::builtin::spec_eq(recover_journal_length((old(powerpm).view()).read_state,
                                        *sm),
                                    Some(::builtin::spec_cast_integer::<_,
                                                u64>(entries_bytes.len()))),
                                ::builtin::spec_eq(recover_journal_entries_bytes((old(powerpm).view()).read_state,
                                        *sm,
                                        ::builtin::spec_cast_integer::<_,
                                                u64>(entries_bytes.len())), Some((entries_bytes.view()))),
                                ::builtin::spec_eq(parse_journal_entries((entries_bytes.view())),
                                    Some(entries)), journal_entries_valid(entries, *sm),
                                ::builtin::is_variant(apply_journal_entries((old(powerpm).view()).read_state,
                                        entries, *sm), "Some"),
                                ::builtin::is_variant(recover_journal((old(powerpm).view()).read_state),
                                    "Some"),
                                ::builtin::spec_eq(recover_version_metadata((powerpm.view()).durable_state),
                                    Some(vm)),
                                ::builtin::spec_eq(recover_static_metadata((powerpm.view()).durable_state,
                                        vm), Some(*sm)),
                                ::builtin::spec_eq(recover_committed_cdb((powerpm.view()).durable_state,
                                        *sm), Some(true)),
                                ::builtin::spec_eq(recover_journal_length((powerpm.view()).durable_state,
                                        *sm),
                                    Some(::builtin::spec_cast_integer::<_,
                                                u64>(entries_bytes.len()))),
                                ::builtin::spec_eq(recover_journal_entries_bytes((powerpm.view()).durable_state,
                                        *sm,
                                        ::builtin::spec_cast_integer::<_,
                                                u64>(entries_bytes.len())), Some((entries_bytes.view()))),
                                ::builtin::spec_eq(recover_journal((powerpm.view()).durable_state),
                                    recover_journal((old(powerpm).view()).durable_state)),
                                ::builtin::spec_eq(perm_factory.id(), powerpm.id()),
                                ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                        ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                            #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                s2))),
                                ::builtin::spec_eq(parse_journal_entries((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                    int>(start))), Some(entries.skip(num_entries_installed))),
                                seqs_match_in_range((old(powerpm).view()).durable_state,
                                    (powerpm.view()).durable_state,
                                    ::builtin::spec_literal_integer("0"),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start)),
                                seqs_match_in_range((old(powerpm).view()).read_state,
                                    (powerpm.view()).read_state,
                                    ::builtin::spec_literal_integer("0"),
                                    ::builtin::spec_cast_integer::<_, int>(sm.app_area_start)),
                                ::builtin::spec_eq(apply_journal_entries((powerpm.view()).read_state,
                                        entries.skip(num_entries_installed), *sm),
                                    Some(commit_state))]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (powerpm.view()).durable_state };
                    #[verus::internal(spec)]
                    let mut durable_state_at_start_of_loop;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_state_at_start_of_loop = verus_tmp;
                        durable_state_at_start_of_loop =
                            verus_tmp_durable_state_at_start_of_loop;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(((start).spec_add(twice_u64_size)).spec_le(end))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::is_variant(parse_journal_entry((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                        int>(start))), "Some"))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(parse_journal_entry((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                                int>(start))).unwrap().0,
                                        entries.spec_index(num_entries_installed)))
                            };
                    };
                    let entries_bytes_slice = entries_bytes.as_slice();
                    let addr =
                        u64_from_le_bytes(slice_subrange(entries_bytes_slice, start,
                                start + u64_size));
                    let len =
                        u64_from_le_bytes(slice_subrange(entries_bytes_slice,
                                start + u64_size, start + twice_u64_size));

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((entries_bytes_slice.view()).subrange(::builtin::spec_cast_integer::<_,
                                                    int>(start),
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(((start).spec_add(u64_size)))),
                                        extract_section((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                        int>(start)), ::builtin::spec_literal_integer("0"),
                                            u64::spec_size_of())))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(addr,
                                        u64::spec_from_bytes(extract_section((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                            int>(start)), ::builtin::spec_literal_integer("0"),
                                                u64::spec_size_of()))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((entries_bytes_slice.view()).subrange(::builtin::spec_cast_integer::<_,
                                                    int>(((start).spec_add(u64_size))),
                                            ::builtin::spec_cast_integer::<_,
                                                    int>((((start).spec_add(u64_size)).spec_add(u64_size)))),
                                        extract_section((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                        int>(start)),
                                            ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()),
                                            u64::spec_size_of())))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(len,
                                        u64::spec_from_bytes(extract_section((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                            int>(start)),
                                                ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()),
                                                u64::spec_size_of()))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_((((start).spec_add(twice_u64_size)).spec_add(::builtin::spec_cast_integer::<_,
                                                        usize>(len))).spec_le(end))
                            };
                    };
                    let bytes_to_write =
                        slice_subrange(entries_bytes_slice, start + twice_u64_size,
                            start + twice_u64_size + len as usize);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((bytes_to_write.view()),
                                        extract_section((entries_bytes.view()).skip(::builtin::spec_cast_integer::<_,
                                                        int>(start)),
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(((u64::spec_size_of()).spec_add(u64::spec_size_of()))),
                                            ::builtin::spec_cast_integer::<_, nat>(len))))
                            };
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            JournalEntry {
                                start: ::builtin::spec_cast_integer::<_, int>(addr),
                                bytes_to_write: (bytes_to_write.view()),
                            }
                    };
                    #[verus::internal(spec)]
                    let mut entry;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_entry = verus_tmp;
                        entry = verus_tmp_entry;
                    };

                    #[verifier::proof_block]
                    {
                        lemma_parse_journal_entry_implications((entries_bytes.view()),
                            entries, ::builtin::spec_cast_integer::<_, int>(start),
                            num_entries_installed);
                        ::builtin::assert_(::builtin::spec_eq(entries.spec_index(::builtin::spec_cast_integer::<_,
                                            int>(num_entries_installed)), entry));
                    }
                    Self::install_journal_entry_during_start::<PermFactory>(powerpm,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] &perm_factory),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] vm),
                        sm, start, addr, bytes_to_write,
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (entries_bytes.view())),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] num_entries_installed),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] entries),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] commit_state));

                    #[verifier::proof_block]
                    {
                        ::builtin::assert_(::builtin::ext_equal(entries.skip(num_entries_installed),
                                (::vstd::vstd::seq::Seq::empty().push(entries.spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(num_entries_installed)))).spec_add(entries.skip((num_entries_installed).spec_add(::builtin::spec_literal_nat("1"))))));
                        num_entries_installed =
                            (num_entries_installed).spec_add(::builtin::spec_literal_nat("1"));
                    }
                    start += twice_u64_size + len as usize;
                }
                powerpm.flush();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub(super) fn clear_log<PermFactory>(powerpm:
                    &mut PoWERPersistentMemoryRegion<PM>,
                verus_tmp_perm_factory: Tracked<&PermFactory>,
                verus_tmp_vm: Ghost<JournalVersionMetadata>,
                sm: &JournalStaticMetadata) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                #[verus::internal(header_unwrap_parameter)]
                let vm;

                #[verifier::proof_block]
                { vm = verus_tmp_vm.view() };
                ::builtin::requires([old(powerpm).inv(),
                            (old(powerpm).view()).valid(),
                            (old(powerpm).view()).flush_predicted(),
                            ::builtin::spec_eq(recover_version_metadata((old(powerpm).view()).read_state),
                                Some(vm)),
                            ::builtin::spec_eq(recover_static_metadata((old(powerpm).view()).read_state,
                                    vm), Some(*sm)),
                            ::builtin::spec_eq(recover_committed_cdb((old(powerpm).view()).read_state,
                                    *sm), Some(true)),
                            ({
                                    ((if let Some(j) =
                                                        (recover_journal((old(powerpm).view()).read_state)) {
                                                    ::builtin::spec_eq(j.state,
                                                        (old(powerpm).view()).read_state)
                                                } else { false }))
                                }),
                            ::builtin::spec_eq(perm_factory.id(), old(powerpm).id()),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(spec_recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([powerpm.inv(),
                            ::builtin::spec_eq(powerpm.constants(),
                                old(powerpm).constants()),
                            ::builtin::spec_eq(powerpm.id(), old(powerpm).id()),
                            ::builtin::spec_eq((powerpm.view()).len(),
                                (old(powerpm).view()).len()),
                            (powerpm.view()).flush_predicted(),
                            ::builtin::spec_eq(recover_version_metadata((powerpm.view()).read_state),
                                Some(vm)),
                            ::builtin::spec_eq(recover_static_metadata((powerpm.view()).read_state,
                                    vm), Some(*sm)),
                            ::builtin::spec_eq(recover_committed_cdb((powerpm.view()).read_state,
                                    *sm), Some(false)),
                            spec_recovery_equivalent_for_app((powerpm.view()).durable_state,
                                (old(powerpm).view()).durable_state)]);
                let new_cdb: u64 = CDB_FALSE;
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        update_bytes((powerpm.view()).durable_state,
                            ::builtin::spec_cast_integer::<_,
                                    int>(sm.committed_cdb_start), new_cdb.spec_to_bytes())
                };
                #[verus::internal(spec)]
                let mut new_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_state = verus_tmp;
                    new_state = verus_tmp_new_state;
                };

                #[verifier::proof_block]
                {
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(::builtin::spec_eq((::builtin::spec_cast_integer::<_,
                                            int>(sm.committed_cdb_start)).spec_euclidean_mod(const_persistence_chunk_size()),
                            ::builtin::spec_literal_nat("0")));
                    ::builtin::assert_(::builtin::spec_eq(new_cdb.spec_to_bytes().len(),
                            const_persistence_chunk_size()));
                    ::builtin::assert_(spec_recovery_equivalent_for_app((powerpm.view()).durable_state,
                            (powerpm.view()).durable_state));
                    ::builtin::assert_(perm_factory.check_permission((powerpm.view()).durable_state,
                            (powerpm.view()).durable_state));
                    ::builtin::assert_(::builtin::spec_eq(recover_version_metadata(new_state),
                            Some(vm)));
                    ::builtin::assert_(::builtin::spec_eq(recover_static_metadata(new_state,
                                vm), Some(*sm)));
                    ::builtin::assert_(::builtin::spec_eq(recover_committed_cdb(new_state,
                                *sm), Some(false)));
                    ::builtin::assert_(spec_recovery_equivalent_for_app(new_state,
                            (old(powerpm).view()).durable_state));
                    lemma_auto_only_two_crash_states_introduced_by_aligned_chunk_write();
                }
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.grant_permission() };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                powerpm.serialize_and_write::<PermFactory::Perm,
                    u64>(sm.committed_cdb_start, &new_cdb,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                powerpm.flush();

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq((powerpm.view()).read_state,
                                    new_state))
                        };
                };
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn start<PermFactory>(powerpm:
                    PoWERPersistentMemoryRegion<PM>,
                verus_tmp_perm_factory: Tracked<PermFactory>)
                -> Result<Self, JournalError> where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([powerpm.inv(),
                            Self::recover((powerpm.view()).durable_state).is_some(),
                            ::builtin::spec_eq(perm_factory.id(), powerpm.id()),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(Self::recovery_equivalent_for_app(s1, s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures(|result: Result<Self, JournalError>|
                        [match result {
                                    Ok(j) => {
                                        ((((((((((j.valid()) && (j.recover_idempotent())) &&
                                                                                                            ((j.view()).valid())) &&
                                                                                                    (::builtin::spec_eq((j.view()).constants,
                                                                                                            Self::recover((powerpm.view()).durable_state).unwrap().constants)))
                                                                                            &&
                                                                                            (::builtin::spec_eq((j.view()).pm_constants,
                                                                                                    powerpm.constants()))) &&
                                                                                    (::builtin::spec_eq((j.view()).remaining_capacity,
                                                                                            (j.view()).constants.journal_capacity))) &&
                                                                            (::builtin::spec_eq((j.view()).journaled_addrs,
                                                                                    Set::<int>::empty()))) &&
                                                                    (::builtin::spec_eq((j.view()).durable_state,
                                                                            (j.view()).read_state))) &&
                                                            (::builtin::spec_eq((j.view()).read_state,
                                                                    (j.view()).commit_state))) &&
                                                    (::builtin::spec_eq((j.view()).powerpm_id, powerpm.id())))
                                            &&
                                            (Self::recovery_equivalent_for_app((j.view()).durable_state,
                                                    (powerpm.view()).durable_state))
                                    }
                                    Err(JournalError::CRCError) =>
                                        !powerpm.constants().impervious_to_corruption(),
                                    _ => false,
                                }]);
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (powerpm.view()).durable_state };
                #[verus::internal(spec)]
                let mut old_durable_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_old_durable_state = verus_tmp;
                    old_durable_state = verus_tmp_old_durable_state;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(powerpm.constants().valid(),
                                    { powerpm.lemma_inv_implies_view_valid(); });
                            }
                        };
                }
                let mut powerpm = powerpm;
                powerpm.flush();
                let pm = powerpm.get_pm_region_ref();
                let pm_size = pm.get_region_size();
                let vm =
                    Self::read_version_metadata(pm).ok_or(JournalError::CRCError)?;
                let sm =
                    Self::read_static_metadata(pm,
                                &vm).ok_or(JournalError::CRCError)?;
                let cdb =
                    Self::read_committed_cdb(pm, &vm,
                                &sm).ok_or(JournalError::CRCError)?;
                let constants =
                    JournalConstants {
                        app_version_number: sm.app_version_number,
                        app_program_guid: sm.app_program_guid,
                        journal_capacity: sm.journal_entries_end -
                            sm.journal_entries_start,
                        app_area_start: sm.app_area_start,
                        app_area_end: sm.app_area_end,
                    };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(Self::recover((powerpm.view()).durable_state).unwrap().constants.app_area_end,
                                    (powerpm.view()).len()))
                        };
                };
                if cdb {
                        let journal_length =
                            Self::read_journal_length(pm,
                                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] vm),
                                        &sm).ok_or(JournalError::CRCError)?;
                        let entries_bytes =
                            Self::read_journal_entries_bytes(pm,
                                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] vm),
                                        &sm, journal_length).ok_or(JournalError::CRCError)?;
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        {
                            verus_tmp =
                                parse_journal_entries((entries_bytes.view())).unwrap()
                        };
                        #[verus::internal(spec)]
                        let mut entries;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_entries = verus_tmp;
                            entries = verus_tmp_entries;
                        };
                        Self::install_journal_entries_during_start::<PermFactory>(&mut powerpm,
                            #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] &perm_factory),
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] vm),
                            &sm, &entries_bytes,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] entries));

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    {
                                        ::builtin::assert_forall_by(|s1: Seq<u8>, s2: Seq<u8>|
                                                {
                                                    ::builtin::requires(spec_recovery_equivalent_for_app(s1,
                                                            s2));
                                                    ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                            s2));
                                                    Self::lemma_recover_doesnt_change_size(s1);
                                                });
                                    }
                                };
                        }
                        Self::clear_log::<PermFactory>(&mut powerpm,
                            #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] &perm_factory),
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] vm),
                            &sm);
                    }
                let j =
                    Self {
                        powerpm,
                        vm: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] vm),
                        sm,
                        status: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] JournalStatus::Quiescent),
                        constants: constants.clone(),
                        journal_length: 0,
                        journaled_addrs: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] Set::<int>::empty()),
                        entries: ConcreteJournalEntries::new(),
                    };
                Ok(j)
            }
        }
    }
    mod write_v {
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::subrange_v::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::power_t::*;
        use super::entry_v::*;
        use super::impl_v::*;
        use super::spec_v::*;
        #[verus::internal(verus_macro)]
        impl<PM> Journal<PM> where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn write_preconditions<Perm>(self, addr: u64,
                bytes_to_write: Seq<u8>, perm: Perm) -> bool where
                Perm: CheckPermission<Seq<u8>> {
                (((((self.valid()) &&
                                                    (((self.view()).constants.app_area_start).spec_le(addr))) &&
                                            (((addr).spec_add(bytes_to_write.len())).spec_le((self.view()).constants.app_area_end)))
                                    &&
                                    (::builtin::spec_eq(perm.id(), (self.view()).powerpm_id)))
                            &&
                            (::builtin::forall(|s: Seq<u8>|
                                        ::builtin::imply({
                                                (seqs_match_except_in_range((self.view()).durable_state, s,
                                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                                            (addr).spec_add(bytes_to_write.len()))) &&
                                                    (((if let Some(j) = (Self::recover(s)) {
                                                                        (::builtin::spec_eq(j.constants, (self.view()).constants))
                                                                            && (::builtin::spec_eq(j.state, s))
                                                                    } else { false })))
                                            },
                                            #[verus::internal(trigger)] perm.check_permission((self.view()).durable_state,
                                                s))))) &&
                    (::builtin::forall(|i: int|
                                ::builtin::with_triggers((((self.view()).journaled_addrs.contains(i),),),
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(addr),
                                                    i), (addr).spec_add(bytes_to_write.len()))),
                                        !(self.view()).journaled_addrs.contains(i)))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn write_postconditions(self, old_self: Self, addr: u64,
                bytes_to_write: Seq<u8>) -> bool {
                (((((self.valid()) && ((self.view()).valid())) &&
                                            (self.recover_idempotent())) &&
                                    (::builtin::spec_eq((self.view()),
                                            (JournalView {
                                                    read_state: update_bytes((old_self.view()).read_state,
                                                        ::builtin::spec_cast_integer::<_, int>(addr),
                                                        bytes_to_write),
                                                    commit_state: update_bytes((old_self.view()).commit_state,
                                                        ::builtin::spec_cast_integer::<_, int>(addr),
                                                        bytes_to_write),
                                                    durable_state: (self.view()).durable_state,
                                                    ..(old_self.view())
                                                })))) &&
                            ((self.view()).matches_except_in_range((old_self.view()),
                                    ::builtin::spec_cast_integer::<_, int>(addr),
                                    (addr).spec_add(bytes_to_write.len())))) &&
                    (seqs_match_except_in_range((old_self.view()).durable_state,
                            (self.view()).durable_state,
                            ::builtin::spec_cast_integer::<_, int>(addr),
                            (addr).spec_add(bytes_to_write.len())))
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn write_slice<Perm>(&mut self, addr: u64,
                bytes_to_write: &[u8], verus_tmp_perm: Tracked<Perm>) where
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).write_preconditions(addr,
                                (bytes_to_write.view()), perm)]);
                ::builtin::ensures([self.write_postconditions(*old(self),
                                addr, (bytes_to_write.view()))]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_update_bytes_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_can_result_from_write_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verifier::proof_block]
                {
                    {
                        ::builtin::assert_forall_by(|s|
                                {
                                    ::builtin::requires(can_result_from_partial_write(s,
                                            (self.powerpm.view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            (bytes_to_write.view())));
                                    ::builtin::ensures(#[verus::internal(trigger)] perm.check_permission((self.powerpm.view()).durable_state,
                                            s));
                                    ::builtin::assert_(seqs_match_except_in_range(s,
                                            (self.powerpm.view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            (addr).spec_add((bytes_to_write.view()).len())));
                                });
                    }
                }
                self.powerpm.write::<Perm>(addr, bytes_to_write,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by({
                                        (::builtin::spec_eq(apply_journal_entries((self.powerpm.view()).read_state,
                                                        (self.entries.view()), self.sm),
                                                    Some((self.view()).commit_state))) &&
                                            (::builtin::spec_eq((self.view()).commit_state,
                                                    update_bytes((old(self).view()).commit_state,
                                                        ::builtin::spec_cast_integer::<_, int>(addr),
                                                        (bytes_to_write.view()))))
                                    },
                                    {
                                        lemma_apply_journal_entries_some_iff_journal_entries_valid((old(self).powerpm.view()).read_state,
                                            (self.entries.view()), self.sm);
                                        {
                                            ::builtin::assert_forall_by(|i: int|
                                                    {
                                                        ::builtin::requires(::builtin::with_triggers((((self.journaled_addrs.view()).contains(i),),),
                                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(addr),
                                                                            i), (addr).spec_add((bytes_to_write.view()).len())))));
                                                        ::builtin::ensures(!(self.journaled_addrs.view()).contains(i));
                                                        ::builtin::assert_(((self.journaled_addrs.view()).contains(i))
                                                                == ((old(self).view()).journaled_addrs.contains(i)));
                                                    });
                                        }
                                        lemma_apply_journal_entries_commutes_with_update_bytes((old(self).powerpm.view()).read_state,
                                            (self.entries.view()), (self.journaled_addrs.view()),
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            (bytes_to_write.view()), self.sm);
                                    });
                            }
                        };
                }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn write_vec<Perm>(&mut self, addr: u64,
                bytes_to_write: Vec<u8>, verus_tmp_perm: Tracked<Perm>) where
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).write_preconditions(addr,
                                (bytes_to_write.view()), perm)]);
                ::builtin::ensures([self.write_postconditions(*old(self),
                                addr, (bytes_to_write.view()))]);
                self.write_slice::<Perm>(addr, bytes_to_write.as_slice(),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn write_object<S,
                Perm>(&mut self, addr: u64, object: &S,
                verus_tmp_perm: Tracked<Perm>) where S: PmCopy,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).write_preconditions(addr,
                                object.spec_to_bytes(), perm)]);
                ::builtin::ensures([self.write_postconditions(*old(self),
                                addr, object.spec_to_bytes())]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                self.write_slice::<Perm>(addr, object.as_byte_slice(),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn journal_write(&mut self, addr: u64,
                bytes_to_write: Vec<u8>) -> Result<(), JournalError> {
                ::builtin::requires([old(self).valid(),
                            ((old(self).view()).constants.app_area_start).spec_le(addr),
                            ((addr).spec_add(bytes_to_write.len())).spec_le((old(self).view()).constants.app_area_end)]);
                ::builtin::ensures(|result: Result<(), JournalError>|
                        [self.valid(), (self.view()).valid(),
                                self.recover_idempotent(),
                                ({
                                        let space_needed =
                                            (spec_journal_entry_overhead()).spec_add((bytes_to_write.view()).len());
                                        match result {
                                            Ok(_) => {
                                                (((space_needed).spec_le((old(self).view()).remaining_capacity))
                                                            &&
                                                            (::builtin::spec_eq((self.view()),
                                                                    (JournalView {
                                                                            commit_state: update_bytes((old(self).view()).commit_state,
                                                                                ::builtin::spec_cast_integer::<_, int>(addr),
                                                                                (bytes_to_write.view())),
                                                                            journaled_addrs: ((old(self).view()).journaled_addrs).spec_add(Set::<int>::new(::builtin::closure_to_fn_spec(|i:
                                                                                                int|
                                                                                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(addr),
                                                                                                        i), (addr).spec_add(bytes_to_write.len())))))),
                                                                            remaining_capacity: ((old(self).view()).remaining_capacity).spec_sub(space_needed),
                                                                            ..(old(self).view())
                                                                        })))) &&
                                                    ((self.view()).matches_except_in_range((old(self).view()),
                                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                                            (addr).spec_add(bytes_to_write.len())))
                                            }
                                            Err(JournalError::NotEnoughSpace) => {
                                                ((space_needed).spec_gt((old(self).view()).remaining_capacity))
                                                    && (::builtin::spec_eq(self, old(self)))
                                            }
                                            Err(_) => false,
                                        }
                                    })]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_update_bytes_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                let overhead = Self::journal_entry_overhead();
                if self.sm.journal_entries_end - self.sm.journal_entries_start
                                - self.journal_length < overhead {
                        return Err(JournalError::NotEnoughSpace);
                    }
                if bytes_to_write.len() as u64 >
                            self.sm.journal_entries_end - self.sm.journal_entries_start
                                    - self.journal_length - overhead {
                        return Err(JournalError::NotEnoughSpace);
                    }
                self.journal_length =
                    self.journal_length + overhead +
                        bytes_to_write.len() as u64;
                self.journaled_addrs =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.journaled_addrs.view())).spec_add(Set::<int>::new(::builtin::closure_to_fn_spec(|i:
                                            int|
                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(addr),
                                                    i), (addr).spec_add(bytes_to_write.len())))))));
                let concrete_entry =
                    ConcreteJournalEntry::new(addr, bytes_to_write);
                self.entries.push(concrete_entry);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by({
                                        (::builtin::spec_eq(apply_journal_entries((self.powerpm.view()).read_state,
                                                        (self.entries.view()), self.sm),
                                                    Some((self.view()).commit_state))) &&
                                            (::builtin::spec_eq((self.view()).commit_state,
                                                    update_bytes((old(self).view()).commit_state,
                                                        ::builtin::spec_cast_integer::<_, int>(addr),
                                                        (bytes_to_write.view()))))
                                    },
                                    {
                                        lemma_apply_journal_entries_some_iff_journal_entries_valid((old(self).powerpm.view()).read_state,
                                            (old(self).entries.view()), self.sm);
                                        lemma_effect_of_append_on_apply_journal_entries((old(self).powerpm.view()).read_state,
                                            (old(self).entries.view()), (concrete_entry.view()),
                                            self.sm);
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(journaled_addrs_complete((self.entries.view()),
                                        (self.journaled_addrs.view())),
                                    {
                                        {
                                            ::builtin::assert_forall_by(|entry, addr|
                                                    {
                                                        ::builtin::requires(::builtin::with_triggers((((self.entries.view()).contains(entry),
                                                                        (self.journaled_addrs.view()).contains(addr)),),
                                                                (self.entries.view()).contains(entry) &&
                                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(entry.start),
                                                                                addr), entry.end()))));
                                                        ::builtin::ensures((self.journaled_addrs.view()).contains(addr));
                                                        if !(old(self).entries.view()).contains(entry) {
                                                                ::builtin::assert_(::builtin::spec_eq(entry,
                                                                        (concrete_entry.view())));
                                                            }
                                                    });
                                        }
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(space_needed_for_journal_entries_list((self.entries.view())),
                                        (space_needed_for_journal_entries_list((old(self).entries.view()))).spec_add((concrete_entry.view()).space_needed())),
                                    {
                                        ::builtin::assert_(::builtin::spec_eq((self.entries.view()).last(),
                                                (concrete_entry.view())));
                                        ::builtin::assert_(::builtin::ext_equal((self.entries.view()).drop_last(),
                                                (old(self).entries.view())));
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {
                    lemma_apply_journal_entries_some_iff_journal_entries_valid((self.powerpm.view()).read_state,
                        (self.entries.view()), self.sm);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                Ok(())
            }
        }
    }
    #[cfg(verus_keep_ghost)]
    pub use spec_v::{
        broadcast_journal_view_matches_in_range_can_narrow_range,
        broadcast_journal_view_matches_in_range_transitive,
    };
    pub use spec_v::{
        JournalConstants, JournalError, JournalView, RecoveredJournal,
    };
    pub use impl_v::Journal;
    #[cfg(verus_keep_ghost)]
    pub use impl_v::spec_journal_entry_overhead;
}
pub mod kv2 {
    #![allow(unused_imports)]
    pub mod abort_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn abort(&mut self) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) =>
                                        ::builtin::spec_eq((self.view()),
                                            (old(self).view()).abort()),
                                    Err(_) => false,
                                }]);
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                    old(self).perm_factory))
                        };
                };
                self.internal_abort();
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub(super) fn internal_abort(&mut self) {
                ::builtin::requires([old(self).inv(),
                            ::builtin::is_variant((old(self).status.view()),
                                "MustAbort")]);
                ::builtin::ensures([self.valid(),
                            ::builtin::spec_eq((self.view()),
                                (old(self).view()).abort()),
                            ::builtin::spec_eq((self.journal.view()).durable_state,
                                (self.journal.view()).read_state)]);
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (self.journal.view()) };
                #[verus::internal(spec)]
                let mut jv_before_abort;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_jv_before_abort = verus_tmp;
                    jv_before_abort = verus_tmp_jv_before_abort;
                };
                self.journal.abort();
                self.journal.flush();
                self.keys.abort(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_abort),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())));
                self.items.abort(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_abort),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())));
                self.lists.abort(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_abort),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())));
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.view()).durable.num_keys());
                self.used_list_element_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.view()).durable.num_list_elements());
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0"));
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);

                #[verifier::proof_block]
                { self.lemma_used_slots_correspond(); }
            }
        }
    }
    pub mod commit_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::subrange_v::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::recover_v::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn commit<Perm>(&mut self, verus_tmp_perm: Tracked<Perm>)
                -> Result<(), KvError> where Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).valid(),
                            ::builtin::spec_eq(perm.id(),
                                (old(self).view()).powerpm_id),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply({
                                            (::builtin::spec_eq(Self::recover(s1),
                                                        Some(RecoveredKvStore::<K, I,
                                                                L> {
                                                                ps: (old(self).view()).ps,
                                                                kv: (old(self).view()).durable,
                                                            }))) &&
                                                (::builtin::spec_eq(Self::recover(s2),
                                                        Some(RecoveredKvStore::<K, I,
                                                                L> {
                                                                ps: (old(self).view()).ps,
                                                                kv: (old(self).view()).tentative,
                                                            })))
                                        },
                                        #[verus::internal(trigger)] perm.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) =>
                                        ::builtin::spec_eq((self.view()),
                                            (old(self).view()).commit()),
                                    Err(_) => false,
                                }]);
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (self.journal.view()) };
                #[verus::internal(spec)]
                let mut jv_before_commit;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_jv_before_commit = verus_tmp;
                    jv_before_commit = verus_tmp_jv_before_commit;
                };

                #[verifier::proof_block]
                {
                    Self::lemma_establish_recovery_equivalent_for_app((self.perm_factory.view()));
                    self.lemma_establish_recovery_equivalent_for_app_on_commit(perm);
                }
                self.journal.commit::<PermFactory,
                    Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));

                #[verifier::proof_block]
                {
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    lemma_recover_static_metadata_depends_only_on_its_area::<K,
                            I,
                            L>((old(self).journal.view()).durable_state,
                        (self.journal.view()).commit_state,
                        jv_before_commit.constants);
                }
                self.keys.commit(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_commit),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())));
                self.items.commit(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_commit),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())));
                self.lists.commit(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_commit),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())));
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.view()).durable.num_keys());
                self.used_list_element_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.view()).durable.num_list_elements());
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0"));

                #[verifier::proof_block]
                { self.lemma_used_slots_correspond(); }
                Ok(())
            }
        }
    }
    pub mod concurrentspec_t {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::traits_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::spec_t::*;
        use vstd::pcm::frac::*;
        #[verifier::reject_recursive_types(K)]
        #[verus::internal(verus_macro)]
        pub struct ConcurrentKvStoreView<K, I, L> {
            pub ps: SetupParameters,
            pub pm_constants: PersistentMemoryConstants,
            pub kv: AtomicKvStore<K, I, L>,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> ConcurrentKvStoreView<K, I, L> where K: Hash + PmCopy +
            Sized + std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug,
            L: PmCopy + LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                ::builtin::spec_eq(self.ps.logical_range_gaps_policy,
                    self.kv.logical_range_gaps_policy)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn from_kvstore_view(v: KvStoreView<K, I, L>) -> Self {
                Self { ps: v.ps, pm_constants: v.pm_constants, kv: v.durable }
            }
        }
        #[verus::internal(verus_macro)]
        pub trait ReadOnlyOperation<K, I, L>: Sized {
            type ExecResult;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn result_valid(self, ckv: ConcurrentKvStoreView<K, I, L>,
            result: Self::ExecResult)
            -> bool;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__result_valid(self,
                ckv: ConcurrentKvStoreView<K, I, L>, result: Self::ExecResult)
                -> bool {
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub trait ReadLinearizer<K, I, L,
            Op: ReadOnlyOperation<K, I, L>>: Sized {
            type Completion;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn namespaces(self)
            -> Set<int>;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn pre(self, id: int, op: Op)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn post(self, apply: Self::Completion, id: int, op: Op,
            result: Op::ExecResult)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self, op: Op,
            result: Op::ExecResult,
            #[verus::internal(proof)] r:
                &GhostVarAuth<ConcurrentKvStoreView<K, I, L>>)
            -> Self::Completion;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__namespaces(self) -> Set<int> {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__pre(self, id: int, op: Op) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__post(self, apply: Self::Completion, id: int,
                op: Op, result: Op::ExecResult) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn VERUS_SPEC__apply(#[verus::internal(proof)] self, op: Op,
                result: Op::ExecResult,
                #[verus::internal(proof)] r:
                    &GhostVarAuth<ConcurrentKvStoreView<K, I, L>>)
                -> Self::Completion {
                ::builtin::requires([self.pre(r.id(), op),
                            op.result_valid((r.view()), result)]);
                ::builtin::ensures(|complete: Self::Completion|
                        [self.post(complete, r.id(), op, result)]);
                ::builtin::opens_invariants_set(self.namespaces());
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub trait MutatingOperation<K, I, L>: Sized {
            type ExecResult;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
            new_ckv: ConcurrentKvStoreView<K, I, L>, result: Self::ExecResult)
            -> bool;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__result_valid(self,
                old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub trait CanRecover<K, I, L> {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn recover(s: Seq<u8>)
            -> Option<RecoveredKvStore<K, I, L>>;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__recover(s: Seq<u8>)
                -> Option<RecoveredKvStore<K, I, L>> {
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn grants_permission_to_mutate<Perm, K, I, L, Op,
            Kv>(perm: Perm, op: Op, pm_constants: PersistentMemoryConstants)
            -> bool where Perm: CheckPermission<Seq<u8>>,
            Op: MutatingOperation<K, I, L>, Kv: CanRecover<K, I, L> {
            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                    ::builtin::imply({
                            ((if let Some(old_rkv) = (Kv::recover(s1)) {
                                            ((if let Some(new_rkv) = (Kv::recover(s2)) {
                                                            ::builtin::exists(|result|
                                                                    {

                                                                        #[verus::internal(trigger)]
                                                                        op.result_valid(ConcurrentKvStoreView::<K, I,
                                                                                L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                                            ConcurrentKvStoreView::<K, I,
                                                                                L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv }, result)
                                                                    })
                                                        } else { false }))
                                        } else { false }))
                        },
                        #[verus::internal(trigger)] perm.check_permission(s1, s2)))
        }
        #[verus::internal(verus_macro)]
        pub trait MutatingLinearizer<K, I, L,
            Op: MutatingOperation<K, I, L>>: Sized {
            type Completion;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn namespaces(self)
            -> Set<int>;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn pre(self, id: int, op: Op)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn post(self, complete: Self::Completion, id: int, op: Op,
            exec_result: Op::ExecResult)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self, op: Op,
            new_ckv: ConcurrentKvStoreView<K, I, L>,
            exec_result: Op::ExecResult,
            #[verus::internal(proof)] r:
                &mut GhostVarAuth<ConcurrentKvStoreView<K, I, L>>)
            -> Self::Completion;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__namespaces(self) -> Set<int> {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__pre(self, id: int, op: Op) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__post(self, complete: Self::Completion, id: int,
                op: Op, exec_result: Op::ExecResult) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn VERUS_SPEC__apply(#[verus::internal(proof)] self, op: Op,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                exec_result: Op::ExecResult,
                #[verus::internal(proof)] r:
                    &mut GhostVarAuth<ConcurrentKvStoreView<K, I, L>>)
                -> Self::Completion {
                ::builtin::requires([self.pre(old(r).id(), op),
                            op.result_valid((old(r).view()), new_ckv, exec_result)]);
                ::builtin::ensures(|complete: Self::Completion|
                        [::builtin::spec_eq(r.id(), old(r).id()),
                                ::builtin::spec_eq((r.view()), new_ckv),
                                self.post(complete, r.id(), op, exec_result)]);
                ::builtin::opens_invariants_set(self.namespaces());
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub struct ReadItemOp<K> where K: Hash + PmCopy + Sized +
            std::fmt::Debug {
            pub key: K,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> ReadOnlyOperation<K, I, L> for ReadItemOp<K> where
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<I, KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(item) => {
                        ((if let Ok(i) = (ckv.kv.read_item(self.key)) {
                                        ::builtin::spec_eq(item, i)
                                    } else { false }))
                    }
                    Err(KvError::CRCMismatch) =>
                        !ckv.pm_constants.impervious_to_corruption(),
                    Err(e) => {
                        ((if let Err(e_spec) = (ckv.kv.read_item(self.key)) {
                                        ::builtin::spec_eq(e, e_spec)
                                    } else { false }))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct CreateOp<K, I> where K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug {
            pub key: K,
            pub item: I,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for CreateOp<K, I> where
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) = (old_ckv.kv.create(self.key, self.item))
                                                {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys))
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.create(self.key, self.item)) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct UpdateItemOp<K, I> where K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug {
            pub key: K,
            pub item: I,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for UpdateItemOp<K, I> where
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) =
                                                    (old_ckv.kv.update_item(self.key, self.item)) {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys))
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.update_item(self.key, self.item)) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct DeleteOp<K> where K: Hash + PmCopy + Sized +
            std::fmt::Debug {
            pub key: K,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for DeleteOp<K> where
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) = (old_ckv.kv.delete(self.key)) {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) = (old_ckv.kv.delete(self.key)) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct GetKeysOp {}
        #[verus::internal(verus_macro)]
        impl<K, I, L> ReadOnlyOperation<K, I, L> for GetKeysOp where K: Hash +
            PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<Vec<K>, KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(keys) => {
                        (::builtin::spec_eq((keys.view()).to_set(),
                                    ckv.kv.get_keys())) && ((keys.view()).no_duplicates())
                    }
                    Err(KvError::CRCMismatch) =>
                        !ckv.pm_constants.impervious_to_corruption(),
                    Err(_) => false,
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct ReadItemAndListOp<K> where K: Hash + PmCopy + Sized +
            std::fmt::Debug {
            pub key: K,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> ReadOnlyOperation<K, I, L> for ReadItemAndListOp<K>
            where K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy +
            Sized + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            type ExecResult = Result<(I, Vec<L>), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok((item, lst)) => {
                        ((if let Ok((i, l)) = (ckv.kv.read_item_and_list(self.key))
                                        {
                                        (::builtin::spec_eq(item, i)) &&
                                            (::builtin::spec_eq((lst.view()), l))
                                    } else { false }))
                    }
                    Err(KvError::CRCMismatch) =>
                        !ckv.pm_constants.impervious_to_corruption(),
                    Err(e) => {
                        ((if let Err(e_spec) = (ckv.kv.read_item_and_list(self.key))
                                        {
                                        ::builtin::spec_eq(e, e_spec)
                                    } else { false }))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct ReadListOp<K> where K: Hash + PmCopy + Sized +
            std::fmt::Debug {
            pub key: K,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> ReadOnlyOperation<K, I, L> for ReadListOp<K> where
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<Vec<L>, KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(lst) => {
                        ((if let Ok((i, l)) = (ckv.kv.read_item_and_list(self.key))
                                        {
                                        ::builtin::spec_eq((lst.view()), l)
                                    } else { false }))
                    }
                    Err(KvError::CRCMismatch) =>
                        !ckv.pm_constants.impervious_to_corruption(),
                    Err(e) => {
                        ((if let Err(e_spec) = (ckv.kv.read_item_and_list(self.key))
                                        {
                                        ::builtin::spec_eq(e, e_spec)
                                    } else { false }))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct GetListLengthOp<K> where K: Hash + PmCopy + Sized +
            std::fmt::Debug {
            pub key: K,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> ReadOnlyOperation<K, I, L> for GetListLengthOp<K> where
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<usize, KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(num_elements) => {
                        ((if let Ok(n) = (ckv.kv.get_list_length(self.key)) {
                                        ::builtin::spec_eq(num_elements, n)
                                    } else { false }))
                    }
                    Err(KvError::CRCMismatch) =>
                        !ckv.pm_constants.impervious_to_corruption(),
                    Err(e) => {
                        ((if let Err(e_spec) = (ckv.kv.get_list_length(self.key)) {
                                        ::builtin::spec_eq(e, e_spec)
                                    } else { false }))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct AppendToListOp<K, L> where K: Hash + PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
            Copy {
            pub key: K,
            pub new_list_element: L,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for AppendToListOp<K, L>
            where K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy +
            Sized + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) =
                                                    (old_ckv.kv.append_to_list(self.key, self.new_list_element))
                                                {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ({
                                    ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys)) ||
                                        ((old_ckv.kv.num_list_elements()).spec_ge(old_ckv.ps.max_list_elements))
                                })
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.append_to_list(self.key, self.new_list_element))
                                                {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct AppendToListAndUpdateItemOp<K, I, L> where K: Hash +
            PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
            Copy {
            pub key: K,
            pub new_list_element: L,
            pub new_item: I,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for
            AppendToListAndUpdateItemOp<K, I, L> where K: Hash + PmCopy +
            Sized + std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug,
            L: PmCopy + LogicalRange + std::fmt::Debug + Copy {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) =
                                                    (old_ckv.kv.append_to_list_and_update_item(self.key,
                                                            self.new_list_element, self.new_item)) {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ({
                                    ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys)) ||
                                        ((old_ckv.kv.num_list_elements()).spec_ge(old_ckv.ps.max_list_elements))
                                })
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.append_to_list_and_update_item(self.key,
                                                            self.new_list_element, self.new_item)) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct UpdateListElementAtIndexOp<K, L> where K: Hash + PmCopy +
            Sized + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            pub key: K,
            pub idx: usize,
            pub new_list_element: L,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for
            UpdateListElementAtIndexOp<K, L> where K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) =
                                                    (old_ckv.kv.update_list_element_at_index(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.idx),
                                                            self.new_list_element)) {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ({
                                    ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys)) ||
                                        ((old_ckv.kv.num_list_elements()).spec_ge(old_ckv.ps.max_list_elements))
                                })
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.update_list_element_at_index(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.idx),
                                                            self.new_list_element)) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct UpdateListElementAtIndexAndItemOp<K, I, L> where K: Hash +
            PmCopy + Sized + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            pub key: K,
            pub idx: usize,
            pub new_list_element: L,
            pub new_item: I,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for
            UpdateListElementAtIndexAndItemOp<K, I, L> where K: Hash +
            PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) =
                                                    (old_ckv.kv.update_list_element_at_index_and_item(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.idx),
                                                            self.new_list_element, self.new_item)) {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ({
                                    ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys)) ||
                                        ((old_ckv.kv.num_list_elements()).spec_ge(old_ckv.ps.max_list_elements))
                                })
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.update_list_element_at_index_and_item(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.idx),
                                                            self.new_list_element, self.new_item)) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct TrimListOp<K> where K: Hash + PmCopy + Sized +
            std::fmt::Debug {
            pub key: K,
            pub trim_length: usize,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for TrimListOp<K> where
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug + Copy
            {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) =
                                                    (old_ckv.kv.trim_list(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.trim_length))) {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys))
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.trim_list(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.trim_length))) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        pub struct TrimListAndUpdateItemOp<K, I> where K: Hash + PmCopy +
            Sized + std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug {
            pub key: K,
            pub trim_length: usize,
            pub new_item: I,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> MutatingOperation<K, I, L> for
            TrimListAndUpdateItemOp<K, I> where K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            type ExecResult = Result<(), KvError>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn result_valid(self, old_ckv: ConcurrentKvStoreView<K, I, L>,
                new_ckv: ConcurrentKvStoreView<K, I, L>,
                result: Self::ExecResult) -> bool {
                match result {
                    Ok(()) => {
                        (::builtin::spec_eq(new_ckv,
                                    ConcurrentKvStoreView { kv: new_ckv.kv, ..old_ckv })) &&
                            (((if let Ok(kv) =
                                                    (old_ckv.kv.trim_list_and_update_item(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.trim_length),
                                                            self.new_item)) {
                                                ::builtin::spec_eq(kv, new_ckv.kv)
                                            } else { false })))
                    }
                    Err(KvError::CRCMismatch) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (!old_ckv.pm_constants.impervious_to_corruption())
                    }
                    Err(KvError::OutOfSpace) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            ((old_ckv.kv.num_keys()).spec_ge(old_ckv.ps.max_keys))
                    }
                    Err(e) => {
                        (::builtin::spec_eq(new_ckv, old_ckv)) &&
                            (((if let Err(e_spec) =
                                                    (old_ckv.kv.trim_list_and_update_item(self.key,
                                                            ::builtin::spec_cast_integer::<_, nat>(self.trim_length),
                                                            self.new_item)) {
                                                ::builtin::spec_eq(e, e_spec)
                                            } else { false })))
                    }
                }
            }
        }
    }
    pub mod crud_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::traits_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::keys::KeyTableRowMetadata;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + std::fmt::Debug,
            I: PmCopy + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_item(&self, key: &K) -> Result<I, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<I, KvError>|
                        [match result {
                                    Ok(item) => {
                                        ((if let Ok(i) = ((self.view()).tentative.read_item(*key)) {
                                                        ::builtin::spec_eq(item, i)
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.read_item(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (_key_addr, row_metadata) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        None => { return Err(KvError::KeyNotFound); }
                        Some(i) => i,
                    };
                let item =
                    match self.items.read(row_metadata.item_addr, &self.journal)
                        {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            return Err(KvError::CRCMismatch);
                        }
                        Err(_) => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::KeyNotFound);
                        }
                    };
                Ok(item)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_create(&mut self, key: &K, item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.create(*key, *item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.create(*key, *item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                match self.keys.read(key,
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                    {
                    Some(info) => { return Err(KvError::KeyAlreadyExists); }
                    None => {}
                };
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                    old(self).perm_factory))
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_item_table_update() };
                #[verus::internal(spec)]
                let mut self_before_item_create;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_item_create = verus_tmp;
                    self_before_item_create = verus_tmp_self_before_item_create;
                };
                let result =
                    self.items.create::<PermFactory>(item, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_item_table_update(self_before_item_create);
                }
                let item_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_key_table_update() };
                #[verus::internal(spec)]
                let mut self_before_key_create;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_key_create = verus_tmp;
                    self_before_key_create = verus_tmp_self_before_key_create;
                };
                let result =
                    self.keys.create::<PermFactory>(key, item_addr,
                        &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_key_table_update(self_before_key_create);
                }
                match result {
                    Ok(()) => {}
                    Err(KvError::OutOfSpace) => {
                        self.status =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                        self.internal_abort();

                        #[verifier::proof_block]
                        {
                            old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                        }
                        return Err(KvError::OutOfSpace);
                    }
                    _ => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.create(*key, *item).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_delete(&mut self, key: &K)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.delete(*key)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.delete(*key)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);
                self.items.delete(rm.item_addr, &self.journal);
                if rm.list_addr != 0 {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                            old(self).perm_factory))
                                };
                        };
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = self.lemma_prepare_for_list_table_update() };
                        #[verus::internal(spec)]
                        let mut self_before_list_delete;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_self_before_list_delete = verus_tmp;
                            self_before_list_delete = verus_tmp_self_before_list_delete;
                        };
                        let result =
                            self.lists.delete::<PermFactory>(rm.list_addr,
                                &mut self.journal,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                        #[verifier::proof_block]
                        {
                            self.lemma_reflect_list_table_update(self_before_list_delete);
                        }
                        match result {
                            Ok(()) => {}
                            Err(KvError::OutOfSpace) => {
                                self.status =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                                self.internal_abort();

                                #[verifier::proof_block]
                                {
                                    old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                                }
                                return Err(KvError::OutOfSpace);
                            }
                            Err(KvError::CRCMismatch) => {
                                self.status =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                                self.internal_abort();
                                return Err(KvError::CRCMismatch);
                            }
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                        }
                    }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq((self.journal.view()).remaining_capacity,
                                    (old(self).journal.view()).remaining_capacity))
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_key_table_update() };
                #[verus::internal(spec)]
                let mut self_before_key_delete;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_key_delete = verus_tmp;
                    self_before_key_delete = verus_tmp_self_before_key_delete;
                };
                let result =
                    self.keys.delete::<PermFactory>(key, key_addr, rm,
                        &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_key_table_update(self_before_key_delete);
                }
                match result {
                    Ok(()) => {}
                    Err(KvError::OutOfSpace) => {
                        self.status =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                        self.internal_abort();

                        #[verifier::proof_block]
                        {
                            old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                        }
                        return Err(KvError::OutOfSpace);
                    }
                    _ => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.delete(*key).unwrap()))
                        };
                };
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.keys.view()).tentative.unwrap().list_addrs(),
                                    (self.lists.view()).tentative.unwrap().m.dom()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_update_item(&mut self, key: &K, new_item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.update_item(*key, *new_item))
                                                                {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.update_item(*key, *new_item))
                                                                {
                                                                ::builtin::spec_eq(e_spec, e)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, former_rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                    old(self).perm_factory))
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_item_table_update() };
                #[verus::internal(spec)]
                let mut self_before_item_create;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_item_create = verus_tmp;
                    self_before_item_create = verus_tmp_self_before_item_create;
                };
                let result =
                    self.items.create::<PermFactory>(new_item,
                        &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_item_table_update(self_before_item_create);
                }
                let item_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_key_table_update() };
                #[verus::internal(spec)]
                let mut self_before_key_update;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_key_update = verus_tmp;
                    self_before_key_update = verus_tmp_self_before_key_update;
                };
                let new_rm = KeyTableRowMetadata { item_addr, ..former_rm };
                let result =
                    self.keys.update::<PermFactory>(key, key_addr, new_rm,
                        former_rm, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_key_table_update(self_before_key_update);
                }
                match result {
                    Ok(()) => {}
                    Err(KvError::OutOfSpace) => {
                        self.status =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                        self.internal_abort();

                        #[verifier::proof_block]
                        {
                            old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                        }
                        return Err(KvError::OutOfSpace);
                    }
                    _ => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                }
                self.items.delete(former_rm.item_addr, &self.journal);
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        (old(self).keys.view()).tentative.unwrap().item_addrs()
                };
                #[verus::internal(spec)]
                let mut old_item_addrs;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_old_item_addrs = verus_tmp;
                    old_item_addrs = verus_tmp_old_item_addrs;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal(old_item_addrs.insert(new_rm.item_addr).remove(former_rm.item_addr),
                                    old_item_addrs.remove(former_rm.item_addr).insert(new_rm.item_addr)))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.update_item(*key,
                                            *new_item).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
        }
    }
    pub mod elements_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::journal::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::keys::*;
        use super::impl_v::*;
        use super::lists::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_list(&self, key: &K) -> Result<Vec<L>, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<Vec<L>, KvError>|
                        [match result {
                                    Ok(lst) => {
                                        ((if let Ok((i, l)) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        ::builtin::spec_eq((lst.view()), l)
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (_key_addr, row_metadata) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        None => { return Err(KvError::KeyNotFound); }
                        Some(i) => i,
                    };
                let list_addr = row_metadata.list_addr;
                if list_addr == 0 { return Ok(Vec::<L>::new()); }
                self.lists.read(list_addr, &self.journal)
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_item_and_list(&self, key: &K)
                -> Result<(I, Vec<L>), KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<(I, Vec<L>), KvError>|
                        [match result {
                                    Ok((item, lst)) => {
                                        ((if let Ok((i, l)) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        (::builtin::spec_eq(item, i)) &&
                                                            (::builtin::spec_eq((lst.view()), l))
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (_key_addr, row_metadata) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        None => { return Err(KvError::KeyNotFound); }
                        Some(i) => i,
                    };
                let item =
                    match self.items.read(row_metadata.item_addr, &self.journal)
                        {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            return Err(KvError::CRCMismatch);
                        }
                        Err(_) => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::KeyNotFound);
                        }
                    };
                let list_addr = row_metadata.list_addr;
                if list_addr == 0 { return Ok((item, Vec::<L>::new())); }
                let lst =
                    match self.lists.read(list_addr, &self.journal) {
                        Ok(s) => s,
                        Err(KvError::CRCMismatch) => {
                            return Err(KvError::CRCMismatch);
                        }
                        Err(_) => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::KeyNotFound);
                        }
                    };
                Ok((item, lst))
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_list_length(&self, key: &K) -> Result<usize, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<usize, KvError>|
                        [match result {
                                    Ok(num_elements) => {
                                        ((if let Ok(n) =
                                                            ((self.view()).tentative.get_list_length(*key)) {
                                                        ::builtin::spec_eq(num_elements, n)
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.get_list_length(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (_key_addr, row_metadata) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        None => { return Err(KvError::KeyNotFound); }
                        Some(i) => i,
                    };
                let list_addr = row_metadata.list_addr;
                if list_addr == 0 { return Ok(0); }
                self.lists.get_list_length(list_addr, &self.journal)
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn tentatively_append_to_list_step1(&mut self, key: &K,
                key_addr: u64, former_rm: &KeyTableRowMetadata,
                new_list_element: L) -> Result<u64, KvError> {
                ::builtin::requires([old(self).valid(),
                            ::builtin::is_variant((old(self).keys.view()).tentative,
                                "Some"),
                            (old(self).keys.view()).tentative.unwrap().key_info.contains_key(*key),
                            ::builtin::spec_eq((old(self).keys.view()).tentative.unwrap().key_info.spec_index(*key),
                                *former_rm)]);
                ::builtin::ensures(|result: Result<u64, KvError>|
                        [match result {
                                    Ok(list_addr) => {
                                        let old_list =
                                            if ::builtin::spec_eq(former_rm.list_addr,
                                                        ::builtin::spec_literal_nat("0")) {
                                                    Seq::<L>::empty()
                                                } else {
                                                   (old(self).lists.view()).tentative.unwrap().m.spec_index(former_rm.list_addr)
                                               };
                                        (((((((((((((::builtin::spec_eq(self,
                                                                                                                                                    Self {
                                                                                                                                                        status: ::builtin::Ghost::new(KvStoreStatus::ComponentsDontCorrespond),
                                                                                                                                                        journal: self.journal,
                                                                                                                                                        lists: self.lists,
                                                                                                                                                        ..*old(self)
                                                                                                                                                    })) && (self.inv())) &&
                                                                                                                                    (!::builtin::spec_eq(list_addr,
                                                                                                                                                ::builtin::spec_literal_nat("0")))) &&
                                                                                                                            (::builtin::spec_eq(list_addr, former_rm.list_addr) ||
                                                                                                                                    !(old(self).lists.view()).tentative.unwrap().m.contains_key(list_addr)))
                                                                                                                    && (self.lists.validate_list_addr(list_addr))) &&
                                                                                                            (::builtin::spec_eq((self.lists.view()),
                                                                                                                    ListTableView {
                                                                                                                        tentative: (self.lists.view()).tentative,
                                                                                                                        used_slots: (self.lists.view()).used_slots,
                                                                                                                        ..(old(self).lists.view())
                                                                                                                    }))) &&
                                                                                                    (((self.lists.view()).used_slots).spec_le(((old(self).lists.view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                                                            &&
                                                                                            (::builtin::is_variant((self.lists.view()).tentative,
                                                                                                    "Some"))) &&
                                                                                    (::builtin::spec_eq((self.lists.view()).tentative.unwrap(),
                                                                                            if ::builtin::spec_eq(former_rm.list_addr,
                                                                                                        ::builtin::spec_literal_nat("0")) {
                                                                                                    (old(self).lists.view()).tentative.unwrap().create_singleton(list_addr,
                                                                                                        new_list_element)
                                                                                                } else {
                                                                                                   (old(self).lists.view()).tentative.unwrap().append(former_rm.list_addr,
                                                                                                       list_addr, new_list_element)
                                                                                               }))) && ((old_list.len()).spec_lt(usize::MAX))) &&
                                                                    (match (self.lists.view()).logical_range_gaps_policy {
                                                                            LogicalRangeGapsPolicy::LogicalRangeGapsForbidden =>
                                                                                ::builtin::spec_eq(new_list_element.start(),
                                                                                    end_of_range(old_list)),
                                                                            LogicalRangeGapsPolicy::LogicalRangeGapsPermitted =>
                                                                                (new_list_element.start()).spec_ge(end_of_range(old_list)),
                                                                        })) &&
                                                            ((self.journal.view()).matches_except_in_range((old(self).journal.view()),
                                                                    ::builtin::spec_cast_integer::<_,
                                                                            int>((self.lists.view()).sm.start()),
                                                                    ::builtin::spec_cast_integer::<_,
                                                                            int>((self.lists.view()).sm.end())))) &&
                                                    (((self.journal.view()).remaining_capacity).spec_ge(((((old(self).journal.view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())).spec_sub(u64::spec_size_of()))))
                                            &&
                                            (::builtin::spec_eq((self.journal.view()).powerpm_id,
                                                    (old(self).journal.view()).powerpm_id))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        ((self.valid()) &&
                                                    (::builtin::spec_eq((self.view()),
                                                            (old(self).view()).abort()))) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        ((self.valid()) &&
                                                    (::builtin::spec_eq((self.view()),
                                                            (old(self).view()).abort()))) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        ((self.valid()) &&
                                                    (::builtin::spec_eq((self.view()), (old(self).view())))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.append_to_list(*key,
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_list_table_update() };
                #[verus::internal(spec)]
                let mut self_before_list_append;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_list_append = verus_tmp;
                    self_before_list_append = verus_tmp_self_before_list_append;
                };
                let result =
                    if former_rm.list_addr == 0 {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::spec_eq(end_of_range(Seq::<L>::empty()),
                                                ::builtin::spec_literal_nat("0")))
                                    };
                            };
                            self.lists.create_singleton::<PermFactory>(new_list_element,
                                &mut self.journal,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()))
                        } else {
                           self.lists.append::<PermFactory>(former_rm.list_addr,
                               new_list_element, &mut self.journal,
                               #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()))
                       };

                #[verifier::proof_block]
                {
                    self.lemma_reflect_list_table_update(self_before_list_append);
                }
                let list_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();
                            return Err(KvError::CRCMismatch);
                        }
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        Err(KvError::ListLengthWouldExceedUsizeMax) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::ListLengthWouldExceedUsizeMax);
                        }
                        Err(KvError::PageLeavesLogicalRangeGap { end_of_valid_range
                            }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::PageLeavesLogicalRangeGap {
                                        end_of_valid_range,
                                    });
                        }
                        Err(KvError::PageOutOfLogicalRangeOrder { end_of_valid_range
                            }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::PageOutOfLogicalRangeOrder {
                                        end_of_valid_range,
                                    });
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                Ok(list_addr)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_append_to_list(&mut self, key: &K,
                new_list_element: L) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.append_to_list(*key,
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.append_to_list(*key,
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, former_rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                let list_addr =
                    match self.tentatively_append_to_list_step1(key, key_addr,
                            &former_rm, new_list_element) {
                        Ok(a) => a,
                        Err(e) => { return Err(e); }
                    };
                if list_addr != former_rm.list_addr {
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = self.lemma_prepare_for_key_table_update() };
                        #[verus::internal(spec)]
                        let mut self_before_key_update;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_self_before_key_update = verus_tmp;
                            self_before_key_update = verus_tmp_self_before_key_update;
                        };
                        let new_rm = KeyTableRowMetadata { list_addr, ..former_rm };
                        let result =
                            self.keys.update::<PermFactory>(key, key_addr, new_rm,
                                former_rm, &mut self.journal,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                        #[verifier::proof_block]
                        {
                            self.lemma_reflect_key_table_update(self_before_key_update);
                        }
                        match result {
                            Ok(()) => {}
                            Err(KvError::OutOfSpace) => {
                                self.status =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                                self.internal_abort();

                                #[verifier::proof_block]
                                {
                                    old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                                }
                                return Err(KvError::OutOfSpace);
                            }
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                        };
                    }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_list_element_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_list_element_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.append_to_list(*key,
                                            new_list_element).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_append_to_list_and_update_item(&mut self,
                key: &K, new_list_element: L, new_item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.append_to_list_and_update_item(*key,
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.append_to_list_and_update_item(*key,
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, former_rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                let list_addr =
                    match self.tentatively_append_to_list_step1(key, key_addr,
                            &former_rm, new_list_element) {
                        Ok(a) => a,
                        Err(e) => { return Err(e); }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_item_table_update() };
                #[verus::internal(spec)]
                let mut self_before_item_create;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_item_create = verus_tmp;
                    self_before_item_create = verus_tmp_self_before_item_create;
                };
                let result =
                    self.items.create::<PermFactory>(&new_item,
                        &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_item_table_update(self_before_item_create);
                }
                let item_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_key_table_update() };
                #[verus::internal(spec)]
                let mut self_before_key_update;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_key_update = verus_tmp;
                    self_before_key_update = verus_tmp_self_before_key_update;
                };
                let new_rm = KeyTableRowMetadata { item_addr, list_addr };
                let result =
                    self.keys.update::<PermFactory>(key, key_addr, new_rm,
                        former_rm, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_key_table_update(self_before_key_update);
                }
                match result {
                    Ok(()) => {}
                    Err(KvError::OutOfSpace) => {
                        self.status =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                        self.internal_abort();

                        #[verifier::proof_block]
                        {
                            old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                        }
                        return Err(KvError::OutOfSpace);
                    }
                    _ => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                };
                self.items.delete(former_rm.item_addr, &self.journal);
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_list_element_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_list_element_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        (old(self).keys.view()).tentative.unwrap().item_addrs()
                };
                #[verus::internal(spec)]
                let mut old_item_addrs;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_old_item_addrs = verus_tmp;
                    old_item_addrs = verus_tmp_old_item_addrs;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal(old_item_addrs.insert(new_rm.item_addr).remove(former_rm.item_addr),
                                    old_item_addrs.remove(former_rm.item_addr).insert(new_rm.item_addr)))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.append_to_list_and_update_item(*key,
                                            new_list_element, *new_item).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_update_list_element_at_index(&mut self,
                key: &K, idx: usize, new_list_element: L)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, former_rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                if former_rm.list_addr == 0 {
                        return Err(KvError::IndexOutOfRange { upper_bound: 0 });
                    }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                    old(self).perm_factory))
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_list_table_update() };
                #[verus::internal(spec)]
                let mut self_before_list_update;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_list_update = verus_tmp;
                    self_before_list_update = verus_tmp_self_before_list_update;
                };
                let result =
                    self.lists.update::<PermFactory>(former_rm.list_addr, idx,
                        new_list_element, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_list_table_update(self_before_list_update);
                }
                let list_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();
                            return Err(KvError::CRCMismatch);
                        }
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        Err(KvError::IndexOutOfRange { upper_bound }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::IndexOutOfRange { upper_bound });
                        }
                        Err(KvError::LogicalRangeUpdateNotAllowed {
                            old_start, old_end, new_start, new_end }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::LogicalRangeUpdateNotAllowed {
                                        old_start,
                                        old_end,
                                        new_start,
                                        new_end,
                                    });
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                if list_addr != former_rm.list_addr {
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = self.lemma_prepare_for_key_table_update() };
                        #[verus::internal(spec)]
                        let mut self_before_key_update;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_self_before_key_update = verus_tmp;
                            self_before_key_update = verus_tmp_self_before_key_update;
                        };
                        let new_rm = KeyTableRowMetadata { list_addr, ..former_rm };
                        let result =
                            self.keys.update::<PermFactory>(key, key_addr, new_rm,
                                former_rm, &mut self.journal,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                        #[verifier::proof_block]
                        {
                            self.lemma_reflect_key_table_update(self_before_key_update);
                        }
                        match result {
                            Ok(()) => {}
                            Err(KvError::OutOfSpace) => {
                                self.status =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                                self.internal_abort();

                                #[verifier::proof_block]
                                {
                                    old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                                }
                                return Err(KvError::OutOfSpace);
                            }
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                        };
                    }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_list_element_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_list_element_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.update_list_element_at_index(*key,
                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                            new_list_element).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_update_list_element_at_index_and_item(&mut self,
                key: &K, idx: usize, new_list_element: L, new_item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index_and_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index_and_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, former_rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                if former_rm.list_addr == 0 {
                        return Err(KvError::IndexOutOfRange { upper_bound: 0 });
                    }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                    old(self).perm_factory))
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_list_table_update() };
                #[verus::internal(spec)]
                let mut self_before_list_update;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_list_update = verus_tmp;
                    self_before_list_update = verus_tmp_self_before_list_update;
                };
                let result =
                    self.lists.update::<PermFactory>(former_rm.list_addr, idx,
                        new_list_element, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_list_table_update(self_before_list_update);
                }
                let list_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();
                            return Err(KvError::CRCMismatch);
                        }
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        Err(KvError::IndexOutOfRange { upper_bound }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::IndexOutOfRange { upper_bound });
                        }
                        Err(KvError::LogicalRangeUpdateNotAllowed {
                            old_start, old_end, new_start, new_end }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::LogicalRangeUpdateNotAllowed {
                                        old_start,
                                        old_end,
                                        new_start,
                                        new_end,
                                    });
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_item_table_update() };
                #[verus::internal(spec)]
                let mut self_before_item_create;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_item_create = verus_tmp;
                    self_before_item_create = verus_tmp_self_before_item_create;
                };
                let result =
                    self.items.create::<PermFactory>(&new_item,
                        &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_item_table_update(self_before_item_create);
                }
                let item_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_key_table_update() };
                #[verus::internal(spec)]
                let mut self_before_key_update;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_key_update = verus_tmp;
                    self_before_key_update = verus_tmp_self_before_key_update;
                };
                let new_rm = KeyTableRowMetadata { item_addr, list_addr };
                let result =
                    self.keys.update::<PermFactory>(key, key_addr, new_rm,
                        former_rm, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_key_table_update(self_before_key_update);
                }
                match result {
                    Ok(()) => {}
                    Err(KvError::OutOfSpace) => {
                        self.status =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                        self.internal_abort();

                        #[verifier::proof_block]
                        {
                            old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                        }
                        return Err(KvError::OutOfSpace);
                    }
                    _ => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                };
                self.items.delete(former_rm.item_addr, &self.journal);
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_list_element_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_list_element_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        (old(self).keys.view()).tentative.unwrap().item_addrs()
                };
                #[verus::internal(spec)]
                let mut old_item_addrs;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_old_item_addrs = verus_tmp;
                    old_item_addrs = verus_tmp_old_item_addrs;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal(old_item_addrs.insert(new_rm.item_addr).remove(former_rm.item_addr),
                                    old_item_addrs.remove(former_rm.item_addr).insert(new_rm.item_addr)))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.update_list_element_at_index_and_item(*key,
                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                            new_list_element, *new_item).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_trim_list(&mut self, key: &K,
                trim_length: usize) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.trim_list(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length))) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.trim_list(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length))) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, former_rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                if trim_length == 0 {
                        self.used_key_slots =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                        self.used_transaction_operation_slots =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal((self.view()).tentative.read_item_and_list(*key).unwrap().1.skip(::builtin::spec_cast_integer::<_,
                                                        int>(trim_length)),
                                            (self.view()).tentative.read_item_and_list(*key).unwrap().1))
                                };
                        };

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal((self.view()).tentative.trim_list(*key,
                                                    ::builtin::spec_cast_integer::<_,
                                                            nat>(trim_length)).unwrap(), (self.view()).tentative))
                                };
                        };

                        #[verifier::proof_block]
                        {
                            self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                        }

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                            old(self).perm_factory))
                                };
                        };
                        return Ok(());
                    }
                if former_rm.list_addr == 0 {
                        return Err(KvError::IndexOutOfRange { upper_bound: 0 });
                    }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                    old(self).perm_factory))
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_list_table_update() };
                #[verus::internal(spec)]
                let mut self_before_list_trim;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_list_trim = verus_tmp;
                    self_before_list_trim = verus_tmp_self_before_list_trim;
                };
                let result =
                    self.lists.trim::<PermFactory>(former_rm.list_addr,
                        trim_length, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_list_table_update(self_before_list_trim);
                }
                let list_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();
                            return Err(KvError::CRCMismatch);
                        }
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        Err(KvError::IndexOutOfRange { upper_bound }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::IndexOutOfRange { upper_bound });
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                if list_addr != former_rm.list_addr {
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = self.lemma_prepare_for_key_table_update() };
                        #[verus::internal(spec)]
                        let mut self_before_key_update;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_self_before_key_update = verus_tmp;
                            self_before_key_update = verus_tmp_self_before_key_update;
                        };
                        let new_rm = KeyTableRowMetadata { list_addr, ..former_rm };
                        let result =
                            self.keys.update::<PermFactory>(key, key_addr, new_rm,
                                former_rm, &mut self.journal,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                        #[verifier::proof_block]
                        {
                            self.lemma_reflect_key_table_update(self_before_key_update);
                        }
                        match result {
                            Ok(()) => {}
                            Err(KvError::OutOfSpace) => {
                                self.status =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                                self.internal_abort();

                                #[verifier::proof_block]
                                {
                                    old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                                }
                                return Err(KvError::OutOfSpace);
                            }
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                        };
                    }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.trim_list(*key,
                                            ::builtin::spec_cast_integer::<_,
                                                    nat>(trim_length)).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_trim_list_and_update_item(&mut self, key: &K,
                trim_length: usize, new_item: &I) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.trim_list_and_update_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length),
                                                                            *new_item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.trim_list_and_update_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length),
                                                                            *new_item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);

                #[verifier::proof_block]
                { self.keys.lemma_valid_implications((self.journal.view())); }
                let (key_addr, former_rm) =
                    match self.keys.read(key,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.journal.view())))
                        {
                        Some(info) => info,
                        None => { return Err(KvError::KeyNotFound); }
                    };
                if trim_length == 0 {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal((self.view()).tentative.read_item_and_list(*key).unwrap().1.skip(::builtin::spec_cast_integer::<_,
                                                        int>(trim_length)),
                                            (self.view()).tentative.read_item_and_list(*key).unwrap().1))
                                };
                        };

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal((self.view()).tentative.trim_list_and_update_item(*key,
                                                ::builtin::spec_cast_integer::<_, nat>(trim_length),
                                                *new_item),
                                            (self.view()).tentative.update_item(*key, *new_item)))
                                };
                        };
                        return self.tentatively_update_item(key, &new_item);
                    }
                if former_rm.list_addr == 0 {
                        return Err(KvError::IndexOutOfRange { upper_bound: 0 });
                    }
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::ComponentsDontCorrespond);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq(self.perm_factory,
                                    old(self).perm_factory))
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_list_table_update() };
                #[verus::internal(spec)]
                let mut self_before_list_trim;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_list_trim = verus_tmp;
                    self_before_list_trim = verus_tmp_self_before_list_trim;
                };
                let result =
                    self.lists.trim::<PermFactory>(former_rm.list_addr,
                        trim_length, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_list_table_update(self_before_list_trim);
                }
                let list_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();
                            return Err(KvError::CRCMismatch);
                        }
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        Err(KvError::IndexOutOfRange { upper_bound }) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                            return Err(KvError::IndexOutOfRange { upper_bound });
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_item_table_update() };
                #[verus::internal(spec)]
                let mut self_before_item_create;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_item_create = verus_tmp;
                    self_before_item_create = verus_tmp_self_before_item_create;
                };
                let result =
                    self.items.create::<PermFactory>(&new_item,
                        &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_item_table_update(self_before_item_create);
                }
                let item_addr =
                    match result {
                        Ok(i) => i,
                        Err(KvError::OutOfSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                            self.internal_abort();

                            #[verifier::proof_block]
                            {
                                old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                            }
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = self.lemma_prepare_for_key_table_update() };
                #[verus::internal(spec)]
                let mut self_before_key_update;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_self_before_key_update = verus_tmp;
                    self_before_key_update = verus_tmp_self_before_key_update;
                };
                let new_rm = KeyTableRowMetadata { item_addr, list_addr };
                let result =
                    self.keys.update::<PermFactory>(key, key_addr, new_rm,
                        former_rm, &mut self.journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] self.perm_factory.borrow()));

                #[verifier::proof_block]
                {
                    self.lemma_reflect_key_table_update(self_before_key_update);
                }
                match result {
                    Ok(()) => {}
                    Err(KvError::OutOfSpace) => {
                        self.status =
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::MustAbort);
                        self.internal_abort();

                        #[verifier::proof_block]
                        {
                            old(self).lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used();
                        }
                        return Err(KvError::OutOfSpace);
                    }
                    _ => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                };
                self.items.delete(former_rm.item_addr, &self.journal);
                self.status =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent);
                self.used_key_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_key_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                self.used_transaction_operation_slots =
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ((self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1")));
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        (old(self).keys.view()).tentative.unwrap().item_addrs()
                };
                #[verus::internal(spec)]
                let mut old_item_addrs;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_old_item_addrs = verus_tmp;
                    old_item_addrs = verus_tmp_old_item_addrs;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(!::builtin::spec_eq(new_rm.item_addr,
                                        former_rm.item_addr))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal(old_item_addrs.insert(new_rm.item_addr).remove(former_rm.item_addr),
                                    old_item_addrs.remove(former_rm.item_addr).insert(new_rm.item_addr)))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                    (old(self).view()).tentative.trim_list_and_update_item(*key,
                                            ::builtin::spec_cast_integer::<_, nat>(trim_length),
                                            *new_item).unwrap()))
                        };
                };

                #[verifier::proof_block]
                {
                    self.lemma_using_space_for_transaction_operation_maintains_invariant(*old(self));
                }
                Ok(())
            }
        }
    }
    pub mod impl_t {
        //! This file contains the public interface of the paged key-value store.
        //! The methods offered by this file should match the mocks.
        //! The key-value store itself should be as generic as possible, not
        //! restricted to particular data structures.
        //! We define legal crash states at this level and pass them
        //! to the untrusted implementation, which passes them along
        //! to untrusted components.
        //!
        //! This file is unverified and should be tested/audited for correctness.
        #![allow(unused_imports)]
        #![verus::trusted]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::pcm::frac::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::inv_v::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        pub struct TrustedKvPermission {
            #[verus::internal(spec)]
            is_transition_allowable: ::builtin::FnSpec<(Seq<u8>, Seq<u8>),
            bool>,
            #[verus::internal(spec)]
            powerpm_id: int,
        }
        #[verus::internal(verus_macro)]
        impl CheckPermission<Seq<u8>> for TrustedKvPermission {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: Seq<u8>, s2: Seq<u8>) -> bool {
                (self.is_transition_allowable)(s1, s2)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn id(&self) -> int { self.powerpm_id }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self,
                #[verus::internal(proof)] credit:
                    vstd::invariant::OpenInvariantCredit,
                #[verus::internal(proof)] r: &mut GhostVarAuth<Seq<u8>>,
                new_state: Seq<u8>) {
                admit();
            }
        }
        #[verus::internal(verus_macro)]
        pub struct TrustedKvPermissionFactory {
            #[verus::internal(spec)]
            is_transition_allowable: ::builtin::FnSpec<(Seq<u8>, Seq<u8>),
            bool>,
            #[verus::internal(spec)]
            powerpm_id: int,
        }
        #[verus::internal(verus_macro)]
        impl PermissionFactory<Seq<u8>> for TrustedKvPermissionFactory {
            type Perm = TrustedKvPermission;
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: Seq<u8>, s2: Seq<u8>) -> bool {
                (self.is_transition_allowable)(s1, s2)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn grant_permission(#[verus::internal(proof)] &self)
                -> TrustedKvPermission {
                ::builtin::ensures(|perm: TrustedKvPermission|
                        [::builtin::forall(|s1, s2|
                                        ::builtin::imply(self.check_permission(s1, s2),
                                            #[verus::internal(trigger)] perm.check_permission(s1,
                                                s2)))]);
                TrustedKvPermission {
                    is_transition_allowable: ::builtin::closure_to_fn_spec(|s1:
                                Seq<u8>, s2: Seq<u8>|
                            (self.is_transition_allowable)(s1, s2)),
                    powerpm_id: self.powerpm_id,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn clone(#[verus::internal(proof)] &self) -> Self {
                ::builtin::ensures(|other: Self|
                        [::builtin::forall(|s1, s2|
                                        ::builtin::imply(self.check_permission(s1, s2),
                                            #[verus::internal(trigger)] other.check_permission(s1,
                                                s2)))]);
                Self {
                    is_transition_allowable: self.is_transition_allowable,
                    powerpm_id: self.powerpm_id,
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn id(&self) -> int { self.powerpm_id }
        }
        #[verifier::reject_recursive_types(K)]
        #[verifier::reject_recursive_types(I)]
        #[verifier::reject_recursive_types(L)]
        #[verus::internal(verus_macro)]
        pub struct KvStore<PM, K, I, L> where PM: PersistentMemoryRegion,
            K: Hash + PmCopy + Sized + std::fmt::Debug, I: PmCopy + Sized +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
            Copy {
            untrusted_kv_impl: UntrustedKvStoreImpl<TrustedKvPermissionFactory,
            PM, K, I, L>,
            powerpm_id: Ghost<int>,
        }
        #[verus::internal(verus_macro)]
        impl<PM, K, I, L> View for KvStore<PM, K, I, L> where
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            type V = KvStoreView<K, I, L>;
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn view(&self) -> KvStoreView<K, I, L> {
                (self.untrusted_kv_impl.view())
            }
        }
        #[verus::internal(verus_macro)]
        impl<PM, K, I, L> KvStore<PM, K, I, L> where
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                (self.untrusted_kv_impl.valid()) &&
                    (::builtin::spec_eq((self.powerpm_id.view()),
                            (self.untrusted_kv_impl.view()).powerpm_id))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn recover(s: Seq<u8>) -> Option<RecoveredKvStore<K, I, L>> {
                UntrustedKvStoreImpl::<TrustedKvPermissionFactory, PM, K, I,
                        L>::recover(s)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_space_needed_for_setup(ps: SetupParameters) -> nat {
                UntrustedKvStoreImpl::<TrustedKvPermissionFactory, PM, K, I,
                        L>::spec_space_needed_for_setup(ps)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_space_needed_for_transaction_operation() -> nat {
                spec_space_needed_for_transaction_operation()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn space_needed_for_setup(ps: &SetupParameters)
                -> Result<u64, KvError> {
                ::builtin::ensures(|result: Result<u64, KvError>|
                        [match result {
                                    Ok(v) =>
                                        ::builtin::spec_eq(v,
                                            Self::spec_space_needed_for_setup(*ps)),
                                    Err(KvError::InvalidParameter) => !ps.valid(),
                                    Err(KvError::OutOfSpace) =>
                                        (Self::spec_space_needed_for_setup(*ps)).spec_gt(u64::MAX),
                                    Err(_) => false,
                                }]);
                UntrustedKvStoreImpl::<TrustedKvPermissionFactory, PM, K, I,
                        L>::space_needed_for_setup(ps)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn setup(pm: &mut PM, ps: &SetupParameters)
                -> Result<(), KvError> {
                ::builtin::requires([old(pm).inv()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [pm.inv(),
                                ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                match result {
                                    Ok(()) => {
                                        (((pm.view()).flush_predicted()) && (ps.valid())) &&
                                            (::builtin::spec_eq(Self::recover((pm.view()).durable_state),
                                                    Some(RecoveredKvStore::<K, I, L>::init(*ps))))
                                    }
                                    Err(KvError::InvalidParameter) => !ps.valid(),
                                    Err(KvError::KeySizeTooSmall) =>
                                        ::builtin::spec_eq(K::spec_size_of(),
                                            ::builtin::spec_literal_nat("0")),
                                    Err(KvError::OutOfSpace) =>
                                        ((pm.view()).len()).spec_lt(Self::spec_space_needed_for_setup(*ps)),
                                    Err(_) => false,
                                }]);
                UntrustedKvStoreImpl::<TrustedKvPermissionFactory, PM, K, I,
                        L>::setup(pm, ps)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn start(pm: PM, kvstore_id: u128) -> Result<Self, KvError> {
                ::builtin::requires([pm.inv(),
                            ::builtin::is_variant(Self::recover((pm.view()).read_state),
                                "Some"), vstd::std_specs::hash::obeys_key_model::<K>()]);
                ::builtin::ensures(|result: Result<Self, KvError>|
                        [({
                                        let state = Self::recover((pm.view()).read_state).unwrap();
                                        match result {
                                            Ok(kv) => {
                                                (((((((((kv.valid()) && ((kv.view()).valid())) &&
                                                                                                            (::builtin::spec_eq((kv.view()).ps, state.ps))) &&
                                                                                                    ((kv.view()).ps.valid())) &&
                                                                                            (::builtin::spec_eq((kv.view()).used_key_slots,
                                                                                                    state.kv.m.dom().len()))) &&
                                                                                    (::builtin::spec_eq((kv.view()).used_list_element_slots,
                                                                                            state.kv.num_list_elements()))) &&
                                                                            (::builtin::spec_eq((kv.view()).used_transaction_operation_slots,
                                                                                    ::builtin::spec_literal_nat("0")))) &&
                                                                    (::builtin::spec_eq((kv.view()).pm_constants,
                                                                            pm.constants()))) &&
                                                            (::builtin::spec_eq((kv.view()).durable, state.kv))) &&
                                                    (::builtin::spec_eq((kv.view()).tentative, state.kv))
                                            }
                                            Err(KvError::CRCMismatch) =>
                                                !pm.constants().impervious_to_corruption(),
                                            Err(KvError::WrongKvStoreId { requested_id, actual_id }) =>
                                                {
                                                (::builtin::spec_eq(requested_id, kvstore_id)) &&
                                                    (::builtin::spec_eq(actual_id, state.ps.kvstore_id))
                                            }
                                            Err(KvError::KeySizeTooSmall) =>
                                                ::builtin::spec_eq(K::spec_size_of(),
                                                    ::builtin::spec_literal_nat("0")),
                                            Err(_) => false,
                                        }
                                    })]);
                let (mut powerpm, _) = PoWERPersistentMemoryRegion::new(pm);
                powerpm.flush();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        UntrustedKvStoreImpl::<TrustedKvPermissionFactory, PM, K, I,
                                    L>::recover((powerpm.view()).durable_state).unwrap()
                };
                #[verus::internal(spec)]
                let mut state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_state = verus_tmp;
                    state = verus_tmp_state;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ::builtin::closure_to_fn_spec(|s1: Seq<u8>, s2: Seq<u8>|
                                {
                                    ::builtin::spec_eq(UntrustedKvStoreImpl::<TrustedKvPermissionFactory,
                                                PM, K, I, L>::recover(s1),
                                        UntrustedKvStoreImpl::<TrustedKvPermissionFactory, PM, K, I,
                                                L>::recover(s2))
                                })
                };
                #[verus::internal(spec)]
                let mut is_transition_allowable;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_is_transition_allowable:
                            ::builtin::FnSpec<(Seq<u8>, Seq<u8>), bool> = verus_tmp;
                    is_transition_allowable = verus_tmp_is_transition_allowable;
                };
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        TrustedKvPermissionFactory {
                            is_transition_allowable,
                            powerpm_id: powerpm.id(),
                        }
                };
                #[verus::internal(infer_mode)]
                let mut perm_factory;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm_factory = verus_tmp;
                    perm_factory = verus_tmp_perm_factory;
                };
                let untrusted_kv_impl =
                    UntrustedKvStoreImpl::<TrustedKvPermissionFactory, PM, K, I,
                                L>::start(powerpm, kvstore_id,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] state),
                            #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory))?;
                Ok(Self {
                        untrusted_kv_impl,
                        powerpm_id: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] powerpm.id()),
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_item(&self, key: &K) -> Result<I, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<I, KvError>|
                        [match result {
                                    Ok(item) => {
                                        ((if let Ok(i) = ((self.view()).tentative.read_item(*key)) {
                                                        ::builtin::spec_eq(item, i)
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.read_item(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);
                self.untrusted_kv_impl.read_item(key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_create(&mut self, key: &K, item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.create(*key, *item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.create(*key, *item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_create(key, item)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_update_item(&mut self, key: &K, item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.update_item(*key, *item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.update_item(*key, *item)) {
                                                                ::builtin::spec_eq(e_spec, e)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_update_item(key, item)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_delete(&mut self, key: &K)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.delete(*key)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.delete(*key)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_delete(key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn abort(&mut self) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) =>
                                        ::builtin::spec_eq((self.view()),
                                            (old(self).view()).abort()),
                                    Err(_) => false,
                                }]);
                self.untrusted_kv_impl.abort()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn commit(&mut self) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) =>
                                        ::builtin::spec_eq((self.view()),
                                            (old(self).view()).commit()),
                                    Err(_) => false,
                                }]);
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ::builtin::closure_to_fn_spec(|s1: Seq<u8>, s2: Seq<u8>|
                                {
                                    (::builtin::spec_eq(UntrustedKvStoreImpl::<TrustedKvPermissionFactory,
                                                        PM, K, I, L>::recover(s1),
                                                Some(RecoveredKvStore::<K, I,
                                                        L> { ps: (self.view()).ps, kv: (self.view()).durable }))) &&
                                        (::builtin::spec_eq(UntrustedKvStoreImpl::<TrustedKvPermissionFactory,
                                                        PM, K, I, L>::recover(s2),
                                                Some(RecoveredKvStore::<K, I,
                                                        L> { ps: (self.view()).ps, kv: (self.view()).tentative })))
                                })
                };
                #[verus::internal(spec)]
                let mut is_transition_allowable;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_is_transition_allowable:
                            ::builtin::FnSpec<(Seq<u8>, Seq<u8>), bool> = verus_tmp;
                    is_transition_allowable = verus_tmp_is_transition_allowable;
                };
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        TrustedKvPermission {
                            is_transition_allowable,
                            powerpm_id: (self.powerpm_id.view()),
                        }
                };
                #[verus::internal(infer_mode)]
                let mut perm;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_perm = verus_tmp;
                    perm = verus_tmp_perm;
                };
                self.untrusted_kv_impl.commit::<TrustedKvPermission>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_keys(&self) -> Result<Vec<K>, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<Vec<K>, KvError>|
                        [match result {
                                    Ok(keys) => {
                                        (::builtin::spec_eq((keys.view()).to_set(),
                                                    (self.view()).tentative.get_keys())) &&
                                            ((keys.view()).no_duplicates())
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(_) => false,
                                }]);
                self.untrusted_kv_impl.get_keys()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_item_and_list(&self, key: &K)
                -> Result<(I, Vec<L>), KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<(I, Vec<L>), KvError>|
                        [match result {
                                    Ok((item, lst)) => {
                                        ((if let Ok((i, l)) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        (::builtin::spec_eq(item, i)) &&
                                                            (::builtin::spec_eq((lst.view()), l))
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);
                self.untrusted_kv_impl.read_item_and_list(key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_list(&self, key: &K) -> Result<Vec<L>, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<Vec<L>, KvError>|
                        [match result {
                                    Ok(lst) => {
                                        ((if let Ok((i, l)) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        ::builtin::spec_eq((lst.view()), l)
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        !(self.view()).pm_constants.impervious_to_corruption()
                                    }
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.read_item_and_list(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);
                self.untrusted_kv_impl.read_list(key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_list_length(&self, key: &K) -> Result<usize, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<usize, KvError>|
                        [match result {
                                    Ok(num_elements) => {
                                        ((if let Ok(n) =
                                                            ((self.view()).tentative.get_list_length(*key)) {
                                                        ::builtin::spec_eq(num_elements, n)
                                                    } else { false }))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        !(self.view()).pm_constants.impervious_to_corruption()
                                    }
                                    Err(e) => {
                                        ((if let Err(e_spec) =
                                                            ((self.view()).tentative.get_list_length(*key)) {
                                                        ::builtin::spec_eq(e, e_spec)
                                                    } else { false }))
                                    }
                                }]);
                self.untrusted_kv_impl.get_list_length(key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_append_to_list(&mut self, key: &K,
                new_list_element: L) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.append_to_list(*key,
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.append_to_list(*key,
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_append_to_list(key,
                    new_list_element)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_append_to_list_and_update_item(&mut self,
                key: &K, new_list_element: L, new_item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.append_to_list_and_update_item(*key,
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.append_to_list_and_update_item(*key,
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_append_to_list_and_update_item(key,
                    new_list_element, new_item)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_update_list_element_at_index(&mut self,
                key: &K, idx: usize, new_list_element: L)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_update_list_element_at_index(key,
                    idx, new_list_element)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_update_list_element_at_index_and_item(&mut self,
                key: &K, idx: usize, new_list_element: L, new_item: &I)
                -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_list_element_slots: ((old(self).view()).used_list_element_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index_and_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    ((((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                                ||
                                                                (((old(self).view()).used_list_element_slots).spec_ge((old(self).view()).ps.max_list_elements)))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.update_list_element_at_index_and_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(idx),
                                                                            new_list_element, *new_item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_update_list_element_at_index_and_item(key,
                    idx, new_list_element, new_item)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_trim_list(&mut self, key: &K,
                trim_length: usize) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.trim_list(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length))) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.trim_list(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length))) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_trim_list(key, trim_length)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn tentatively_trim_list_and_update_item(&mut self, key: &K,
                trim_length: usize, new_item: &I) -> Result<(), KvError> {
                ::builtin::requires([old(self).valid()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [self.valid(),
                                match result {
                                    Ok(()) => {
                                        (::builtin::spec_eq((self.view()),
                                                    KvStoreView {
                                                        tentative: (self.view()).tentative,
                                                        used_key_slots: ((old(self).view()).used_key_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        used_transaction_operation_slots: ((old(self).view()).used_transaction_operation_slots).spec_add(::builtin::spec_literal_nat("1")),
                                                        ..(old(self).view())
                                                    })) &&
                                            (((if let Ok(new_self) =
                                                                    ((old(self).view()).tentative.trim_list_and_update_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length),
                                                                            *new_item)) {
                                                                ::builtin::spec_eq((self.view()).tentative, new_self)
                                                            } else { false })))
                                    }
                                    Err(KvError::CRCMismatch) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            (!(self.view()).pm_constants.impervious_to_corruption())
                                    }
                                    Err(KvError::OutOfSpace) => {
                                        (::builtin::spec_eq((self.view()),
                                                    (old(self).view()).abort())) &&
                                            ({
                                                    (((old(self).view()).used_key_slots).spec_ge((old(self).view()).ps.max_keys))
                                                        ||
                                                        (((old(self).view()).used_transaction_operation_slots).spec_ge((old(self).view()).ps.max_operations_per_transaction))
                                                })
                                    }
                                    Err(e) => {
                                        (::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                            (((if let Err(e_spec) =
                                                                    ((old(self).view()).tentative.trim_list_and_update_item(*key,
                                                                            ::builtin::spec_cast_integer::<_, nat>(trim_length),
                                                                            *new_item)) {
                                                                ::builtin::spec_eq(e, e_spec)
                                                            } else { false })))
                                    }
                                }]);
                self.untrusted_kv_impl.tentatively_trim_list_and_update_item(key,
                    trim_length, new_item)
            }
        }
    }
    pub mod impl_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::align_v::*;
        use crate::journal::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use super::items::*;
        use super::keys::*;
        use super::lists::*;
        use super::recover_v::*;
        use super::spec_t::*;
        use std::hash::Hash;
        #[verus::internal(verus_macro)]
        pub(super) enum KvStoreStatus {
            Quiescent,
            MustAbort,
            ComponentsDontCorrespond,
        }
        #[verifier::reject_recursive_types(K)]
        #[verifier::reject_recursive_types(I)]
        #[verifier::reject_recursive_types(L)]
        #[verus::internal(verus_macro)]
        pub(super) struct UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + std::fmt::Debug,
            I: PmCopy + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            pub(super) status: Ghost<KvStoreStatus>,
            pub(super) sm: Ghost<KvStaticMetadata>,
            pub(super) used_key_slots: Ghost<int>,
            pub(super) used_list_element_slots: Ghost<int>,
            pub(super) used_transaction_operation_slots: Ghost<int>,
            pub(super) journal: Journal<PM>,
            pub(super) keys: KeyTable<PM, K>,
            pub(super) items: ItemTable<PM, I>,
            pub(super) lists: ListTable<PM, L>,
            pub(super) perm_factory: Tracked<PermFactory>,
        }
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L> View for
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            type V = KvStoreView<K, I, L>;
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn view(&self) -> KvStoreView<K, I, L> {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                KvStoreView {
                    ps: (self.sm.view()).setup_parameters().unwrap(),
                    used_key_slots: (self.used_key_slots.view()),
                    used_list_element_slots: (self.used_list_element_slots.view()),
                    used_transaction_operation_slots: (self.used_transaction_operation_slots.view()),
                    pm_constants: (self.journal.view()).pm_constants,
                    durable: combine_component_snapshots((self.lists.view()).logical_range_gaps_policy,
                        (self.keys.view()).durable, (self.items.view()).durable,
                        (self.lists.view()).durable),
                    tentative: combine_component_snapshots((self.lists.view()).logical_range_gaps_policy,
                        (self.keys.view()).tentative.unwrap(),
                        (self.items.view()).tentative.unwrap(),
                        (self.lists.view()).tentative.unwrap()),
                    powerpm_id: (self.journal.view()).powerpm_id,
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn pm_constants(self) -> PersistentMemoryConstants {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                (self.journal.view()).pm_constants
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn recover(bytes: Seq<u8>)
                -> Option<RecoveredKvStore<K, I, L>> {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                recover_journal_then_kv::<PM, K, I, L>(bytes)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                (::builtin::is_variant((self.status.view()), "Quiescent")) &&
                    (self.inv())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn spec_space_needed_for_setup(ps: SetupParameters) -> nat {
                #[verus::internal(open_visibility_qualifier)]
                pub(super) use crate as _;
                ::builtin::recommends([ps.valid()]);
                let journal_capacity =
                    ::builtin::spec_cast_integer::<_,
                            nat>(((ps.max_operations_per_transaction).spec_mul(spec_space_needed_for_transaction_operation())));
                let journal_end =
                    Journal::<PM>::spec_space_needed_for_setup(journal_capacity);
                let sm_start =
                    round_up_to_alignment(::builtin::spec_cast_integer::<_,
                                int>(journal_end),
                        ::builtin::spec_cast_integer::<_,
                                int>(KvStaticMetadata::spec_align_of()));
                let sm_end =
                    (sm_start).spec_add(KvStaticMetadata::spec_size_of());
                let sm_crc_end = (sm_end).spec_add(u64::spec_size_of());
                let key_table_end =
                    (sm_crc_end).spec_add(KeyTable::<PM,
                                K>::spec_space_needed_for_setup(ps,
                            ::builtin::spec_cast_integer::<_, nat>(sm_crc_end)));
                let item_table_end =
                    (key_table_end).spec_add(ItemTable::<PM,
                                I>::spec_space_needed_for_setup(ps,
                            ::builtin::spec_cast_integer::<_, nat>(key_table_end)));
                let list_table_end =
                    (item_table_end).spec_add(ListTable::<PM,
                                L>::spec_space_needed_for_setup(ps,
                            ::builtin::spec_cast_integer::<_, nat>(item_table_end)));
                ::builtin::spec_cast_integer::<_, nat>(list_table_end)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_keys(&self) -> Result<Vec<K>, KvError> {
                ::builtin::requires([self.valid()]);
                ::builtin::ensures(|result: Result<Vec<K>, KvError>|
                        [match result {
                                    Ok(keys) => {
                                        (::builtin::spec_eq((keys.view()).to_set(),
                                                    (self.view()).tentative.get_keys())) &&
                                            ((keys.view()).no_duplicates())
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !(self.view()).pm_constants.impervious_to_corruption(),
                                    Err(_) => false,
                                }]);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal((self.view()).tentative.get_keys(),
                                    (self.keys.view()).tentative.unwrap().key_info.dom()))
                        };
                };
                Ok(self.keys.get_keys(&self.journal))
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_space_needed_for_transaction_operation() -> nat {
            #[verus::internal(open_visibility_qualifier)]
            pub(super) use crate as _;
            ((((((spec_journal_entry_overhead()).spec_add(spec_journal_entry_overhead())).spec_add(spec_journal_entry_overhead())).spec_add(KeyTableRowMetadata::spec_size_of())).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of())
        }
    }
    pub mod inv_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::journal::JournalView;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::traits_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::recover_v::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_journal_ok(self) -> bool {
                (((((((self.journal.valid()) &&
                                                                    ((self.journal.view()).valid())) &&
                                                            (self.journal.recover_idempotent())) &&
                                                    (::builtin::spec_eq((self.journal.view()).constants.app_program_guid,
                                                            KVSTORE_PROGRAM_GUID))) &&
                                            (::builtin::spec_eq((self.journal.view()).constants.app_version_number,
                                                    KVSTORE_PROGRAM_VERSION_NUMBER))) &&
                                    (((self.journal.view()).constants.journal_capacity).spec_ge(((self.sm.view()).max_operations_per_transaction).spec_mul(spec_space_needed_for_transaction_operation()))))
                            &&
                            (::builtin::imply(::builtin::is_variant((self.status.view()),
                                        "Quiescent"),
                                    ((self.journal.view()).remaining_capacity).spec_ge(((((self.sm.view()).max_operations_per_transaction).spec_sub((self.used_transaction_operation_slots.view())))).spec_mul(spec_space_needed_for_transaction_operation())))))
                    &&
                    (validate_static_metadata::<K, I,
                                L>((self.sm.view()), (self.journal.view()).constants))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_static_metadata_matches(self) -> bool {
                ((::builtin::spec_eq(recover_static_metadata::<K, I,
                                            L>((self.journal.view()).durable_state,
                                        (self.journal.view()).constants), Some((self.sm.view()))))
                            &&
                            (states_match_in_static_metadata_area((self.journal.view()).durable_state,
                                    (self.journal.view()).read_state,
                                    (self.journal.view()).constants))) &&
                    (states_match_in_static_metadata_area((self.journal.view()).durable_state,
                            (self.journal.view()).commit_state,
                            (self.journal.view()).constants))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_tentative_components_exist(self) -> bool {
                ::builtin::imply(!(::builtin::is_variant((self.status.view()),
                                "MustAbort")),
                    {
                        ((::builtin::is_variant((self.keys.view()).tentative,
                                            "Some")) &&
                                    (::builtin::is_variant((self.items.view()).tentative,
                                            "Some"))) &&
                            (::builtin::is_variant((self.lists.view()).tentative,
                                    "Some"))
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_components_valid(self) -> bool {
                (((((::builtin::spec_eq((self.keys.view()).sm,
                                                            (self.sm.view()).keys)) &&
                                                    (::builtin::spec_eq((self.items.view()).sm,
                                                            (self.sm.view()).items))) &&
                                            (::builtin::spec_eq((self.lists.view()).sm,
                                                    (self.sm.view()).lists))) &&
                                    (self.keys.valid((self.journal.view())))) &&
                            (self.items.valid((self.journal.view())))) &&
                    (self.lists.valid((self.journal.view())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_components_correspond(self) -> bool {
                ::builtin::recommends([self.inv_tentative_components_exist()]);
                ((::builtin::spec_eq((self.keys.view()).durable.item_addrs(),
                                    (self.items.view()).durable.m.dom())) &&
                            (::builtin::spec_eq((self.keys.view()).durable.list_addrs(),
                                    (self.lists.view()).durable.m.dom()))) &&
                    (::builtin::imply(::builtin::is_variant((self.status.view()),
                                "Quiescent"),
                            {
                                let tentative_keys = (self.keys.view()).tentative.unwrap();
                                let tentative_items =
                                    (self.items.view()).tentative.unwrap();
                                let tentative_lists =
                                    (self.lists.view()).tentative.unwrap();
                                (::builtin::spec_eq(tentative_keys.item_addrs(),
                                            tentative_items.m.dom())) &&
                                    (::builtin::spec_eq(tentative_keys.list_addrs(),
                                            tentative_lists.m.dom()))
                            }))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_components_finite(self) -> bool {
                (((self.keys.view()).durable.key_info.dom().finite()) &&
                            ((self.items.view()).durable.m.dom().finite())) &&
                    ((self.lists.view()).durable.m.dom().finite())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_used_slots_correspond(self) -> bool {
                ::builtin::imply(::builtin::is_variant((self.status.view()),
                        "Quiescent"),
                    {
                        ((((self.used_key_slots.view())).spec_ge((self.keys.view()).used_slots))
                                    &&
                                    (((self.used_key_slots.view())).spec_ge((self.items.view()).used_slots)))
                            &&
                            (((self.used_list_element_slots.view())).spec_ge((self.lists.view()).used_slots))
                    })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv_perm_factory_allows_recovery_idempotent_changes(self)
                -> bool {
                (::builtin::spec_eq((self.perm_factory.view()).id(),
                            (self.view()).powerpm_id)) &&
                    (::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                ::builtin::imply(::builtin::spec_eq(Self::recover(s1),
                                        Self::recover(s2)),
                                    #[verus::internal(trigger)] (self.perm_factory.view()).check_permission(s1,
                                        s2))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn inv(self) -> bool {
                (((((((((self.inv_journal_ok()) &&
                                                                                    ((self.sm.view()).valid::<K, I, L>())) &&
                                                                            (self.inv_static_metadata_matches())) &&
                                                                    (self.inv_tentative_components_exist())) &&
                                                            (self.inv_components_valid())) &&
                                                    (self.inv_components_correspond())) &&
                                            (self.inv_components_finite())) &&
                                    (self.inv_used_slots_correspond())) &&
                            (self.inv_perm_factory_allows_recovery_idempotent_changes()))
                    &&
                    (::builtin::spec_eq(decode_policies((self.sm.view()).encoded_policies),
                            Some((self.lists.view()).logical_range_gaps_policy)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_recover_static_metadata_depends_only_on_my_area(&self,
                old_jv: JournalView, new_jv: JournalView) {
                ::builtin::requires([::builtin::spec_eq(old_jv.constants,
                                new_jv.constants),
                            validate_static_metadata::<K, I,
                                    L>((self.sm.view()), old_jv.constants),
                            ::builtin::spec_eq(recover_static_metadata::<K, I,
                                        L>(old_jv.durable_state, old_jv.constants),
                                Some((self.sm.view()))),
                            states_match_in_static_metadata_area(old_jv.durable_state,
                                old_jv.read_state, old_jv.constants),
                            states_match_in_static_metadata_area(old_jv.durable_state,
                                old_jv.commit_state, old_jv.constants),
                            old_jv.matches_in_range(new_jv,
                                ::builtin::spec_cast_integer::<_,
                                        int>(old_jv.constants.app_area_start),
                                ((old_jv.constants.app_area_start).spec_add(KvStaticMetadata::spec_size_of())).spec_add(u64::spec_size_of()))]);
                ::builtin::ensures([::builtin::spec_eq(recover_static_metadata::<K,
                                        I, L>(new_jv.durable_state, new_jv.constants),
                                Some((self.sm.view()))),
                            states_match_in_static_metadata_area(new_jv.durable_state,
                                new_jv.read_state, new_jv.constants),
                            states_match_in_static_metadata_area(new_jv.durable_state,
                                new_jv.commit_state, new_jv.constants)]);
                lemma_recover_static_metadata_depends_only_on_its_area::<K, I,
                        L>(old_jv.durable_state, new_jv.durable_state,
                    old_jv.constants);
            }
        }
    }
    pub mod items {
        mod abort_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::spec_v::*;
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ItemTableStatus { Quiescent, }
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn abort(&mut self,
                    verus_tmp_jv_before_abort: Ghost<JournalView>,
                    verus_tmp_jv_after_abort: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_before_abort;

                    #[verifier::proof_block]
                    { jv_before_abort = verus_tmp_jv_before_abort.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_after_abort;

                    #[verifier::proof_block]
                    { jv_after_abort = verus_tmp_jv_after_abort.view() };
                    ::builtin::requires([old(self).valid(jv_before_abort),
                                jv_before_abort.valid(), jv_after_abort.valid(),
                                ::builtin::spec_eq(jv_after_abort, jv_before_abort.abort()),
                                ::builtin::spec_eq(jv_before_abort.durable_state,
                                    jv_before_abort.read_state)]);
                    ::builtin::ensures([self.valid(jv_after_abort),
                                ::builtin::spec_eq((self.view()),
                                    (ItemTableView {
                                            tentative: Some((old(self).view()).durable),
                                            used_slots: (self.view()).used_slots,
                                            ..(old(self).view())
                                        })), (self.view()).durable.m.dom().finite(),
                                ::builtin::spec_eq((self.view()).used_slots,
                                    (self.view()).durable.m.dom().len())]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            Map::<u64,
                                    ItemRowDisposition<I>>::new(::builtin::closure_to_fn_spec(|row_addr:
                                            u64| (self.row_info.view()).contains_key(row_addr)),
                                ::builtin::closure_to_fn_spec(|row_addr: u64|
                                        match (self.row_info.view()).spec_index(row_addr) {
                                            ItemRowDisposition::<I>::InPendingAllocationList { pos, item
                                                } =>
                                                ItemRowDisposition::<I>::InFreeList {
                                                    pos: ((self.free_list.view()).len()).spec_add(pos),
                                                },
                                            ItemRowDisposition::<I>::InPendingDeallocationList {
                                                pos, item } =>
                                                ItemRowDisposition::<I>::NowhereFree { item },
                                            ItemRowDisposition::<I>::InBothPendingLists {
                                                alloc_pos, dealloc_pos, item } =>
                                                ItemRowDisposition::<I>::InFreeList {
                                                    pos: ((self.free_list.view()).len()).spec_add(alloc_pos),
                                                },
                                            _ => (self.row_info.view()).spec_index(row_addr),
                                        }))
                    };
                    #[verus::internal(spec)]
                    let mut new_row_info;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_row_info = verus_tmp;
                        new_row_info = verus_tmp_new_row_info;
                    };
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_row_info);
                    self.free_list.append(&mut self.pending_allocations);
                    self.pending_deallocations.clear();
                    self.must_abort =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] false);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid(jv_after_abort)) };
                    };

                    #[verifier::proof_block]
                    {
                        self.internal_view().lemma_corresponds_implication_for_free_list_length(self.sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()),
                                        (ItemTableView {
                                                tentative: Some((old(self).view()).durable),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })))
                            };
                    };
                }
            }
        }
        mod commit_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::spec_v::*;
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ItemTableStatus { Quiescent, }
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn commit(&mut self,
                    verus_tmp_jv_before_commit: Ghost<JournalView>,
                    verus_tmp_jv_after_commit: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_before_commit;

                    #[verifier::proof_block]
                    { jv_before_commit = verus_tmp_jv_before_commit.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_after_commit;

                    #[verifier::proof_block]
                    { jv_after_commit = verus_tmp_jv_after_commit.view() };
                    ::builtin::requires([old(self).valid(jv_before_commit),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                jv_before_commit.valid(), jv_after_commit.valid(),
                                jv_after_commit.committed_from(jv_before_commit)]);
                    ::builtin::ensures([self.valid(jv_after_commit),
                                ::builtin::spec_eq((self.view()),
                                    (ItemTableView {
                                            durable: (old(self).view()).tentative.unwrap(),
                                            used_slots: (self.view()).used_slots,
                                            ..(old(self).view())
                                        })), (self.view()).durable.m.dom().finite(),
                                ::builtin::spec_eq((self.view()).used_slots,
                                    (self.view()).durable.m.dom().len())]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            Map::<u64,
                                    ItemRowDisposition<I>>::new(::builtin::closure_to_fn_spec(|row_addr:
                                            u64| (self.row_info.view()).contains_key(row_addr)),
                                ::builtin::closure_to_fn_spec(|row_addr: u64|
                                        match (self.row_info.view()).spec_index(row_addr) {
                                            ItemRowDisposition::<I>::InPendingAllocationList { pos, item
                                                } => ItemRowDisposition::<I>::NowhereFree { item },
                                            ItemRowDisposition::<I>::InPendingDeallocationList {
                                                pos, item } =>
                                                ItemRowDisposition::<I>::InFreeList {
                                                    pos: ((self.free_list.view()).len()).spec_add(pos),
                                                },
                                            ItemRowDisposition::<I>::InBothPendingLists {
                                                alloc_pos, dealloc_pos, item } =>
                                                ItemRowDisposition::<I>::InFreeList {
                                                    pos: ((self.free_list.view()).len()).spec_add(dealloc_pos),
                                                },
                                            _ => (self.row_info.view()).spec_index(row_addr),
                                        }))
                    };
                    #[verus::internal(spec)]
                    let mut new_row_info;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_row_info = verus_tmp;
                        new_row_info = verus_tmp_new_row_info;
                    };
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_row_info);
                    self.free_list.append(&mut self.pending_deallocations);
                    self.pending_allocations.clear();

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid(jv_after_commit)) };
                    };

                    #[verifier::proof_block]
                    {
                        self.internal_view().lemma_corresponds_implication_for_free_list_length(self.sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()),
                                        (ItemTableView {
                                                durable: (old(self).view()).tentative.unwrap(),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })))
                            };
                    };
                }
            }
        }
        mod crud_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use crate::pmem::pmemutil_v::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn read(&self, row_addr: u64, journal: &Journal<PM>)
                    -> Result<I, KvError> {
                    ::builtin::requires([journal.valid(),
                                self.valid((journal.view())),
                                (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(row_addr)]);
                    ::builtin::ensures(|result: Result<I, KvError>|
                            [match result {
                                        Ok(item) =>
                                            ::builtin::spec_eq((self.view()).tentative.unwrap().m.spec_index(row_addr),
                                                item),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        self.lemma_valid_implications((journal.view()));
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    match exec_recover_object::<PM,
                                I>(journal.get_pm_region_ref(),
                            row_addr + self.sm.row_item_start,
                            row_addr + self.sm.row_item_crc_start) {
                        Some(item) => Ok(item),
                        None => Err(KvError::CRCMismatch),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_writing_to_free_slot_doesnt_change_recovery(iv:
                        ItemTableInternalView<I>, s1: Seq<u8>, s2: Seq<u8>,
                    sm: ItemTableStaticMetadata, free_list_pos: int,
                    row_addr: u64, start: int, end: int) {
                    ::builtin::requires([sm.valid::<I>(), iv.valid(sm),
                                iv.consistent_with_durable_state(s1, sm),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            free_list_pos), iv.free_list.len())),
                                ::builtin::spec_eq(iv.free_list.spec_index(free_list_pos),
                                    row_addr), sm.table.validate_row_addr(row_addr),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                start), end), (row_addr).spec_add(sm.table.row_size))),
                                seqs_match_except_in_range(s1, s2, start, end)]);
                    ::builtin::ensures([iv.consistent_with_durable_state(s2,
                                    sm),
                                ::builtin::spec_eq(Self::recover(s2,
                                        iv.as_durable_snapshot().m.dom(), sm),
                                    Self::recover(s1, iv.as_durable_snapshot().m.dom(), sm))]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(::builtin::ext_equal(Self::recover(s2,
                                iv.as_durable_snapshot().m.dom(), sm),
                            Self::recover(s1, iv.as_durable_snapshot().m.dom(), sm)));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_writing_to_free_slot_has_permission_later_forall<PermFactory>(iv:
                        ItemTableInternalView<I>, initial_durable_state: Seq<u8>,
                    sm: ItemTableStaticMetadata, constants: JournalConstants,
                    free_list_pos: int, row_addr: u64,
                    perm_factory: PermFactory) where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    ::builtin::requires([sm.valid::<I>(), iv.valid(sm),
                                iv.consistent_with_durable_state(initial_durable_state, sm),
                                Journal::<PM>::state_recovery_idempotent(initial_durable_state,
                                    constants),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            free_list_pos), iv.free_list.len())),
                                ::builtin::spec_eq(iv.free_list.spec_index(free_list_pos),
                                    row_addr), sm.table.validate_row_addr(row_addr),
                                (sm.table.end).spec_le(initial_durable_state.len()),
                                ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                        ::builtin::imply({
                                                (Self::state_equivalent_for_me(s1, initial_durable_state,
                                                            iv.as_durable_snapshot().m.dom(), constants, sm)) &&
                                                    (Self::state_equivalent_for_me(s2, initial_durable_state,
                                                            iv.as_durable_snapshot().m.dom(), constants, sm))
                                            },
                                            #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                s2)))]);
                    ::builtin::ensures([::builtin::forall(|current_durable_state:
                                            Seq<u8>, s: Seq<u8>, start: int, end: int|
                                        ::builtin::imply({
                                                ((((#[verus::internal(trigger)] seqs_match_except_in_range(current_durable_state,
                                                                                    s, start, end)) &&
                                                                            (Self::state_equivalent_for_me(current_durable_state,
                                                                                    initial_durable_state, iv.as_durable_snapshot().m.dom(),
                                                                                    constants, sm))) &&
                                                                    (iv.consistent_with_durable_state(current_durable_state,
                                                                            sm))) &&
                                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                                                start), end), (row_addr).spec_add(sm.table.row_size))))) &&
                                                    (Journal::<PM>::state_recovery_idempotent(s, constants))
                                            },
                                            {
                                                ((Self::state_equivalent_for_me(s, initial_durable_state,
                                                                    iv.as_durable_snapshot().m.dom(), constants, sm)) &&
                                                            (iv.consistent_with_durable_state(s, sm))) &&
                                                    (perm_factory.check_permission(current_durable_state, s))
                                            }))]);
                    let item_addrs = iv.as_durable_snapshot().m.dom();
                    {
                        ::builtin::assert_forall_by(|current_durable_state: Seq<u8>,
                                s: Seq<u8>, start: int, end: int|
                                {
                                    ::builtin::requires({
                                            ((((#[verus::internal(trigger)] seqs_match_except_in_range(current_durable_state,
                                                                                s, start, end)) &&
                                                                        (Self::state_equivalent_for_me(current_durable_state,
                                                                                initial_durable_state, item_addrs, constants, sm))) &&
                                                                (iv.consistent_with_durable_state(current_durable_state,
                                                                        sm))) &&
                                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                                            start), end), (row_addr).spec_add(sm.table.row_size))))) &&
                                                (Journal::<PM>::state_recovery_idempotent(s, constants))
                                        });
                                    ::builtin::ensures({
                                            ((Self::state_equivalent_for_me(s, initial_durable_state,
                                                                item_addrs, constants, sm)) &&
                                                        (iv.consistent_with_durable_state(s, sm))) &&
                                                (perm_factory.check_permission(current_durable_state, s))
                                        });
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    Self::lemma_writing_to_free_slot_doesnt_change_recovery(iv,
                                        current_durable_state, s, sm, free_list_pos, row_addr,
                                        start, end);
                                });
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn create<PermFactory>(&mut self, item: &I,
                    journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<u64, KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                (old(self).view()).tentative.is_some(),
                                old(journal).valid(),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    ::builtin::spec_eq((journal.view()).remaining_capacity,
                                        (old(journal).view()).remaining_capacity),
                                    match result {
                                        Ok(row_addr) => {
                                            (((::builtin::spec_eq((self.view()),
                                                                        (ItemTableView {
                                                                                tentative: Some((old(self).view()).tentative.unwrap().create(row_addr,
                                                                                        *item)),
                                                                                used_slots: (self.view()).used_slots,
                                                                                ..(old(self).view())
                                                                            }))) &&
                                                                (((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                        &&
                                                        (!(old(self).view()).tentative.unwrap().m.contains_key(row_addr)))
                                                && (self.validate_item_addr(row_addr))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (ItemTableView { tentative: None, ..(old(self).view()) })))
                                                &&
                                                (::builtin::spec_eq((self.view()).used_slots,
                                                        (self.view()).sm.num_rows()))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        self.lemma_valid_implications((journal.view()));
                        if ((self.free_list.view()).len()).spec_gt(::builtin::spec_literal_nat("0"))
                                {
                                Self::lemma_writing_to_free_slot_has_permission_later_forall(self.internal_view(),
                                    (journal.view()).durable_state, self.sm,
                                    (journal.view()).constants,
                                    ((self.free_list.view()).len()).spec_sub(::builtin::spec_literal_nat("1")),
                                    (self.free_list.view()).last(), *perm_factory);
                            }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let row_addr =
                        match self.free_list.pop() {
                            None => {
                                self.must_abort =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                                return Err(KvError::OutOfSpace);
                            }
                            Some(a) => a,
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((old(self).free_list.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                    int>((self.free_list.view()).len())), row_addr))
                            };
                    };
                    let item_addr = row_addr + self.sm.row_item_start;
                    let item_crc_addr = row_addr + self.sm.row_item_crc_start;
                    let item_crc = calculate_crc(item);
                    journal.write_object::<I,
                        PermFactory::Perm>(item_addr, &item,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    journal.write_object::<u64,
                        PermFactory::Perm>(item_crc_addr, &item_crc,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ItemRowDisposition::InPendingAllocationList {
                                pos: ::builtin::spec_cast_integer::<_,
                                        nat>(self.pending_allocations.len()),
                                item: *item,
                            }
                    };
                    #[verus::internal(spec)]
                    let mut disposition;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_disposition = verus_tmp;
                        disposition = verus_tmp_disposition;
                    };
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.row_info.view()).insert(row_addr,
                                disposition));
                    self.pending_allocations.push(row_addr);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()).durable,
                                        (old(self).view()).durable))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                        Some((old(self).view()).tentative.unwrap().create(row_addr,
                                                *item))))
                            };
                    };
                    Ok(row_addr)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn delete(&mut self, row_addr: u64,
                    journal: &Journal<PM>) {
                    ::builtin::requires([old(self).valid((journal.view())),
                                journal.valid(), (old(self).view()).tentative.is_some(),
                                (old(self).view()).tentative.unwrap().m.contains_key(row_addr)]);
                    ::builtin::ensures([self.valid((journal.view())),
                                ::builtin::spec_eq((self.view()),
                                    (ItemTableView {
                                            tentative: Some((old(self).view()).tentative.unwrap().delete(row_addr)),
                                            ..(old(self).view())
                                        }))]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ::builtin::spec_cast_integer::<_,
                                    nat>((self.pending_deallocations.view()).len())
                    };
                    #[verus::internal(spec)]
                    let mut new_pos;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_pos = verus_tmp;
                        new_pos = verus_tmp_new_pos;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            match (self.row_info.view()).spec_index(row_addr) {
                                ItemRowDisposition::NowhereFree { item } =>
                                    ItemRowDisposition::InPendingDeallocationList {
                                        pos: new_pos,
                                        item,
                                    },
                                ItemRowDisposition::InPendingAllocationList { pos, item } =>
                                    ItemRowDisposition::InBothPendingLists {
                                        alloc_pos: pos,
                                        dealloc_pos: new_pos,
                                        item,
                                    },
                                _ => { ::builtin::assert_(false); arbitrary() }
                            }
                    };
                    #[verus::internal(spec)]
                    let mut disposition;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_disposition = verus_tmp;
                        disposition = verus_tmp_disposition;
                    };
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.row_info.view()).insert(row_addr,
                                disposition));
                    self.pending_deallocations.push(row_addr);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()).durable,
                                        (old(self).view()).durable))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                        Some((old(self).view()).tentative.unwrap().delete(row_addr))))
                            };
                    };
                }
            }
        }
        mod impl_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::align_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use deps_hack::PmCopy;
            use super::inv_v::*;
            use super::spec_v::*;
            use super::recover_v::*;
            use super::super::spec_t::*;
            #[repr(C)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct ItemTableStaticMetadata {
                pub(super) table: TableMetadata,
                pub(super) item_size: u64,
                pub(super) row_item_start: u64,
                pub(super) row_item_end: u64,
                pub(super) row_item_crc_start: u64,
            }
            unsafe impl pmcopy for ItemTableStaticMetadata where
                TableMetadata: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy,
                u64: pmcopy {}
            #[verus::internal(verus_macro)]
            impl SpecPmSized for ItemTableStaticMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_size_of() -> ::builtin::nat {
                    let offset: ::builtin::nat =
                        ::builtin::spec_literal_integer("0");
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<TableMetadata>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <TableMetadata>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        (offset).spec_add(spec_padding_needed(offset,
                                <ItemTableStaticMetadata>::spec_align_of()));
                    offset
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_align_of() -> ::builtin::nat {
                    let alignment_seq =
                        <_ as
                                ::vstd::vstd::view::View>::view(&[<TableMetadata>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of()]);
                    nat_seq_max(alignment_seq)
                }
            }
            unsafe impl PmSized for ItemTableStaticMetadata {
                fn size_of() -> usize { Self::SIZE }
                fn align_of() -> usize { Self::ALIGN }
            }
            unsafe impl ConstPmSized for ItemTableStaticMetadata {
                const SIZE: usize =
                    {
                        let offset: usize = 0;
                        let offset: usize =
                            offset + <TableMetadata>::SIZE +
                                padding_needed(offset, <TableMetadata>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset +
                                padding_needed(offset, <ItemTableStaticMetadata>::ALIGN);
                        offset
                    };
                const ALIGN: usize =
                    {
                        let mut largest_alignment: usize = 0;
                        if largest_alignment <= <TableMetadata>::ALIGN {
                                largest_alignment = <TableMetadata>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        largest_alignment
                    };
            }
            const SIZE_CHECK_ITEMTABLESTATICMETADATA: usize =
                (core::mem::size_of::<ItemTableStaticMetadata>() ==
                                <ItemTableStaticMetadata>::SIZE) as usize - 1;
            const ALIGN_CHECK_ITEMTABLESTATICMETADATA: usize =
                (core::mem::align_of::<ItemTableStaticMetadata>() ==
                                <ItemTableStaticMetadata>::ALIGN) as usize - 1;
            unsafe impl UnsafeSpecPmSized for ItemTableStaticMetadata {}
            impl Clone for ItemTableStaticMetadata {
                fn clone(&self) -> Self {
                    Self {
                        table: self.table.clone(),
                        item_size: self.item_size.clone(),
                        row_item_start: self.row_item_start.clone(),
                        row_item_end: self.row_item_end.clone(),
                        row_item_crc_start: self.row_item_crc_start.clone(),
                    }
                }
            }
            impl PartialEq for ItemTableStaticMetadata {
                fn eq(&self, other: &Self) -> bool {
                    self.table == other.table &&
                                    self.item_size == other.item_size &&
                                self.row_item_start == other.row_item_start &&
                            self.row_item_end == other.row_item_end &&
                        self.row_item_crc_start == other.row_item_crc_start
                }
            }
            impl Eq for ItemTableStaticMetadata {}
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_itemtablestaticmetadata_clone(b:
                    &ItemTableStaticMetadata) -> ItemTableStaticMetadata {
                ::builtin::ensures(|res: ItemTableStaticMetadata|
                        [::builtin::spec_eq(*b, res)]);
                b.clone()
            }
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_itemtablestaticmetadata_eq(lhs:
                    &ItemTableStaticMetadata, rhs: &ItemTableStaticMetadata)
                -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
                lhs.eq(rhs)
            }
            #[verus::internal(verus_macro)]
            impl CloneProof for ItemTableStaticMetadata {
                #[verus::internal(verus_macro)]
                fn clone_provable(&self) -> ItemTableStaticMetadata {
                    ::builtin::ensures(|res: ItemTableStaticMetadata|
                            [::builtin::spec_eq(*self, res)]);
                    self.clone()
                }
            }
            #[verus::internal(verus_macro)]
            impl EqProof for ItemTableStaticMetadata {
                #[verus::internal(verus_macro)]
                fn eq_provable(&self, other: &Self) -> bool {
                    ::builtin::ensures(|b: bool|
                            [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                    self.eq(other)
                }
            }
            impl PmCopy for ItemTableStaticMetadata {}
            #[automatically_derived]
            impl ::core::marker::Copy for ItemTableStaticMetadata { }
            #[verus::internal(verus_macro)]
            impl ItemTableStaticMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn valid<I>(self) -> bool where I: PmCopy {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    (((((self.table.valid()) &&
                                                        ((self.table.start).spec_le(self.table.end))) &&
                                                (::builtin::spec_eq((self.row_item_end).spec_sub(self.row_item_start),
                                                        self.item_size))) &&
                                        ((self.row_item_end).spec_le(self.row_item_crc_start))) &&
                                (((self.row_item_crc_start).spec_add(u64::spec_size_of())).spec_le(self.table.row_size)))
                        && (::builtin::spec_eq(self.item_size, I::spec_size_of()))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_start(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.start
                }
                #[verifier::when_used_as_spec(spec_start)]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn start(self) -> u64 {
                    ::builtin::ensures(|result: u64|
                            [::builtin::spec_eq(result, self.spec_start())]);
                    self.table.start
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_end(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.end
                }
                #[verifier::when_used_as_spec(spec_end)]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn end(self) -> u64 {
                    ::builtin::ensures(|result: u64|
                            [::builtin::spec_eq(result, self.spec_end())]);
                    self.table.end
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn num_rows(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.num_rows
                }
            }
            #[verifier::ext_equal]
            #[verifier::reject_recursive_types(I)]
            #[verus::internal(verus_macro)]
            pub struct ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                pub(super) status: Ghost<ItemTableStatus>,
                pub(super) sm: ItemTableStaticMetadata,
                pub(super) must_abort: Ghost<bool>,
                pub(super) row_info: Ghost<Map<u64, ItemRowDisposition<I>>>,
                pub(super) free_list: Vec<u64>,
                pub(super) pending_allocations: Vec<u64>,
                pub(super) pending_deallocations: Vec<u64>,
                pub(super) phantom_pm: Ghost<core::marker::PhantomData<PM>>,
            }
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn view(&self) -> ItemTableView<I> {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    ItemTableView::<I> {
                        sm: self.sm,
                        used_slots: (self.sm.table.num_rows).spec_sub(self.free_list.len()),
                        durable: self.internal_view().as_durable_snapshot(),
                        tentative: if (self.must_abort.view()) {
                                None
                            } else {
                               Some(self.internal_view().as_tentative_snapshot())
                           },
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn valid(self, jv: JournalView) -> bool {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    (::builtin::is_variant((self.status.view()), "Quiescent"))
                        && (self.inv(jv))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn recover(s: Seq<u8>, addrs: Set<u64>,
                    sm: ItemTableStaticMetadata)
                    -> Option<ItemTableSnapshot<I>> {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    if items_recoverable::<I>(s, addrs, sm) {
                            Some(ItemTableSnapshot::<I> {
                                    m: recover_items::<I>(s, addrs, sm),
                                })
                        } else { None }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_space_needed_for_setup(ps: SetupParameters,
                    min_start: nat) -> nat {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    let row_item_end = I::spec_size_of();
                    let row_item_crc_end =
                        (row_item_end).spec_add(u64::spec_size_of());
                    let row_size = row_item_crc_end;
                    let num_rows = ps.max_keys;
                    let table_size =
                        (::builtin::spec_cast_integer::<_,
                                        int>(num_rows)).spec_mul(row_size);
                    let initial_space =
                        if (min_start).spec_gt(u64::MAX) {
                                ::builtin::spec_literal_integer("0")
                            } else {
                               space_needed_for_alignment(::builtin::spec_cast_integer::<_,
                                           int>(min_start),
                                   ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()))
                           };
                    ::builtin::spec_cast_integer::<_,
                            nat>(((initial_space).spec_add(table_size)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn validate_item_addr(&self, addr: u64) -> bool {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.sm.table.validate_row_addr(addr)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn state_equivalent_for_me(s: Seq<u8>,
                    durable_state: Seq<u8>, item_addrs: Set<u64>,
                    constants: JournalConstants, sm: ItemTableStaticMetadata)
                    -> bool {
                    ((seqs_match_except_in_range(durable_state, s,
                                        ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                        ::builtin::spec_cast_integer::<_, int>(sm.end()))) &&
                                (Journal::<PM>::state_recovery_idempotent(s, constants))) &&
                        (::builtin::spec_eq(Self::recover(s, item_addrs, sm),
                                Self::recover(durable_state, item_addrs, sm)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn perm_factory_permits_states_equivalent_for_me<PermFactory>(&self,
                    jv: JournalView, perm_factory: PermFactory) -> bool where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                            ::builtin::imply({
                                    (Self::state_equivalent_for_me(s1, jv.durable_state,
                                                (self.view()).durable.m.dom(), jv.constants,
                                                (self.view()).sm)) &&
                                        (Self::state_equivalent_for_me(s2, jv.durable_state,
                                                (self.view()).durable.m.dom(), jv.constants,
                                                (self.view()).sm))
                                },
                                #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                    s2)))
                }
            }
        }
        mod inv_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::journal::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::power_t::*;
            use super::{
                ItemTable, ItemTableSnapshot, ItemTableStaticMetadata,
            };
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ItemTableStatus { Quiescent, }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ItemRowDisposition<I> where I: PmCopy + Sized +
                std::fmt::Debug {
                NowhereFree {
                    item: I,
                },
                InFreeList {
                    pos: nat,
                },
                InPendingDeallocationList {
                    pos: nat,
                    item: I,
                },
                InPendingAllocationList {
                    pos: nat,
                    item: I,
                },
                InBothPendingLists {
                    alloc_pos: nat,
                    dealloc_pos: nat,
                    item: I,
                },
            }
            #[verus::internal(verus_macro)]
            impl<I> ItemRowDisposition<I> where I: PmCopy + Sized +
                std::fmt::Debug {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_alloc_pos(self) -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "alloc_pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_dealloc_pos(self) -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "dealloc_pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_pos(self) -> nat {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_item(self) -> I {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_NowhereFree_item(self) -> I {
                    ::builtin::get_variant_field(self, "NowhereFree", "item")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InFreeList_pos(self) -> nat {
                    ::builtin::get_variant_field(self, "InFreeList", "pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InPendingDeallocationList_pos(self)
                    -> nat {
                    ::builtin::get_variant_field(self,
                        "InPendingDeallocationList", "pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InPendingDeallocationList_item(self)
                    -> I {
                    ::builtin::get_variant_field(self,
                        "InPendingDeallocationList", "item")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InPendingAllocationList_pos(self) -> nat {
                    ::builtin::get_variant_field(self,
                        "InPendingAllocationList", "pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InPendingAllocationList_item(self) -> I {
                    ::builtin::get_variant_field(self,
                        "InPendingAllocationList", "item")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InBothPendingLists_alloc_pos(self)
                    -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "alloc_pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InBothPendingLists_dealloc_pos(self)
                    -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "dealloc_pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InBothPendingLists_item(self) -> I {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "item")
                }
            }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) struct ItemTableInternalView<I> where I: PmCopy +
                Sized + std::fmt::Debug {
                pub row_info: Map<u64, ItemRowDisposition<I>>,
                pub free_list: Seq<u64>,
                pub pending_allocations: Seq<u64>,
                pub pending_deallocations: Seq<u64>,
            }
            #[verus::internal(verus_macro)]
            impl<I> ItemTableInternalView<I> where I: PmCopy + Sized +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn complete(self, sm: ItemTableStaticMetadata)
                    -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] sm.table.validate_row_addr(row_addr),
                                self.row_info.contains_key(row_addr)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn row_info_consistent(self,
                    sm: ItemTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                {
                                    (sm.table.validate_row_addr(row_addr)) &&
                                        (match self.row_info.spec_index(row_addr) {
                                                ItemRowDisposition::NowhereFree { item } => true,
                                                ItemRowDisposition::InFreeList { pos } => {
                                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        pos), self.free_list.len()))) &&
                                                        (::builtin::spec_eq(self.free_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(pos)), row_addr))
                                                }
                                                ItemRowDisposition::InPendingAllocationList { pos, item } =>
                                                    {
                                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        pos), self.pending_allocations.len()))) &&
                                                        (::builtin::spec_eq(self.pending_allocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(pos)), row_addr))
                                                }
                                                ItemRowDisposition::InPendingDeallocationList { pos, item }
                                                    => {
                                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        pos), self.pending_deallocations.len()))) &&
                                                        (::builtin::spec_eq(self.pending_deallocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(pos)), row_addr))
                                                }
                                                ItemRowDisposition::InBothPendingLists {
                                                    alloc_pos, dealloc_pos, item } => {
                                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                        alloc_pos), self.pending_allocations.len()))) &&
                                                                        (::builtin::spec_eq(self.pending_allocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                                            int>(alloc_pos)), row_addr))) &&
                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                dealloc_pos), self.pending_deallocations.len())))) &&
                                                        (::builtin::spec_eq(self.pending_deallocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(dealloc_pos)), row_addr))
                                                }
                                            })
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn free_list_consistent(self,
                    sm: ItemTableStaticMetadata) -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.free_list.len())),
                                {
                                    (self.row_info.contains_key(#[verus::internal(trigger)] self.free_list.spec_index(i)))
                                        &&
                                        (((if let ItemRowDisposition::InFreeList { pos } =
                                                                (self.row_info.spec_index(self.free_list.spec_index(i))) {
                                                            ::builtin::spec_eq(pos, i)
                                                        } else { false })))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn pending_allocations_consistent(self,
                    sm: ItemTableStaticMetadata) -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.pending_allocations.len())),
                                {
                                    (self.row_info.contains_key(#[verus::internal(trigger)] self.pending_allocations.spec_index(i)))
                                        &&
                                        (match self.row_info.spec_index(self.pending_allocations.spec_index(i))
                                                {
                                                ItemRowDisposition::InPendingAllocationList { pos, item } =>
                                                    ::builtin::spec_eq(pos, i),
                                                ItemRowDisposition::InBothPendingLists {
                                                    alloc_pos, dealloc_pos, item } =>
                                                    ::builtin::spec_eq(alloc_pos, i),
                                                _ => false,
                                            })
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn pending_deallocations_consistent(self,
                    sm: ItemTableStaticMetadata) -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.pending_deallocations.len())),
                                {
                                    (self.row_info.contains_key(#[verus::internal(trigger)] self.pending_deallocations.spec_index(i)))
                                        &&
                                        (match self.row_info.spec_index(self.pending_deallocations.spec_index(i))
                                                {
                                                ItemRowDisposition::InPendingDeallocationList { pos, item }
                                                    => ::builtin::spec_eq(pos, i),
                                                ItemRowDisposition::InBothPendingLists {
                                                    alloc_pos, dealloc_pos, item } =>
                                                    ::builtin::spec_eq(dealloc_pos, i),
                                                _ => false,
                                            })
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent(self, sm: ItemTableStaticMetadata)
                    -> bool {
                    (((self.row_info_consistent(sm)) &&
                                        (self.free_list_consistent(sm))) &&
                                (self.pending_allocations_consistent(sm))) &&
                        (self.pending_deallocations_consistent(sm))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn valid(self, sm: ItemTableStaticMetadata)
                    -> bool {
                    (self.complete(sm)) && (self.consistent(sm))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_durable_state(self, s: Seq<u8>,
                    sm: ItemTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(self.row_info.contains_key(row_addr),
                                match self.row_info.spec_index(row_addr) {
                                    ItemRowDisposition::NowhereFree { item } =>
                                        ::builtin::spec_eq(recover_object::<I>(s,
                                                (row_addr).spec_add(sm.row_item_start),
                                                (row_addr).spec_add(sm.row_item_crc_start)), Some(item)),
                                    ItemRowDisposition::InPendingDeallocationList { pos, item }
                                        =>
                                        ::builtin::spec_eq(recover_object::<I>(s,
                                                (row_addr).spec_add(sm.row_item_start),
                                                (row_addr).spec_add(sm.row_item_crc_start)), Some(item)),
                                    _ => true,
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_read_state(self, s: Seq<u8>,
                    sm: ItemTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(self.row_info.contains_key(row_addr),
                                match self.row_info.spec_index(row_addr) {
                                    ItemRowDisposition::NowhereFree { item } =>
                                        ::builtin::spec_eq(recover_object::<I>(s,
                                                (row_addr).spec_add(sm.row_item_start),
                                                (row_addr).spec_add(sm.row_item_crc_start)), Some(item)),
                                    ItemRowDisposition::InFreeList { pos } => true,
                                    ItemRowDisposition::InPendingAllocationList { pos, item } =>
                                        ::builtin::spec_eq(recover_object::<I>(s,
                                                (row_addr).spec_add(sm.row_item_start),
                                                (row_addr).spec_add(sm.row_item_crc_start)), Some(item)),
                                    ItemRowDisposition::InPendingDeallocationList { pos, item }
                                        =>
                                        ::builtin::spec_eq(recover_object::<I>(s,
                                                (row_addr).spec_add(sm.row_item_start),
                                                (row_addr).spec_add(sm.row_item_crc_start)), Some(item)),
                                    ItemRowDisposition::InBothPendingLists {
                                        alloc_pos, dealloc_pos, item } =>
                                        ::builtin::spec_eq(recover_object::<I>(s,
                                                (row_addr).spec_add(sm.row_item_start),
                                                (row_addr).spec_add(sm.row_item_crc_start)), Some(item)),
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn as_durable_snapshot(self)
                    -> ItemTableSnapshot<I> {
                    ItemTableSnapshot::<I> {
                        m: Map::<u64,
                                I>::new(::builtin::closure_to_fn_spec(|row_addr: u64|
                                    {
                                        (self.row_info.contains_key(row_addr)) &&
                                            (::builtin::is_variant(self.row_info.spec_index(row_addr),
                                                        "NowhereFree") ||
                                                    ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                                        "InPendingDeallocationList"))
                                    }),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    match self.row_info.spec_index(row_addr) {
                                        ItemRowDisposition::NowhereFree { item } => item,
                                        ItemRowDisposition::InPendingDeallocationList { pos, item }
                                            => item,
                                        _ => arbitrary(),
                                    })),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn as_tentative_snapshot(self)
                    -> ItemTableSnapshot<I> {
                    ItemTableSnapshot::<I> {
                        m: Map::<u64,
                                I>::new(::builtin::closure_to_fn_spec(|row_addr: u64|
                                    {
                                        (self.row_info.contains_key(row_addr)) &&
                                            (::builtin::is_variant(self.row_info.spec_index(row_addr),
                                                        "NowhereFree") ||
                                                    ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                                        "InPendingAllocationList"))
                                    }),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    match self.row_info.spec_index(row_addr) {
                                        ItemRowDisposition::NowhereFree { item } => item,
                                        ItemRowDisposition::InPendingAllocationList { pos, item } =>
                                            item,
                                        _ => arbitrary(),
                                    })),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_corresponds_implication_for_free_list_length(self,
                    sm: ItemTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<I>(), self.valid(sm),
                                ::builtin::spec_eq(self.pending_allocations,
                                    Seq::<u64>::empty()),
                                ::builtin::spec_eq(self.pending_deallocations,
                                    Seq::<u64>::empty())]);
                    ::builtin::ensures([self.as_durable_snapshot().m.dom().finite(),
                                ::builtin::spec_eq(self.as_durable_snapshot().m.dom().len(),
                                    (sm.table.num_rows).spec_sub(self.free_list.len()))]);
                    {
                        ::builtin::assert_forall_by(|pos: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pos), self.free_list.len())));
                                    ::builtin::ensures(self.row_info.contains_key(#[verus::internal(trigger)] self.free_list.spec_index(pos)));
                                    ::builtin::assert_(::builtin::is_variant(self.row_info.spec_index(self.free_list.spec_index(pos)),
                                            "InFreeList"));
                                    ::builtin::assert_(self.row_info.contains_key(self.free_list.spec_index(pos)));
                                });
                    }
                    let free_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.row_info.contains_key(row_addr) &&
                                        ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                            "InFreeList")));
                    let item_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.row_info.contains_key(row_addr) &&
                                        ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                            "NowhereFree")));
                    let valid_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64| self.row_info.contains_key(row_addr)));
                    {
                        ::builtin::assert_by(valid_row_addrs.finite() &&
                                ::builtin::spec_eq(valid_row_addrs.len(),
                                    sm.table.num_rows),
                            {
                                ::builtin::assert_(::builtin::ext_equal(valid_row_addrs,
                                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                                        u64| sm.table.validate_row_addr(row_addr)))));
                                sm.table.lemma_valid_row_set_len();
                            });
                    }
                    {
                        ::builtin::assert_by(free_row_addrs.finite(),
                            {
                                vstd::set_lib::lemma_len_subset(free_row_addrs,
                                    valid_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(item_row_addrs.finite(),
                            {
                                vstd::set_lib::lemma_len_subset(item_row_addrs,
                                    valid_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(::builtin::spec_eq(valid_row_addrs.len(),
                                (free_row_addrs.len()).spec_add(item_row_addrs.len())),
                            {
                                ::builtin::assert_(free_row_addrs.disjoint(item_row_addrs));
                                ::builtin::assert_(::builtin::ext_equal((free_row_addrs).spec_add(item_row_addrs),
                                        valid_row_addrs));
                                vstd::set_lib::lemma_set_disjoint_lens(free_row_addrs,
                                    item_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(::builtin::spec_eq(free_row_addrs.len(),
                                self.free_list.len()),
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.free_list.to_set(),
                                        free_row_addrs));
                                self.free_list.unique_seq_to_set();
                            });
                    }
                    ::builtin::assert_(::builtin::ext_equal(item_row_addrs,
                            self.as_durable_snapshot().m.dom()));
                    ::builtin::assert_(::builtin::spec_eq(item_row_addrs.len(),
                            (sm.table.num_rows).spec_sub(self.free_list.len())));
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn internal_view(self)
                    -> ItemTableInternalView<I> {
                    ItemTableInternalView::<I> {
                        row_info: (self.row_info.view()),
                        free_list: (self.free_list.view()),
                        pending_allocations: (self.pending_allocations.view()),
                        pending_deallocations: (self.pending_deallocations.view()),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn inv(self, jv: JournalView) -> bool {
                    (((((((self.sm.valid::<I>()) &&
                                                                        ((jv.constants.app_area_start).spec_le(self.sm.start()))) &&
                                                                ((self.sm.end()).spec_le(jv.constants.app_area_end))) &&
                                                        (self.internal_view().valid(self.sm))) &&
                                                (self.internal_view().consistent_with_durable_state(jv.durable_state,
                                                        self.sm))) &&
                                        (::builtin::imply(!(self.must_abort.view()),
                                                self.internal_view().consistent_with_read_state(jv.read_state,
                                                    self.sm)))) &&
                                (::builtin::imply(!(self.must_abort.view()),
                                        self.internal_view().consistent_with_read_state(jv.commit_state,
                                            self.sm)))) &&
                        (::builtin::forall(|addr: int|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(self.sm.table.start),
                                                    addr), self.sm.table.end)),
                                        !(#[verus::internal(trigger)] jv.journaled_addrs.contains(addr)))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_valid_implications(self, jv: JournalView) {
                    ::builtin::requires([self.valid(jv)]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(jv.durable_state,
                                        (self.view()).durable.m.dom(), (self.view()).sm),
                                    Some((self.view()).durable)),
                                ::builtin::imply(::builtin::is_variant((self.view()).tentative,
                                        "Some"),
                                    ::builtin::spec_eq(Self::recover(jv.commit_state,
                                            (self.view()).tentative.unwrap().m.dom(), (self.view()).sm),
                                        (self.view()).tentative))]);
                    ::builtin::assert_(::builtin::ext_equal(Self::recover(jv.durable_state,
                                (self.view()).durable.m.dom(), (self.view()).sm),
                            Some((self.view()).durable)));
                    if ::builtin::is_variant((self.view()).tentative, "Some") {
                            ::builtin::assert_(::builtin::ext_equal(Self::recover(jv.commit_state,
                                        (self.view()).tentative.unwrap().m.dom(), (self.view()).sm),
                                    (self.view()).tentative));
                        }
                }
            }
        }
        mod recover_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::JournalView;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::{ItemTable, ItemTableStaticMetadata};
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn item_recoverable<I>(s: Seq<u8>, addr: u64,
                sm: ItemTableStaticMetadata) -> bool where I: PmCopy {
                (sm.table.validate_row_addr(addr)) &&
                    (::builtin::is_variant(recover_object::<I>(s,
                                (addr).spec_add(sm.row_item_start),
                                (addr).spec_add(sm.row_item_crc_start)), "Some"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn items_recoverable<I>(s: Seq<u8>, addrs: Set<u64>,
                sm: ItemTableStaticMetadata) -> bool where I: PmCopy {
                ::builtin::forall(|addr|
                        ::builtin::imply(#[verus::internal(trigger)] addrs.contains(addr),
                            item_recoverable::<I>(s, addr, sm)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn recover_item<I>(s: Seq<u8>, addr: u64,
                sm: ItemTableStaticMetadata) -> I where I: PmCopy {
                ::builtin::recommends([item_recoverable::<I>(s, addr, sm)]);
                recover_object::<I>(s, (addr).spec_add(sm.row_item_start),
                        (addr).spec_add(sm.row_item_crc_start)).unwrap()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub(super) fn recover_items<I>(s: Seq<u8>, addrs: Set<u64>,
                sm: ItemTableStaticMetadata) -> Map<u64, I> where I: PmCopy {
                ::builtin::recommends([items_recoverable::<I>(s, addrs, sm)]);
                Map::<u64,
                        I>::new(::builtin::closure_to_fn_spec(|addr: u64|
                            addrs.contains(addr)),
                    ::builtin::closure_to_fn_spec(|addr: u64|
                            recover_item::<I>(s, addr, sm)))
            }
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_valid_depends_only_on_my_area(&self,
                    old_jv: JournalView, new_jv: JournalView) {
                    ::builtin::requires([self.valid(old_jv),
                                ::builtin::spec_eq(old_jv.constants, new_jv.constants),
                                old_jv.matches_in_range(new_jv,
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.end()))]);
                    ::builtin::ensures([self.valid(new_jv)]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(self.valid(new_jv));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_recover_depends_only_on_my_area_if_valid(s1: Seq<u8>,
                    s2: Seq<u8>, addrs: Set<u64>, sm: ItemTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<I>(),
                                (sm.end()).spec_le(s1.len()),
                                seqs_match_in_range(s1, s2,
                                    ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                    ::builtin::spec_cast_integer::<_, int>(sm.end())),
                                ::builtin::is_variant(Self::recover(s1, addrs, sm),
                                    "Some")]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(s1,
                                        addrs, sm), Self::recover(s2, addrs, sm))]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(::builtin::ext_equal(Self::recover(s1,
                                addrs, sm), Self::recover(s2, addrs, sm)));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_recover_depends_only_on_my_area(s1: Seq<u8>,
                    s2: Seq<u8>, addrs: Set<u64>, sm: ItemTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<I>(),
                                (sm.end()).spec_le(s1.len()),
                                seqs_match_in_range(s1, s2,
                                    ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                    ::builtin::spec_cast_integer::<_, int>(sm.end()))]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(s1,
                                        addrs, sm), Self::recover(s2, addrs, sm))]);
                    if ::builtin::is_variant(Self::recover(s1, addrs, sm),
                                "Some") {
                            Self::lemma_recover_depends_only_on_my_area_if_valid(s1, s2,
                                addrs, sm);
                        } else if ::builtin::is_variant(Self::recover(s2, addrs,
                                   sm), "Some") {
                           Self::lemma_recover_depends_only_on_my_area_if_valid(s2, s1,
                               addrs, sm);
                       }
                }
            }
        }
        mod setup_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::align_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use super::{ItemTable, ItemTableStaticMetadata};
            use super::spec_v::*;
            use super::super::spec_t::*;
            use vstd::arithmetic::overflow::CheckedU64;
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn space_needed_for_setup(ps: &SetupParameters,
                    min_start: &CheckedU64) -> CheckedU64 {
                    ::builtin::requires([ps.valid()]);
                    ::builtin::ensures(|result: CheckedU64|
                            [::builtin::spec_eq((result.view()),
                                        Self::spec_space_needed_for_setup(*ps,
                                            (min_start.view())))]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    let row_item_end = CheckedU64::new(size_of::<I>() as u64);
                    let row_item_crc_end =
                        row_item_end.add_value(size_of::<u64>() as u64);
                    let num_rows = CheckedU64::new(ps.max_keys);
                    let table_size = num_rows.mul_checked(&row_item_crc_end);
                    let initial_space =
                        if min_start.is_overflowed() {
                                0
                            } else {
                               get_space_needed_for_alignment_usize(min_start.unwrap(),
                                       size_of::<u64>()) as u64
                           };
                    CheckedU64::new(initial_space).add_checked(&table_size)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn setup_given_metadata(pm: &mut PM,
                    sm: &ItemTableStaticMetadata) {
                    ::builtin::requires([old(pm).inv(),
                                (old(pm).view()).valid(), sm.valid::<I>(),
                                (sm.table.end).spec_le((old(pm).view()).len())]);
                    ::builtin::ensures([pm.inv(),
                                ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                (pm.view()).valid(),
                                ::builtin::spec_eq((pm.view()).len(),
                                    (old(pm).view()).len()),
                                ::builtin::spec_eq(Self::recover((pm.view()).read_state,
                                        Set::<u64>::empty(), *sm),
                                    Some(ItemTableSnapshot::<I>::init())),
                                seqs_match_except_in_range((old(pm).view()).read_state,
                                    (pm.view()).read_state,
                                    ::builtin::spec_cast_integer::<_, int>(sm.table.start),
                                    ::builtin::spec_cast_integer::<_, int>(sm.table.end))]);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(Self::recover((pm.view()).read_state,
                                            Set::<u64>::empty(), *sm),
                                        Some(ItemTableSnapshot::<I>::init())))
                            };
                    };
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn setup(pm: &mut PM, ps: &SetupParameters,
                    min_start: u64, max_end: u64)
                    -> Result<ItemTableStaticMetadata, KvError> {
                    ::builtin::requires([old(pm).inv(),
                                (old(pm).view()).valid(), ps.valid(),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(min_start),
                                            max_end), (old(pm).view()).len()))]);
                    ::builtin::ensures(|result:
                                Result<ItemTableStaticMetadata, KvError>|
                            [pm.inv(),
                                    ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                    (pm.view()).valid(),
                                    ::builtin::spec_eq((pm.view()).len(),
                                        (old(pm).view()).len()),
                                    match result {
                                        Ok(sm) => {
                                            (((((::builtin::spec_eq(Self::recover((pm.view()).read_state,
                                                                                            Set::<u64>::empty(), sm),
                                                                                        Some(ItemTableSnapshot::<I>::init()))) &&
                                                                                (seqs_match_except_in_range((old(pm).view()).read_state,
                                                                                        (pm.view()).read_state,
                                                                                        ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                                                                        ::builtin::spec_cast_integer::<_, int>(sm.end())))) &&
                                                                        (sm.valid::<I>())) &&
                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(min_start),
                                                                                    sm.start()), sm.end()), max_end)))) &&
                                                        (::builtin::spec_eq((sm.end()).spec_sub(min_start),
                                                                Self::spec_space_needed_for_setup(*ps,
                                                                    ::builtin::spec_cast_integer::<_, nat>(min_start))))) &&
                                                (::builtin::spec_eq(sm.num_rows(), ps.max_keys))
                                        }
                                        Err(KvError::OutOfSpace) =>
                                            ((max_end).spec_sub(min_start)).spec_lt(Self::spec_space_needed_for_setup(*ps,
                                                    ::builtin::spec_cast_integer::<_, nat>(min_start))),
                                        _ => false,
                                    }]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    let item_size = size_of::<I>();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(item_size,
                                            I::spec_size_of()),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    let row_item_end = CheckedU64::new(size_of::<I>() as u64);
                    let row_item_crc_end =
                        row_item_end.add_value(size_of::<u64>() as u64);
                    let num_rows = CheckedU64::new(ps.max_keys);
                    let start =
                        align_checked_u64_to_usize(&CheckedU64::new(min_start),
                            size_of::<u64>());
                    let table_size = num_rows.mul_checked(&row_item_crc_end);
                    let end = start.add_checked(&table_size);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(((end.view())).spec_sub(min_start),
                                        Self::spec_space_needed_for_setup(*ps,
                                            ::builtin::spec_cast_integer::<_, nat>(min_start))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(((table_size.view())).spec_ge((row_item_crc_end.view())),
                                        {
                                            vstd::arithmetic::mul::lemma_mul_ordering(::builtin::spec_cast_integer::<_,
                                                        int>(ps.max_keys),
                                                ::builtin::spec_cast_integer::<_,
                                                        int>((row_item_crc_end.view())));
                                        });
                                }
                            };
                    }
                    if end.is_overflowed() { return Err(KvError::OutOfSpace); }
                    if end.unwrap() > max_end {
                            return Err(KvError::OutOfSpace);
                        }
                    let table =
                        TableMetadata::new(start.unwrap(), end.unwrap(),
                            ps.max_keys, row_item_crc_end.unwrap());
                    let sm =
                        ItemTableStaticMetadata {
                            table,
                            item_size: item_size as u64,
                            row_item_start: 0,
                            row_item_end: row_item_end.unwrap(),
                            row_item_crc_start: row_item_end.unwrap(),
                        };
                    Self::setup_given_metadata(pm, &sm);
                    Ok(sm)
                }
            }
        }
        mod spec_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use super::ItemTableStaticMetadata;
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct ItemTableSnapshot<I> {
                pub m: Map<u64, I>,
            }
            #[verus::internal(verus_macro)]
            impl<I> ItemTableSnapshot<I> {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn init() -> Self { Self { m: Map::<u64, I>::empty() } }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn create(&self, item_addr: u64, item: I) -> Self {
                    Self { m: self.m.insert(item_addr, item) }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn delete(&self, item_addr: u64) -> Self {
                    Self { m: self.m.remove(item_addr) }
                }
            }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct ItemTableView<I> {
                pub sm: ItemTableStaticMetadata,
                pub used_slots: int,
                pub durable: ItemTableSnapshot<I>,
                pub tentative: Option<ItemTableSnapshot<I>>,
            }
        }
        mod start_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::power_t::*;
            use std::collections::HashSet;
            use super::{ItemTable, ItemTableStaticMetadata};
            use super::inv_v::*;
            use super::recover_v::*;
            use super::super::spec_t::*;
            #[verus::internal(verus_macro)]
            impl<PM, I> ItemTable<PM, I> where PM: PersistentMemoryRegion,
                I: PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn start(journal: &Journal<PM>, item_addrs: &HashSet<u64>,
                    sm: &ItemTableStaticMetadata) -> Result<Self, KvError> {
                    ::builtin::requires([journal.valid(),
                                journal.recover_idempotent(), (journal.view()).valid(),
                                ::builtin::spec_eq((journal.view()).journaled_addrs,
                                    Set::<int>::empty()),
                                ::builtin::spec_eq((journal.view()).durable_state,
                                    (journal.view()).read_state),
                                ::builtin::spec_eq((journal.view()).read_state,
                                    (journal.view()).commit_state),
                                ((journal.view()).constants.app_area_start).spec_le(sm.start()),
                                (sm.end()).spec_le((journal.view()).constants.app_area_end),
                                ::builtin::is_variant(Self::recover((journal.view()).read_state,
                                        (item_addrs.view()), *sm), "Some"), sm.valid::<I>()]);
                    ::builtin::ensures(|result: Result<Self, KvError>|
                            [match result {
                                        Ok(items) => {
                                            let recovered_state =
                                                Self::recover((journal.view()).read_state,
                                                        (item_addrs.view()), *sm).unwrap();
                                            ((((((items.valid((journal.view()))) &&
                                                                                        (::builtin::spec_eq((items.view()).sm, *sm))) &&
                                                                                (recovered_state.m.dom().finite())) &&
                                                                        (::builtin::spec_eq((items.view()).used_slots,
                                                                                recovered_state.m.dom().len()))) &&
                                                                (::builtin::spec_eq((items.view()).durable,
                                                                        recovered_state))) &&
                                                        (::builtin::spec_eq((items.view()).tentative,
                                                                Some(recovered_state)))) &&
                                                (::builtin::spec_eq(recovered_state.m.dom(),
                                                        (item_addrs.view())))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        Err(_) => false,
                                    }]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = Map::<u64, ItemRowDisposition<I>>::empty() };
                    #[verus::internal(spec)]
                    let mut row_info;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let mut verus_tmp_row_info = verus_tmp;
                        row_info = verus_tmp_row_info;
                    };
                    let mut free_list: Vec<u64> = Vec::new();
                    let mut row_index: u64 = 0;
                    let mut row_addr: u64 = sm.table.start;

                    #[verifier::proof_block]
                    { sm.table.lemma_start_is_valid_row(); }
                    while row_index < sm.table.num_rows {
                        ::builtin::invariant([::builtin::is_variant(Self::recover((journal.view()).read_state,
                                            (item_addrs.view()), *sm), "Some"), sm.valid::<I>(),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                row_index), sm.table.num_rows)),
                                    ::builtin::spec_eq(sm.table.row_addr_to_index(row_addr),
                                        ::builtin::spec_cast_integer::<_, int>(row_index)),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(sm.table.start),
                                                row_addr), sm.table.end)),
                                    ::builtin::imply((row_index).spec_lt(sm.table.num_rows),
                                        sm.table.validate_row_addr(row_addr)),
                                    ((journal.view()).constants.app_area_start).spec_le(sm.start()),
                                    (sm.end()).spec_le((journal.view()).constants.app_area_end),
                                    ({
                                            let iv =
                                                ItemTableInternalView::<I> {
                                                    row_info,
                                                    free_list: (free_list.view()),
                                                    pending_allocations: Seq::<u64>::empty(),
                                                    pending_deallocations: Seq::<u64>::empty(),
                                                };
                                            (iv.consistent(*sm)) &&
                                                (iv.consistent_with_read_state((journal.view()).read_state,
                                                        *sm))
                                        }),
                                    ::builtin::forall(|any_row_addr: u64|
                                            ::builtin::imply({
                                                    (#[verus::internal(trigger)] sm.table.validate_row_addr(any_row_addr))
                                                        &&
                                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        sm.table.row_addr_to_index(any_row_addr)), row_index)))
                                                }, row_info.contains_key(any_row_addr))),
                                    ::builtin::forall(|any_row_addr: u64|
                                            ::builtin::imply(#[verus::internal(trigger)] row_info.contains_key(any_row_addr),
                                                match row_info.spec_index(any_row_addr) {
                                                    ItemRowDisposition::<I>::NowhereFree { item } =>
                                                        (item_addrs.view()).contains(any_row_addr),
                                                    ItemRowDisposition::<I>::InFreeList { pos } =>
                                                        !(item_addrs.view()).contains(any_row_addr),
                                                    _ => false,
                                                })),
                                    ::builtin::forall(|i: int|
                                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), (free_list.view()).len())),
                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            sm.table.row_addr_to_index(#[verus::internal(trigger)] (free_list.view()).spec_index(i))),
                                                        row_index))))]);

                        #[verifier::proof_block]
                        {
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(vstd::std_specs::hash::group_hash_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            sm.table.lemma_row_addr_successor_is_valid(row_addr);
                        }
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = (free_list.view()) };
                        #[verus::internal(spec)]
                        let mut old_free_list;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_old_free_list = verus_tmp;
                            old_free_list = verus_tmp_old_free_list;
                        };
                        if !item_addrs.contains(&row_addr) {

                                #[verifier::proof_block]
                                {
                                    #[verus::internal(spec)]
                                    let pos = (free_list.view()).len();
                                    row_info =
                                        row_info.insert(row_addr,
                                            ItemRowDisposition::InFreeList { pos });
                                }
                                free_list.push(row_addr);
                            } else {

                               #[verifier::proof_block]
                               {
                                   #[verus::internal(spec)]
                                   let item =
                                       recover_item::<I>((journal.view()).read_state, row_addr,
                                           *sm);
                                   row_info =
                                       row_info.insert(row_addr,
                                           ItemRowDisposition::NowhereFree { item });
                               }
                           }
                        row_index = row_index + 1;
                        row_addr = row_addr + sm.table.row_size;
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_forall_by(|row_addr: u64|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] sm.table.validate_row_addr(row_addr));
                                                ::builtin::ensures(row_info.contains_key(row_addr));
                                                let row_index = sm.table.row_addr_to_index(row_addr);
                                                {
                                                    ::builtin::reveal_hide_({
                                                            #[verus::internal(reveal_fn)]
                                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                            }

                                                            #[verus::internal(broadcast_use_reveal)]
                                                            __VERUS_REVEAL_INTERNAL__
                                                        }, 1);
                                                }
                                            });
                                }
                            };
                    }
                    let items =
                        Self {
                            status: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ItemTableStatus::Quiescent),
                            sm: *sm,
                            must_abort: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] false),
                            row_info: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] row_info),
                            free_list,
                            pending_allocations: Vec::new(),
                            pending_deallocations: Vec::new(),
                            phantom_pm: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] core::marker::PhantomData),
                        };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            Self::recover((journal.view()).read_state,
                                    (item_addrs.view()), *sm).unwrap()
                    };
                    #[verus::internal(spec)]
                    let mut recovered_state;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_recovered_state = verus_tmp;
                        recovered_state = verus_tmp_recovered_state;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((items.view()).durable,
                                        recovered_state))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((items.view()).tentative,
                                        Some(recovered_state)))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(recovered_state.m.dom(),
                                        (item_addrs.view())))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        items.internal_view().lemma_corresponds_implication_for_free_list_length(*sm);
                    }
                    Ok(items)
                }
            }
        }
        pub use impl_v::{ItemTable, ItemTableStaticMetadata};
        pub use spec_v::{ItemTableSnapshot, ItemTableView};
    }
    pub mod keys {
        #![allow(unused_imports)]
        mod abort_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::journal::JournalView;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use std::hash::Hash;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::spec_v::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn apply_last_undo_record(&mut self,
                    verus_tmp_jv: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv;

                    #[verifier::proof_block]
                    { jv = verus_tmp_jv.view() };
                    ::builtin::requires([old(self).inv(jv),
                                ::builtin::is_variant((old(self).status.view()),
                                    "Inconsistent"),
                                ((old(self).undo_records.view()).len()).spec_gt(::builtin::spec_literal_nat("0")),
                                old(self).internal_view().apply_undo_record((old(self).undo_records.view()).last()).unwrap().valid(old(self).sm)]);
                    ::builtin::ensures([self.inv(jv),
                                ::builtin::spec_eq(self.status, old(self).status),
                                ::builtin::spec_eq(self.must_abort, old(self).must_abort),
                                ::builtin::spec_eq(self.sm, old(self).sm),
                                ::builtin::spec_eq((self.undo_records.view()),
                                    (old(self).undo_records.view()).drop_last())]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    let undo_record = self.undo_records.pop().unwrap();
                    match undo_record {
                        KeyUndoRecord::UndoCreate { row_addr, k } => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    ((self.memory_mapping.view()).row_info.spec_index(row_addr).arrow_rm())
                            };
                            #[verus::internal(spec)]
                            let mut rm;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_rm = verus_tmp;
                                rm = verus_tmp_rm;
                            };
                            self.memory_mapping =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.memory_mapping.view()).undo_create(row_addr,
                                            k, rm, (self.free_list.view()).len()).unwrap());
                            self.m.remove(&k);
                            self.free_list.push(row_addr);
                        }
                        KeyUndoRecord::UndoUpdate { row_addr, k, former_rm } => {
                            self.memory_mapping =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.memory_mapping.view()).undo_update(row_addr,
                                            k, former_rm).unwrap());
                            self.m.insert(k,
                                ConcreteKeyInfo { row_addr, rm: former_rm });
                        }
                        KeyUndoRecord::UndoDelete { row_addr, k, rm } => {
                            self.memory_mapping =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.memory_mapping.view()).undo_delete(row_addr,
                                            k, rm).unwrap());
                            self.m.insert(k, ConcreteKeyInfo { row_addr, rm });
                            let _ = self.pending_deallocations.pop();
                        }
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(old(self).internal_view().apply_undo_record(undo_record),
                                        Some(self.internal_view())))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(self.internal_view().apply_undo_records((self.undo_records.view()),
                                            self.sm),
                                        old(self).internal_view().apply_undo_records((old(self).undo_records.view()),
                                            self.sm)))
                            };
                    };
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn apply_all_undo_records(&mut self,
                    verus_tmp_jv: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv;

                    #[verifier::proof_block]
                    { jv = verus_tmp_jv.view() };
                    ::builtin::requires([old(self).inv(jv),
                                ::builtin::is_variant((old(self).status.view()),
                                    "Inconsistent")]);
                    ::builtin::ensures([self.inv(jv),
                                ::builtin::spec_eq(self.status, old(self).status),
                                ::builtin::spec_eq(self.must_abort, old(self).must_abort),
                                ::builtin::spec_eq(self.sm, old(self).sm),
                                ::builtin::spec_eq((self.undo_records.view()).len(),
                                    ::builtin::spec_literal_nat("0"))]);
                    while self.undo_records.len() > 0 {
                        ::builtin::invariant([self.inv(jv),
                                    ::builtin::is_variant((self.status.view()), "Inconsistent"),
                                    ::builtin::spec_eq(self.must_abort, old(self).must_abort),
                                    ::builtin::spec_eq(self.sm, old(self).sm)]);
                        self.apply_last_undo_record(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv));
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn abort(&mut self,
                    verus_tmp_jv_before_abort: Ghost<JournalView>,
                    verus_tmp_jv_after_abort: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_before_abort;

                    #[verifier::proof_block]
                    { jv_before_abort = verus_tmp_jv_before_abort.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_after_abort;

                    #[verifier::proof_block]
                    { jv_after_abort = verus_tmp_jv_after_abort.view() };
                    ::builtin::requires([old(self).valid(jv_before_abort),
                                jv_before_abort.valid(), jv_after_abort.valid(),
                                ::builtin::spec_eq(jv_after_abort, jv_before_abort.abort()),
                                ::builtin::spec_eq(jv_before_abort.durable_state,
                                    jv_before_abort.read_state)]);
                    ::builtin::ensures([self.valid(jv_after_abort),
                                ::builtin::spec_eq((self.view()),
                                    (KeyTableView {
                                            tentative: Some((old(self).view()).durable),
                                            used_slots: (self.view()).used_slots,
                                            ..(old(self).view())
                                        })), (self.view()).durable.key_info.dom().finite(),
                                ::builtin::spec_eq((self.view()).used_slots,
                                    (self.view()).durable.key_info.dom().len())]);
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Inconsistent);
                    self.apply_all_undo_records(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_abort));
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent);
                    self.must_abort =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] false);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((self.pending_deallocations.view()),
                                        Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        (self.memory_mapping.view()).lemma_corresponds_implication_for_free_list_length((self.free_list.view()),
                            self.sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()),
                                        (KeyTableView {
                                                tentative: Some((old(self).view()).durable),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })))
                            };
                    };
                }
            }
        }
        mod commit_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::JournalView;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use std::hash::Hash;
            use super::impl_v::*;
            use super::spec_v::*;
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn commit(&mut self,
                    verus_tmp_jv_before_commit: Ghost<JournalView>,
                    verus_tmp_jv_after_commit: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_before_commit;

                    #[verifier::proof_block]
                    { jv_before_commit = verus_tmp_jv_before_commit.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_after_commit;

                    #[verifier::proof_block]
                    { jv_after_commit = verus_tmp_jv_after_commit.view() };
                    ::builtin::requires([old(self).valid(jv_before_commit),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                jv_before_commit.valid(), jv_after_commit.valid(),
                                jv_after_commit.committed_from(jv_before_commit)]);
                    ::builtin::ensures([self.valid(jv_after_commit),
                                ::builtin::spec_eq((self.view()),
                                    (KeyTableView {
                                            durable: (old(self).view()).tentative.unwrap(),
                                            used_slots: (self.view()).used_slots,
                                            ..(old(self).view())
                                        })), (self.view()).durable.key_info.dom().finite(),
                                ::builtin::spec_eq((self.view()).used_slots,
                                    (self.view()).durable.key_info.dom().len())]);
                    self.undo_records.clear();
                    self.memory_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.memory_mapping.view()).move_pending_deallocations_to_free_list((self.free_list.view()).len()));
                    self.free_list.append(&mut self.pending_deallocations);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid(jv_after_commit)) };
                    };

                    #[verifier::proof_block]
                    {
                        (self.memory_mapping.view()).lemma_corresponds_implication_for_free_list_length((self.free_list.view()),
                            self.sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()),
                                        (KeyTableView {
                                                durable: (old(self).view()).tentative.unwrap(),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })))
                            };
                    };
                }
            }
        }
        mod crud_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use crate::pmem::pmemutil_v::*;
            use std::hash::Hash;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            use vstd::slice::slice_to_vec;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            #[verus::internal(item_broadcast_use)]
            const _: () =
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(vstd::std_specs::hash::group_hash_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                };
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn read(&self, k: &K, jv: Ghost<JournalView>)
                    -> Option<(u64, KeyTableRowMetadata)> {
                    ::builtin::requires([self.valid((jv.view())),
                                (self.view()).tentative.is_some()]);
                    ::builtin::ensures(|result:
                                Option<(u64, KeyTableRowMetadata)>|
                            [match result {
                                        None =>
                                            !(self.view()).tentative.unwrap().key_info.contains_key(*k),
                                        Some((key_addr, rm)) => {
                                            let tentative = (self.view()).tentative.unwrap();
                                            ((tentative.key_info.contains_key(*k)) &&
                                                        (::builtin::spec_eq(tentative.key_info.spec_index(*k), rm)))
                                                && (self.key_corresponds_to_key_addr(*k, key_addr))
                                        }
                                    }]);
                    match self.m.get(k) {
                        None => None,
                        Some(concrete_key_info) =>
                            Some((concrete_key_info.row_addr, concrete_key_info.rm)),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_writing_to_free_slot_doesnt_change_recovery(iv:
                        KeyInternalView<K>, s1: Seq<u8>, s2: Seq<u8>,
                    sm: KeyTableStaticMetadata, free_list_pos: int,
                    row_addr: u64, start: int, end: int) {
                    ::builtin::requires([sm.valid::<K>(),
                                iv.consistent_with_state(s1, sm),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            free_list_pos), iv.free_list.len())),
                                ::builtin::spec_eq(iv.free_list.spec_index(free_list_pos),
                                    row_addr), sm.table.validate_row_addr(row_addr),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value((row_addr).spec_add(sm.row_metadata_start)),
                                                start), end), (row_addr).spec_add(sm.table.row_size))),
                                seqs_match_except_in_range(s1, s2, start, end)]);
                    ::builtin::ensures([iv.consistent_with_state(s2, sm),
                                ::builtin::spec_eq(Self::recover(s2, sm),
                                    Self::recover(s1, sm))]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    iv.memory_mapping.as_recovery_mapping().lemma_corresponds_implies_equals_new(s1,
                        sm);
                    iv.memory_mapping.as_recovery_mapping().lemma_corresponds_implies_equals_new(s2,
                        sm);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_writing_to_free_slot_has_permission_later_forall<PermFactory>(iv:
                        KeyInternalView<K>, initial_durable_state: Seq<u8>,
                    sm: KeyTableStaticMetadata, constants: JournalConstants,
                    free_list_pos: int, row_addr: u64,
                    perm_factory: PermFactory) where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    ::builtin::requires([sm.valid::<K>(),
                                iv.consistent_with_state(initial_durable_state, sm),
                                Journal::<PM>::state_recovery_idempotent(initial_durable_state,
                                    constants),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            free_list_pos), iv.free_list.len())),
                                ::builtin::spec_eq(iv.free_list.spec_index(free_list_pos),
                                    row_addr), sm.table.validate_row_addr(row_addr),
                                (sm.table.end).spec_le(initial_durable_state.len()),
                                ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                        ::builtin::imply({
                                                (Self::state_equivalent_for_me(s1, initial_durable_state,
                                                            constants, sm)) &&
                                                    (Self::state_equivalent_for_me(s2, initial_durable_state,
                                                            constants, sm))
                                            },
                                            #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                s2)))]);
                    ::builtin::ensures([::builtin::forall(|current_durable_state:
                                            Seq<u8>, s: Seq<u8>, start: int, end: int|
                                        ::builtin::imply({
                                                ((((#[verus::internal(trigger)] seqs_match_except_in_range(current_durable_state,
                                                                                    s, start, end)) &&
                                                                            (Self::state_equivalent_for_me(current_durable_state,
                                                                                    initial_durable_state, constants, sm))) &&
                                                                    (iv.consistent_with_state(current_durable_state, sm))) &&
                                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value((row_addr).spec_add(sm.row_metadata_start)),
                                                                                start), end), (row_addr).spec_add(sm.table.row_size))))) &&
                                                    (Journal::<PM>::state_recovery_idempotent(s, constants))
                                            },
                                            {
                                                ((Self::state_equivalent_for_me(s, initial_durable_state,
                                                                    constants, sm)) && (iv.consistent_with_state(s, sm))) &&
                                                    (perm_factory.check_permission(current_durable_state, s))
                                            }))]);
                    {
                        ::builtin::assert_forall_by(|current_durable_state: Seq<u8>,
                                s: Seq<u8>, start: int, end: int|
                                {
                                    ::builtin::requires({
                                            ((((#[verus::internal(trigger)] seqs_match_except_in_range(current_durable_state,
                                                                                s, start, end)) &&
                                                                        (Self::state_equivalent_for_me(current_durable_state,
                                                                                initial_durable_state, constants, sm))) &&
                                                                (iv.consistent_with_state(current_durable_state, sm))) &&
                                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value((row_addr).spec_add(sm.row_metadata_start)),
                                                                            start), end), (row_addr).spec_add(sm.table.row_size))))) &&
                                                (Journal::<PM>::state_recovery_idempotent(s, constants))
                                        });
                                    ::builtin::ensures({
                                            ((Self::state_equivalent_for_me(s, initial_durable_state,
                                                                constants, sm)) && (iv.consistent_with_state(s, sm))) &&
                                                (perm_factory.check_permission(current_durable_state, s))
                                        });
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    Self::lemma_writing_to_free_slot_doesnt_change_recovery(iv,
                                        current_durable_state, s, sm, free_list_pos, row_addr,
                                        start, end);
                                });
                    }
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn create_step1(&mut self, k: &K, item_addr: u64,
                    journal: &mut Journal<PM>) -> Result<u64, KvError> {
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                !(old(self).view()).tentative.unwrap().key_info.contains_key(*k),
                                !(old(self).view()).tentative.unwrap().item_addrs().contains(item_addr)]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.inv((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    ::builtin::spec_eq((journal.view()).durable_state,
                                        (old(journal).view()).durable_state),
                                    match result {
                                        Ok(row_addr) => {
                                            (((((((::builtin::spec_literal_nat("0")).spec_lt((self.free_list.view()).len()))
                                                                                        &&
                                                                                        (::builtin::spec_eq(row_addr,
                                                                                                (self.free_list.view()).last()))) &&
                                                                                (::builtin::spec_eq(self,
                                                                                        (Self {
                                                                                                status: ::builtin::Ghost::new(KeyTableStatus::Inconsistent),
                                                                                                ..*old(self)
                                                                                            })))) &&
                                                                        (::builtin::spec_eq(recover_cdb((journal.view()).commit_state,
                                                                                    (row_addr).spec_add(self.sm.row_cdb_start)), Some(true))))
                                                                &&
                                                                (seqs_match_except_in_range((old(journal).view()).commit_state,
                                                                        (journal.view()).commit_state,
                                                                        ::builtin::spec_cast_integer::<_, int>(row_addr),
                                                                        (row_addr).spec_add(self.sm.table.row_size)))) &&
                                                        (::builtin::spec_eq((journal.view()).journaled_addrs,
                                                                ((old(journal).view()).journaled_addrs).spec_add(Set::<int>::new(::builtin::closure_to_fn_spec(|i:
                                                                                    int|
                                                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((row_addr).spec_add(self.sm.row_cdb_start)),
                                                                                            i),
                                                                                        ((row_addr).spec_add(self.sm.row_cdb_start)).spec_add(u64::spec_size_of())))))))))
                                                &&
                                                (((journal.view()).remaining_capacity).spec_ge((((old(journal).view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (((self.valid((journal.view()))) &&
                                                                (::builtin::spec_eq((self.view()),
                                                                        (KeyTableView { tentative: None, ..(old(self).view()) }))))
                                                        &&
                                                        (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                                (old(journal).view()).remaining_capacity))) &&
                                                ({
                                                        (((old(journal).view()).remaining_capacity).spec_lt((spec_journal_entry_overhead()).spec_add(u64::spec_size_of())))
                                                            ||
                                                            (::builtin::spec_eq((self.view()).used_slots,
                                                                    (self.view()).sm.num_rows()))
                                                    })
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        self.lemma_valid_implications((journal.view()));
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let free_list_len = self.free_list.len();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (free_list_len).spec_sub(::builtin::spec_literal_nat("1"))
                    };
                    #[verus::internal(spec)]
                    let mut free_list_pos;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_free_list_pos = verus_tmp;
                        free_list_pos = verus_tmp_free_list_pos;
                    };
                    if free_list_len == 0 {
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                    let row_addr = self.free_list[free_list_len - 1];
                    let cdb_addr = row_addr + self.sm.row_cdb_start;
                    let cdb = CDB_TRUE;
                    let cdb_bytes = slice_to_vec(cdb.as_byte_slice());
                    match journal.journal_write(cdb_addr, cdb_bytes) {
                        Ok(()) => {}
                        Err(JournalError::NotEnoughSpace) => {
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::InternalError);
                        }
                    };
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Inconsistent);
                    Ok(row_addr)
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn create_step2<PermFactory>(&self, k: &K, item_addr: u64,
                    journal: &mut Journal<PM>, row_addr: u64,
                    verus_tmp_perm_factory: Tracked<&PermFactory>) where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([self.inv((old(journal).view())),
                                ::builtin::is_variant((self.status.view()), "Inconsistent"),
                                old(journal).valid(),
                                ::builtin::is_variant((self.view()).tentative, "Some"),
                                !(self.view()).tentative.unwrap().key_info.contains_key(*k),
                                !(self.view()).tentative.unwrap().item_addrs().contains(item_addr),
                                (::builtin::spec_literal_nat("0")).spec_lt((self.free_list.view()).len()),
                                ::builtin::spec_eq(row_addr,
                                    (self.free_list.view()).last()),
                                ::builtin::forall(|addr: int|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((row_addr).spec_add(self.sm.row_metadata_start)),
                                                        addr), (row_addr).spec_add(self.sm.table.row_size))),
                                            !(#[verus::internal(trigger)] (old(journal).view()).journaled_addrs.contains(addr)))),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                self.perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures([self.inv((journal.view())),
                                journal.valid(),
                                ::builtin::spec_eq((journal.view()).powerpm_id,
                                    (old(journal).view()).powerpm_id),
                                ::builtin::spec_eq((journal.view()).journaled_addrs,
                                    (old(journal).view()).journaled_addrs),
                                (journal.view()).matches_except_in_range((old(journal).view()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.end())),
                                ::builtin::spec_eq((journal.view()).remaining_capacity,
                                    (old(journal).view()).remaining_capacity),
                                ::builtin::spec_eq(recover_object::<K>((journal.view()).commit_state,
                                        (row_addr).spec_add(self.sm.row_key_start),
                                        (row_addr).spec_add(::builtin::spec_cast_integer::<_,
                                                    u64>(self.sm.row_key_crc_start))), Some(*k)),
                                ::builtin::spec_eq(recover_object::<KeyTableRowMetadata>((journal.view()).commit_state,
                                        (row_addr).spec_add(self.sm.row_metadata_start),
                                        (row_addr).spec_add(self.sm.row_metadata_crc_start)),
                                    Some(KeyTableRowMetadata {
                                            item_addr,
                                            list_addr: ::builtin::spec_literal_integer("0"),
                                        })),
                                seqs_match_except_in_range((old(journal).view()).commit_state,
                                    (journal.view()).commit_state,
                                    (row_addr).spec_add(self.sm.row_metadata_start),
                                    (row_addr).spec_add(self.sm.table.row_size))]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            self.internal_view().apply_undo_records((self.undo_records.view()),
                                    self.sm).unwrap()
                    };
                    #[verus::internal(spec)]
                    let mut iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_iv = verus_tmp;
                        iv = verus_tmp_iv;
                    };

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let free_list_pos =
                            ((self.free_list.view()).len()).spec_sub(::builtin::spec_literal_nat("1"));
                        {
                            ::builtin::assert_by(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                free_list_pos), iv.free_list.len())) &&
                                    ::builtin::spec_eq(iv.free_list.spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(free_list_pos)), row_addr),
                                {
                                    self.internal_view().lemma_apply_undo_records_only_appends_to_free_list((self.undo_records.view()),
                                        self.sm);
                                });
                        }
                        Self::lemma_writing_to_free_slot_has_permission_later_forall(iv,
                            (journal.view()).durable_state, self.sm,
                            (journal.view()).constants,
                            ::builtin::spec_cast_integer::<_, int>(free_list_pos),
                            row_addr, *perm_factory);
                    }
                    let key_addr = row_addr + self.sm.row_key_start;
                    #[verus::internal(proof)]
                    #[verus::internal(unwrapped_binding)]
                    let verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = perm_factory.grant_permission() };
                    #[verus::internal(infer_mode)]
                    let mut perm;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(proof)]
                        let verus_tmp_perm = verus_tmp;
                        perm = verus_tmp_perm;
                    };
                    journal.write_object::<_,
                        PermFactory::Perm>(key_addr, k,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                    let key_crc_addr = row_addr + self.sm.row_key_crc_start;
                    let key_crc = calculate_crc(k);
                    #[verus::internal(proof)]
                    #[verus::internal(unwrapped_binding)]
                    let verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = perm_factory.grant_permission() };
                    #[verus::internal(infer_mode)]
                    let mut perm;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(proof)]
                        let verus_tmp_perm = verus_tmp;
                        perm = verus_tmp_perm;
                    };
                    journal.write_object::<_,
                        PermFactory::Perm>(key_crc_addr, &key_crc,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                    let rm = KeyTableRowMetadata { item_addr, list_addr: 0 };
                    let metadata_addr = row_addr + self.sm.row_metadata_start;
                    #[verus::internal(proof)]
                    #[verus::internal(unwrapped_binding)]
                    let verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = perm_factory.grant_permission() };
                    #[verus::internal(infer_mode)]
                    let mut perm;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(proof)]
                        let verus_tmp_perm = verus_tmp;
                        perm = verus_tmp_perm;
                    };
                    journal.write_object::<_,
                        PermFactory::Perm>(metadata_addr, &rm,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                    let rm_crc_addr = row_addr + self.sm.row_metadata_crc_start;
                    let rm_crc = calculate_crc(&rm);
                    #[verus::internal(proof)]
                    #[verus::internal(unwrapped_binding)]
                    let verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = perm_factory.grant_permission() };
                    #[verus::internal(infer_mode)]
                    let mut perm;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(proof)]
                        let verus_tmp_perm = verus_tmp;
                        perm = verus_tmp_perm;
                    };
                    journal.write_object::<_,
                        PermFactory::Perm>(rm_crc_addr, &rm_crc,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn create<PermFactory>(&mut self, k: &K, item_addr: u64,
                    journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<(), KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                !(old(self).view()).tentative.unwrap().key_info.contains_key(*k),
                                !(old(self).view()).tentative.unwrap().item_addrs().contains(item_addr),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<(), KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(()) => {
                                            ((::builtin::spec_eq((self.view()),
                                                                (KeyTableView {
                                                                        tentative: Some((old(self).view()).tentative.unwrap().create(*k,
                                                                                item_addr)),
                                                                        used_slots: (self.view()).used_slots,
                                                                        ..(old(self).view())
                                                                    }))) &&
                                                        (((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                &&
                                                (((journal.view()).remaining_capacity).spec_ge((((old(journal).view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (KeyTableView { tentative: None, ..(old(self).view()) })))
                                                &&
                                                ({
                                                        (((old(journal).view()).remaining_capacity).spec_lt((spec_journal_entry_overhead()).spec_add(u64::spec_size_of())))
                                                            ||
                                                            (::builtin::spec_eq((self.view()).used_slots,
                                                                    (self.view()).sm.num_rows()))
                                                    })
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        self.lemma_valid_implications((journal.view()));
                    }
                    let row_addr =
                        match self.create_step1(k, item_addr, journal) {
                            Ok(r) => r,
                            Err(e) => { return Err(e); }
                        };
                    self.create_step2::<PermFactory>(k, item_addr, journal,
                        row_addr,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory));
                    let rm = KeyTableRowMetadata { item_addr, list_addr: 0 };
                    let _ = self.free_list.pop();
                    self.memory_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.memory_mapping.view()).create(row_addr,
                                *k, rm));
                    let cki = ConcreteKeyInfo { row_addr, rm };
                    self.m.insert(k.clone_provable(), cki);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.m.view()).remove(*k),
                                        (old(self).m.view())))
                            };
                    };
                    let undo_record =
                        KeyUndoRecord::UndoCreate { row_addr, k: *k };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view().apply_undo_record(undo_record),
                                        Some(old(self).internal_view())))
                            };
                    };
                    self.undo_records.push(undo_record);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(self.internal_view().apply_undo_records((self.undo_records.view()),
                                                self.sm),
                                            old(self).internal_view().apply_undo_records((old(self).undo_records.view()),
                                                self.sm)),
                                        {
                                            ::builtin::assert_(::builtin::ext_equal((self.undo_records.view()).drop_last(),
                                                    (old(self).undo_records.view())));
                                            ::builtin::assert_(::builtin::ext_equal((self.undo_records.view()).last(),
                                                    undo_record));
                                        });
                                }
                            };
                    }
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid((journal.view()))) };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                        Some((old(self).view()).tentative.unwrap().create(*k,
                                                item_addr))))
                            };
                    };
                    Ok(())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn delete<PermFactory>(&mut self, k: &K, row_addr: u64,
                    rm: KeyTableRowMetadata, journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<(), KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().key_info.contains_key(*k),
                                ::builtin::spec_eq((old(self).view()).tentative.unwrap().key_info.spec_index(*k),
                                    rm), old(self).key_corresponds_to_key_addr(*k, row_addr),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<(), KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(()) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (KeyTableView {
                                                                tentative: Some((old(self).view()).tentative.unwrap().delete(*k)),
                                                                ..(old(self).view())
                                                            }))) &&
                                                (((journal.view()).remaining_capacity).spec_ge((((old(journal).view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (KeyTableView { tentative: None, ..(old(self).view()) })))
                                                &&
                                                (((old(journal).view()).remaining_capacity).spec_lt((spec_journal_entry_overhead()).spec_add(u64::spec_size_of())))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        self.lemma_valid_implications((journal.view()));
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let cdb_addr = row_addr + self.sm.row_cdb_start;
                    let cdb = CDB_FALSE;
                    let cdb_bytes =
                        vstd::slice::slice_to_vec(cdb.as_byte_slice());
                    match journal.journal_write(cdb_addr, cdb_bytes) {
                        Ok(()) => {}
                        Err(JournalError::NotEnoughSpace) => {
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::InternalError);
                        }
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_((self.memory_mapping.view()).valid(self.sm))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(self.memory_mapping,
                                        old(self).memory_mapping))
                            };
                    };
                    self.memory_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.memory_mapping.view()).delete(row_addr,
                                *k, rm, (self.pending_deallocations.view()).len()));

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.memory_mapping.view()).undo_delete(row_addr,
                                            *k, rm), Some((old(self).memory_mapping.view()))))
                            };
                    };
                    self.m.remove(k);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((self.m.view()).insert(*k,
                                            ConcreteKeyInfo { row_addr, rm }), (old(self).m.view())))
                            };
                    };
                    self.pending_deallocations.push(row_addr);
                    let undo_record =
                        KeyUndoRecord::UndoDelete { row_addr, k: *k, rm };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view().apply_undo_record(undo_record),
                                        Some(old(self).internal_view())))
                            };
                    };
                    self.undo_records.push(undo_record);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(self.internal_view().apply_undo_records((self.undo_records.view()),
                                                self.sm),
                                            old(self).internal_view().apply_undo_records((old(self).undo_records.view()),
                                                self.sm)),
                                        {
                                            ::builtin::assert_(::builtin::ext_equal((self.undo_records.view()).drop_last(),
                                                    (old(self).undo_records.view())));
                                            ::builtin::assert_(::builtin::ext_equal((self.undo_records.view()).last(),
                                                    undo_record));
                                        });
                                }
                            };
                    }

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid((journal.view()))) };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                        Some((old(self).view()).tentative.unwrap().delete(*k))))
                            };
                    };
                    Ok(())
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_step1(&mut self, k: &K, row_addr: u64,
                    new_rm: KeyTableRowMetadata, former_rm: KeyTableRowMetadata,
                    journal: &mut Journal<PM>) -> Result<(), KvError> {
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().key_info.contains_key(*k),
                                old(self).key_corresponds_to_key_addr(*k, row_addr),
                                ::builtin::spec_eq((old(self).view()).tentative.unwrap().key_info.spec_index(*k),
                                    former_rm),
                                ({
                                        (::builtin::spec_eq(new_rm.item_addr, former_rm.item_addr))
                                            ||
                                            (!(old(self).view()).tentative.unwrap().item_addrs().contains(new_rm.item_addr))
                                    }),
                                ({
                                        ((::builtin::spec_eq(new_rm.list_addr,
                                                            ::builtin::spec_literal_nat("0"))) ||
                                                    (::builtin::spec_eq(new_rm.list_addr, former_rm.list_addr)))
                                            ||
                                            (!(old(self).view()).tentative.unwrap().list_addrs().contains(new_rm.list_addr))
                                    })]);
                    ::builtin::ensures(|result: Result<(), KvError>|
                            [journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    match result {
                                        Ok(()) => {
                                            (((((::builtin::spec_eq(self,
                                                                                        Self {
                                                                                            status: ::builtin::Ghost::new(KeyTableStatus::Inconsistent),
                                                                                            ..*old(self)
                                                                                        })) && (self.inv((journal.view())))) &&
                                                                        (self.internal_view().consistent_with_journaled_addrs((journal.view()).journaled_addrs,
                                                                                self.sm))) &&
                                                                ((journal.view()).matches_except_in_range((old(journal).view()),
                                                                        (row_addr).spec_add(self.sm.row_metadata_start),
                                                                        ((row_addr).spec_add(self.sm.row_metadata_crc_start)).spec_add(u64::spec_size_of()))))
                                                        &&
                                                        (::builtin::spec_eq(recover_object::<KeyTableRowMetadata>((journal.view()).commit_state,
                                                                    (row_addr).spec_add(self.sm.row_metadata_start),
                                                                    (row_addr).spec_add(self.sm.row_metadata_crc_start)),
                                                                Some(new_rm)))) &&
                                                (((journal.view()).remaining_capacity).spec_ge((((((old(journal).view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(KeyTableRowMetadata::spec_size_of())).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            ((((journal.view()).matches_except_in_range((old(journal).view()),
                                                                        ::builtin::spec_cast_integer::<_,
                                                                                int>((self.view()).sm.start()),
                                                                        ::builtin::spec_cast_integer::<_,
                                                                                int>((self.view()).sm.end()))) &&
                                                                (self.valid((journal.view())))) &&
                                                        (::builtin::spec_eq((self.view()),
                                                                KeyTableView { tentative: None, ..(old(self).view()) }))) &&
                                                (((old(journal).view()).remaining_capacity).spec_lt((((spec_journal_entry_overhead()).spec_add(KeyTableRowMetadata::spec_size_of())).spec_add(spec_journal_entry_overhead())).spec_add(u64::spec_size_of())))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        self.lemma_valid_implications((journal.view()));
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Inconsistent);
                    let metadata_addr = row_addr + self.sm.row_metadata_start;
                    let rm_bytes = slice_to_vec(new_rm.as_byte_slice());
                    match journal.journal_write(metadata_addr, rm_bytes) {
                        Ok(()) => {}
                        Err(JournalError::NotEnoughSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent);
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent);
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::InternalError);
                        }
                    };
                    let rm_crc_addr = row_addr + self.sm.row_metadata_crc_start;
                    let rm_crc = calculate_crc(&new_rm);
                    let rm_crc_bytes = slice_to_vec(rm_crc.as_byte_slice());
                    match journal.journal_write(rm_crc_addr, rm_crc_bytes) {
                        Ok(()) => {}
                        Err(JournalError::NotEnoughSpace) => {
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent);
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            self.status =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent);
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::InternalError);
                        }
                    };
                    Ok(())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn update<PermFactory>(&mut self, k: &K, row_addr: u64,
                    new_rm: KeyTableRowMetadata, former_rm: KeyTableRowMetadata,
                    journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<(), KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().key_info.contains_key(*k),
                                old(self).key_corresponds_to_key_addr(*k, row_addr),
                                ::builtin::spec_eq((old(self).view()).tentative.unwrap().key_info.spec_index(*k),
                                    former_rm),
                                ({
                                        (::builtin::spec_eq(new_rm.item_addr, former_rm.item_addr))
                                            ||
                                            (!(old(self).view()).tentative.unwrap().item_addrs().contains(new_rm.item_addr))
                                    }),
                                ({
                                        ((::builtin::spec_eq(new_rm.list_addr,
                                                            ::builtin::spec_literal_nat("0"))) ||
                                                    (::builtin::spec_eq(new_rm.list_addr, former_rm.list_addr)))
                                            ||
                                            (!(old(self).view()).tentative.unwrap().list_addrs().contains(new_rm.list_addr))
                                    }),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<(), KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(()) => {
                                            ((::builtin::spec_eq((self.view()),
                                                                (KeyTableView {
                                                                        tentative: Some((old(self).view()).tentative.unwrap().update(*k,
                                                                                new_rm, former_rm)),
                                                                        used_slots: (self.view()).used_slots,
                                                                        ..(old(self).view())
                                                                    }))) &&
                                                        (((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                &&
                                                (((journal.view()).remaining_capacity).spec_ge((((((old(journal).view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(KeyTableRowMetadata::spec_size_of())).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (KeyTableView { tentative: None, ..(old(self).view()) })))
                                                &&
                                                (((old(journal).view()).remaining_capacity).spec_lt((((spec_journal_entry_overhead()).spec_add(KeyTableRowMetadata::spec_size_of())).spec_add(spec_journal_entry_overhead())).spec_add(u64::spec_size_of())))
                                        }
                                        _ => false,
                                    }]);
                    match self.update_step1(k, row_addr, new_rm, former_rm,
                            journal) {
                        Ok(()) => {}
                        Err(e) => { return Err(e); }
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_((self.memory_mapping.view()).valid(self.sm))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(self.memory_mapping,
                                        old(self).memory_mapping))
                            };
                    };
                    self.memory_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.memory_mapping.view()).update(row_addr,
                                *k, new_rm, former_rm));

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.memory_mapping.view()).undo_update(row_addr,
                                            *k, former_rm), Some((old(self).memory_mapping.view()))))
                            };
                    };
                    self.m.insert(k.clone_provable(),
                        ConcreteKeyInfo { row_addr, rm: new_rm });

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((self.m.view()).insert(*k,
                                            ConcreteKeyInfo { row_addr, rm: former_rm }),
                                        (old(self).m.view())))
                            };
                    };
                    let undo_record =
                        KeyUndoRecord::UndoUpdate {
                            row_addr,
                            k: *k,
                            former_rm: former_rm,
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view().apply_undo_record(undo_record),
                                        Some(old(self).internal_view())))
                            };
                    };
                    self.undo_records.push(undo_record);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(self.internal_view().apply_undo_records((self.undo_records.view()),
                                                self.sm),
                                            old(self).internal_view().apply_undo_records((old(self).undo_records.view()),
                                                self.sm)),
                                        {
                                            ::builtin::assert_(::builtin::ext_equal((self.undo_records.view()).drop_last(),
                                                    (old(self).undo_records.view())));
                                            ::builtin::assert_(::builtin::ext_equal((self.undo_records.view()).last(),
                                                    undo_record));
                                        });
                                }
                            };
                    }

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid((journal.view()))) };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()).tentative,
                                        Some((old(self).view()).tentative.unwrap().update(*k,
                                                new_rm, former_rm))))
                            };
                    };
                    Ok(())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn get_keys(&self, journal: &Journal<PM>) -> Vec<K> {
                    ::builtin::requires([self.valid((journal.view())),
                                ::builtin::is_variant((self.view()).tentative, "Some")]);
                    ::builtin::ensures(|result: Vec<K>|
                            [::builtin::spec_eq((result.view()).to_set(),
                                        (self.view()).tentative.unwrap().key_info.dom()),
                                    (result.view()).no_duplicates()]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(vstd::std_specs::hash::group_hash_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    let keys = self.m.keys();
                    let mut result = Vec::<K>::new();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((result.view()),
                                        (keys.view()).1.take(::builtin::spec_literal_integer("0"))))
                            };
                    };
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(keys)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut iter;

                                    #[verifier::proof_block]
                                    {
                                        iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(keys)),
                                                            false)),
                                                    {
                                                        let k =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((result.view()), (iter.view()))
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let k = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(iter.keys.take(iter.pos).push(*k),
                                                                        iter.keys.take((iter.pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                            };
                                                    };
                                                    result.push(*k);
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::ext_equal((result.view()).to_set(),
                                            (self.view()).tentative.unwrap().key_info.dom()),
                                        {
                                            ::builtin::assert_(::builtin::spec_eq((keys.view()).1.to_set(),
                                                    (self.m.view()).dom()));
                                            ::builtin::assert_(::builtin::ext_equal((keys.view()).1.take(::builtin::spec_cast_integer::<_,
                                                                int>((keys.view()).1.len())), (keys.view()).1));
                                            ::builtin::assert_(::builtin::ext_equal((self.m.view()).dom(),
                                                    (self.view()).tentative.unwrap().key_info.dom()));
                                        });
                                }
                            };
                    }
                    result
                }
            }
        }
        mod impl_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::align_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use deps_hack::PmCopy;
            use std::collections::HashMap;
            use std::hash::Hash;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[repr(C)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct KeyTableStaticMetadata {
                pub(super) table: TableMetadata,
                pub(super) key_size: u64,
                pub(super) row_cdb_start: u64,
                pub(super) row_metadata_start: u64,
                pub(super) row_metadata_end: u64,
                pub(super) row_metadata_crc_start: u64,
                pub(super) row_key_start: u64,
                pub(super) row_key_end: u64,
                pub(super) row_key_crc_start: u64,
            }
            unsafe impl pmcopy for KeyTableStaticMetadata where
                TableMetadata: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy,
                u64: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy,
                u64: pmcopy {}
            #[verus::internal(verus_macro)]
            impl SpecPmSized for KeyTableStaticMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_size_of() -> ::builtin::nat {
                    let offset: ::builtin::nat =
                        ::builtin::spec_literal_integer("0");
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<TableMetadata>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <TableMetadata>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        (offset).spec_add(spec_padding_needed(offset,
                                <KeyTableStaticMetadata>::spec_align_of()));
                    offset
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_align_of() -> ::builtin::nat {
                    let alignment_seq =
                        <_ as
                                ::vstd::vstd::view::View>::view(&[<TableMetadata>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of()]);
                    nat_seq_max(alignment_seq)
                }
            }
            unsafe impl PmSized for KeyTableStaticMetadata {
                fn size_of() -> usize { Self::SIZE }
                fn align_of() -> usize { Self::ALIGN }
            }
            unsafe impl ConstPmSized for KeyTableStaticMetadata {
                const SIZE: usize =
                    {
                        let offset: usize = 0;
                        let offset: usize =
                            offset + <TableMetadata>::SIZE +
                                padding_needed(offset, <TableMetadata>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset +
                                padding_needed(offset, <KeyTableStaticMetadata>::ALIGN);
                        offset
                    };
                const ALIGN: usize =
                    {
                        let mut largest_alignment: usize = 0;
                        if largest_alignment <= <TableMetadata>::ALIGN {
                                largest_alignment = <TableMetadata>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        largest_alignment
                    };
            }
            const SIZE_CHECK_KEYTABLESTATICMETADATA: usize =
                (core::mem::size_of::<KeyTableStaticMetadata>() ==
                                <KeyTableStaticMetadata>::SIZE) as usize - 1;
            const ALIGN_CHECK_KEYTABLESTATICMETADATA: usize =
                (core::mem::align_of::<KeyTableStaticMetadata>() ==
                                <KeyTableStaticMetadata>::ALIGN) as usize - 1;
            unsafe impl UnsafeSpecPmSized for KeyTableStaticMetadata {}
            impl Clone for KeyTableStaticMetadata {
                fn clone(&self) -> Self {
                    Self {
                        table: self.table.clone(),
                        key_size: self.key_size.clone(),
                        row_cdb_start: self.row_cdb_start.clone(),
                        row_metadata_start: self.row_metadata_start.clone(),
                        row_metadata_end: self.row_metadata_end.clone(),
                        row_metadata_crc_start: self.row_metadata_crc_start.clone(),
                        row_key_start: self.row_key_start.clone(),
                        row_key_end: self.row_key_end.clone(),
                        row_key_crc_start: self.row_key_crc_start.clone(),
                    }
                }
            }
            impl PartialEq for KeyTableStaticMetadata {
                fn eq(&self, other: &Self) -> bool {
                    self.table == other.table && self.key_size == other.key_size
                                                && self.row_cdb_start == other.row_cdb_start &&
                                            self.row_metadata_start == other.row_metadata_start &&
                                        self.row_metadata_end == other.row_metadata_end &&
                                    self.row_metadata_crc_start == other.row_metadata_crc_start
                                && self.row_key_start == other.row_key_start &&
                            self.row_key_end == other.row_key_end &&
                        self.row_key_crc_start == other.row_key_crc_start
                }
            }
            impl Eq for KeyTableStaticMetadata {}
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_keytablestaticmetadata_clone(b: &KeyTableStaticMetadata)
                -> KeyTableStaticMetadata {
                ::builtin::ensures(|res: KeyTableStaticMetadata|
                        [::builtin::spec_eq(*b, res)]);
                b.clone()
            }
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_keytablestaticmetadata_eq(lhs: &KeyTableStaticMetadata,
                rhs: &KeyTableStaticMetadata) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
                lhs.eq(rhs)
            }
            #[verus::internal(verus_macro)]
            impl CloneProof for KeyTableStaticMetadata {
                #[verus::internal(verus_macro)]
                fn clone_provable(&self) -> KeyTableStaticMetadata {
                    ::builtin::ensures(|res: KeyTableStaticMetadata|
                            [::builtin::spec_eq(*self, res)]);
                    self.clone()
                }
            }
            #[verus::internal(verus_macro)]
            impl EqProof for KeyTableStaticMetadata {
                #[verus::internal(verus_macro)]
                fn eq_provable(&self, other: &Self) -> bool {
                    ::builtin::ensures(|b: bool|
                            [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                    self.eq(other)
                }
            }
            impl PmCopy for KeyTableStaticMetadata {}
            #[automatically_derived]
            impl ::core::marker::Copy for KeyTableStaticMetadata { }
            #[verus::internal(verus_macro)]
            impl KeyTableStaticMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn valid<K>(self) -> bool where K: PmCopy {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    ((((((((((self.table.valid()) &&
                                                                                                ((self.key_size).spec_gt(::builtin::spec_literal_nat("0"))))
                                                                                        && (::builtin::spec_eq(self.key_size, K::spec_size_of())))
                                                                                && ((self.table.start).spec_le(self.table.end))) &&
                                                                        (((self.row_cdb_start).spec_add(u64::spec_size_of())).spec_le(self.row_metadata_start)))
                                                                &&
                                                                (::builtin::spec_eq((self.row_metadata_end).spec_sub(self.row_metadata_start),
                                                                        KeyTableRowMetadata::spec_size_of()))) &&
                                                        ((self.row_metadata_end).spec_le(self.row_metadata_crc_start)))
                                                &&
                                                (((self.row_metadata_crc_start).spec_add(u64::spec_size_of())).spec_le(self.row_key_start)))
                                        &&
                                        (((self.row_key_start).spec_add(self.key_size)).spec_le(self.row_key_end)))
                                && ((self.row_key_end).spec_le(self.row_key_crc_start))) &&
                        (((self.row_key_crc_start).spec_add(u64::spec_size_of())).spec_le(self.table.row_size))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_start(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.start
                }
                #[verifier::when_used_as_spec(spec_start)]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn start(self) -> u64 {
                    ::builtin::ensures(|result: u64|
                            [::builtin::spec_eq(result, self.spec_start())]);
                    self.table.start
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_end(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.end
                }
                #[verifier::when_used_as_spec(spec_end)]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn end(self) -> u64 {
                    ::builtin::ensures(|result: u64|
                            [::builtin::spec_eq(result, self.spec_end())]);
                    self.table.end
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn num_rows(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.num_rows
                }
            }
            #[verifier::reject_recursive_types(K)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                pub(super) status: Ghost<KeyTableStatus>,
                pub(super) must_abort: Ghost<bool>,
                pub(super) sm: KeyTableStaticMetadata,
                pub(super) m: HashMap<K, ConcreteKeyInfo>,
                pub(super) free_list: Vec<u64>,
                pub(super) pending_deallocations: Vec<u64>,
                pub(super) memory_mapping: Ghost<KeyMemoryMapping<K>>,
                pub(super) undo_records: Vec<KeyUndoRecord<K>>,
                pub(super) phantom_pm: Ghost<core::marker::PhantomData<PM>>,
            }
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn view(&self) -> KeyTableView<K> {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    KeyTableView {
                        sm: self.sm,
                        used_slots: (self.sm.table.num_rows).spec_sub(self.free_list.len()),
                        durable: self.internal_view().apply_undo_records((self.undo_records.view()),
                                    self.sm).unwrap().as_snapshot(),
                        tentative: if (self.must_abort.view()) {
                                None
                            } else { Some(self.internal_view().as_snapshot()) },
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn valid(self, jv: JournalView) -> bool {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    (::builtin::is_variant((self.status.view()), "Quiescent"))
                        && (self.inv(jv))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn recover(s: Seq<u8>, sm: KeyTableStaticMetadata)
                    -> Option<KeyTableSnapshot<K>> {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    match KeyRecoveryMapping::<K>::new(s, sm) {
                        None => None,
                        Some(mapping) => Some(mapping.as_snapshot()),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_space_needed_for_setup(ps: SetupParameters,
                    min_start: nat) -> nat {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    let row_metadata_start = u64::spec_size_of();
                    let row_metadata_end =
                        (row_metadata_start).spec_add(KeyTableRowMetadata::spec_size_of());
                    let row_metadata_crc_start = row_metadata_end;
                    let row_metadata_crc_end =
                        (row_metadata_crc_start).spec_add(u64::spec_size_of());
                    let row_key_start = row_metadata_crc_end;
                    let row_key_end =
                        (row_key_start).spec_add(K::spec_size_of());
                    let row_key_crc_start = row_key_end;
                    let row_key_crc_end =
                        (row_key_crc_start).spec_add(u64::spec_size_of());
                    let row_size = row_key_crc_end;
                    let num_rows = ps.max_keys;
                    let table_size = (num_rows).spec_mul(row_size);
                    let initial_space =
                        if (min_start).spec_gt(u64::MAX) {
                                ::builtin::spec_literal_integer("0")
                            } else {
                               space_needed_for_alignment(::builtin::spec_cast_integer::<_,
                                           int>(min_start),
                                   ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()))
                           };
                    ::builtin::spec_cast_integer::<_,
                            nat>(((initial_space).spec_add(table_size)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn validate_key_addr(&self, addr: u64) -> bool {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.sm.table.validate_row_addr(addr)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn key_corresponds_to_key_addr(&self, k: K, addr: u64)
                    -> bool {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    (self.m.view()).contains_key(k) &&
                        ::builtin::spec_eq((self.m.view()).spec_index(k).row_addr,
                            addr)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn state_equivalent_for_me(s: Seq<u8>,
                    durable_state: Seq<u8>, constants: JournalConstants,
                    sm: KeyTableStaticMetadata) -> bool {
                    ((seqs_match_except_in_range(durable_state, s,
                                        ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                        ::builtin::spec_cast_integer::<_, int>(sm.end()))) &&
                                (Journal::<PM>::state_recovery_idempotent(s, constants))) &&
                        (::builtin::spec_eq(Self::recover(s, sm),
                                Self::recover(durable_state, sm)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn perm_factory_permits_states_equivalent_for_me<PermFactory>(&self,
                    jv: JournalView, perm_factory: PermFactory) -> bool where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                            ::builtin::imply({
                                    (Self::state_equivalent_for_me(s1, jv.durable_state,
                                                jv.constants, (self.view()).sm)) &&
                                        (Self::state_equivalent_for_me(s2, jv.durable_state,
                                                jv.constants, (self.view()).sm))
                                },
                                #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                    s2)))
                }
            }
        }
        mod inv_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::JournalView;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use std::hash::Hash;
            use super::impl_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum KeyTableStatus { Quiescent, Inconsistent, }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) struct ConcreteKeyInfo {
                pub row_addr: u64,
                pub rm: KeyTableRowMetadata,
            }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum KeyUndoRecord<K> {
                UndoCreate {
                    row_addr: u64,
                    k: K,
                },
                UndoUpdate {
                    row_addr: u64,
                    k: K,
                    former_rm: KeyTableRowMetadata,
                },
                UndoDelete {
                    row_addr: u64,
                    k: K,
                    rm: KeyTableRowMetadata,
                },
            }
            #[verus::internal(verus_macro)]
            impl<K> KeyUndoRecord<K> {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_rm(self) -> KeyTableRowMetadata {
                    ::builtin::get_variant_field(self, "UndoDelete", "rm")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_k(self) -> K {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_row_addr(self) -> u64 {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_former_rm(self) -> KeyTableRowMetadata {
                    ::builtin::get_variant_field(self, "UndoUpdate",
                        "former_rm")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoCreate_row_addr(self) -> u64 {
                    ::builtin::get_variant_field(self, "UndoCreate", "row_addr")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoCreate_k(self) -> K {
                    ::builtin::get_variant_field(self, "UndoCreate", "k")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoUpdate_row_addr(self) -> u64 {
                    ::builtin::get_variant_field(self, "UndoUpdate", "row_addr")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoUpdate_k(self) -> K {
                    ::builtin::get_variant_field(self, "UndoUpdate", "k")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoUpdate_former_rm(self)
                    -> KeyTableRowMetadata {
                    ::builtin::get_variant_field(self, "UndoUpdate",
                        "former_rm")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoDelete_row_addr(self) -> u64 {
                    ::builtin::get_variant_field(self, "UndoDelete", "row_addr")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoDelete_k(self) -> K {
                    ::builtin::get_variant_field(self, "UndoDelete", "k")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_UndoDelete_rm(self)
                    -> KeyTableRowMetadata {
                    ::builtin::get_variant_field(self, "UndoDelete", "rm")
                }
            }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum KeyRowDisposition<K> {
                InHashTable {
                    k: K,
                    rm: KeyTableRowMetadata,
                },
                InFreeList {
                    pos: nat,
                },
                InPendingDeallocationList {
                    pos: nat,
                },
            }
            #[verus::internal(verus_macro)]
            impl<K> KeyRowDisposition<K> {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_pos(self) -> nat {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_rm(self) -> KeyTableRowMetadata {
                    ::builtin::get_variant_field(self, "InHashTable", "rm")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_k(self) -> K {
                    ::builtin::get_variant_field(self, "InHashTable", "k")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InHashTable_k(self) -> K {
                    ::builtin::get_variant_field(self, "InHashTable", "k")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InHashTable_rm(self)
                    -> KeyTableRowMetadata {
                    ::builtin::get_variant_field(self, "InHashTable", "rm")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InFreeList_pos(self) -> nat {
                    ::builtin::get_variant_field(self, "InFreeList", "pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InPendingDeallocationList_pos(self)
                    -> nat {
                    ::builtin::get_variant_field(self,
                        "InPendingDeallocationList", "pos")
                }
            }
            #[verus::internal(verus_macro)]
            impl<K> KeyRowDisposition<K> {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn move_to_free_list_if_pending_deallocation(self,
                    free_list_len: nat) -> Self {
                    match self {
                        KeyRowDisposition::<K>::InPendingDeallocationList { pos } =>
                            KeyRowDisposition::<K>::InFreeList {
                                pos: (pos).spec_add(free_list_len),
                            },
                        _ => self,
                    }
                }
            }
            #[verifier::reject_recursive_types(K)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct KeyMemoryMapping<K> {
                pub row_info: Map<u64, KeyRowDisposition<K>>,
                pub key_info: Map<K, u64>,
                pub item_info: Map<u64, u64>,
                pub list_info: Map<u64, u64>,
            }
            #[verus::internal(verus_macro)]
            impl<K> KeyMemoryMapping<K> where K: Hash + Eq + Clone + PmCopy +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn new() -> Self {
                    Self {
                        row_info: Map::<u64, KeyRowDisposition<K>>::empty(),
                        key_info: Map::<K, u64>::empty(),
                        item_info: Map::<u64, u64>::empty(),
                        list_info: Map::<u64, u64>::empty(),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn initialize_row(self, row_addr: u64, k: K,
                    rm: KeyTableRowMetadata) -> Self {
                    let new_list_info =
                        if !::builtin::spec_eq(rm.list_addr,
                                        ::builtin::spec_literal_nat("0")) {
                                self.list_info.insert(rm.list_addr, row_addr)
                            } else { self.list_info };
                    Self {
                        row_info: self.row_info.insert(row_addr,
                            KeyRowDisposition::InHashTable { k, rm }),
                        key_info: self.key_info.insert(k, row_addr),
                        item_info: self.item_info.insert(rm.item_addr, row_addr),
                        list_info: new_list_info,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn corresponds_to_snapshot_at_addr(self,
                    m: KeyRecoveryMapping<K>, row_addr: u64) -> bool {
                    ((m.row_info.contains_key(row_addr)) &&
                                (self.row_info.contains_key(row_addr))) &&
                        (match self.row_info.spec_index(row_addr) {
                                KeyRowDisposition::InHashTable { k, rm } =>
                                    ::builtin::spec_eq(m.row_info.spec_index(row_addr),
                                        Some((k, rm))),
                                _ =>
                                    ::builtin::is_variant(m.row_info.spec_index(row_addr),
                                        "None"),
                            })
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn create(self, row_addr: u64, k: K,
                    rm: KeyTableRowMetadata) -> Self {
                    Self {
                        row_info: self.row_info.insert(row_addr,
                            KeyRowDisposition::InHashTable { k, rm }),
                        key_info: self.key_info.insert(k, row_addr),
                        item_info: self.item_info.insert(rm.item_addr, row_addr),
                        list_info: if ::builtin::spec_eq(rm.list_addr,
                                    ::builtin::spec_literal_nat("0")) {
                                self.list_info
                            } else { self.list_info.insert(rm.list_addr, row_addr) },
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn update(self, row_addr: u64, k: K,
                    rm: KeyTableRowMetadata, former_rm: KeyTableRowMetadata)
                    -> Self {
                    let list_info_after_remove =
                        if !::builtin::spec_eq(former_rm.list_addr,
                                        ::builtin::spec_literal_nat("0")) {
                                self.list_info.remove(former_rm.list_addr)
                            } else { self.list_info };
                    let new_list_info =
                        if !::builtin::spec_eq(rm.list_addr,
                                        ::builtin::spec_literal_nat("0")) {
                                list_info_after_remove.insert(rm.list_addr, row_addr)
                            } else { list_info_after_remove };
                    Self {
                        row_info: self.row_info.insert(row_addr,
                            KeyRowDisposition::InHashTable { k, rm }),
                        key_info: self.key_info.insert(k, row_addr),
                        item_info: self.item_info.remove(former_rm.item_addr).insert(rm.item_addr,
                            row_addr),
                        list_info: new_list_info,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn delete(self, row_addr: u64, k: K,
                    rm: KeyTableRowMetadata, pending_deallocation_list_len: nat)
                    -> Self {
                    ::builtin::recommends([self.row_info.contains_key(row_addr),
                                ::builtin::spec_eq(self.row_info.spec_index(row_addr),
                                    (KeyRowDisposition::InHashTable { k, rm }))]);
                    let rd =
                        KeyRowDisposition::InPendingDeallocationList {
                            pos: pending_deallocation_list_len,
                        };
                    Self {
                        row_info: self.row_info.insert(row_addr, rd),
                        key_info: self.key_info.remove(k),
                        item_info: self.item_info.remove(rm.item_addr),
                        list_info: if ::builtin::spec_eq(rm.list_addr,
                                    ::builtin::spec_literal_nat("0")) {
                                self.list_info
                            } else { self.list_info.remove(rm.list_addr) },
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn mark_in_free_list(self, row_addr: u64, pos: nat)
                    -> Self {
                    Self {
                        row_info: self.row_info.insert(row_addr,
                            KeyRowDisposition::InFreeList { pos }),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn move_pending_deallocations_to_free_list(self,
                    free_list_len: nat) -> Self {
                    Self {
                        row_info: self.row_info.map_values(::builtin::closure_to_fn_spec(|krd:
                                        KeyRowDisposition<K>|
                                    krd.move_to_free_list_if_pending_deallocation(free_list_len))),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn as_recovery_mapping(self) -> KeyRecoveryMapping<K> {
                    KeyRecoveryMapping::<K> {
                        row_info: Map::<u64,
                                Option<(K,
                                KeyTableRowMetadata)>>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64| self.row_info.contains_key(row_addr)),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    match self.row_info.spec_index(row_addr) {
                                        KeyRowDisposition::InHashTable { k, rm } => Some((k, rm)),
                                        _ => None,
                                    })),
                        key_info: Map::<K,
                                u64>::new(::builtin::closure_to_fn_spec(|k: K|
                                    self.key_info.contains_key(k)),
                            ::builtin::closure_to_fn_spec(|k: K|
                                    ::builtin::spec_cast_integer::<_,
                                            u64>(self.key_info.spec_index(k)))),
                        item_info: Map::<u64,
                                u64>::new(::builtin::closure_to_fn_spec(|item_addr: u64|
                                    self.item_info.contains_key(item_addr)),
                            ::builtin::closure_to_fn_spec(|item_addr: u64|
                                    ::builtin::spec_cast_integer::<_,
                                            u64>(self.item_info.spec_index(item_addr)))),
                        list_info: Map::<u64,
                                u64>::new(::builtin::closure_to_fn_spec(|list_addr: u64|
                                    self.list_info.contains_key(list_addr)),
                            ::builtin::closure_to_fn_spec(|list_addr: u64|
                                    ::builtin::spec_cast_integer::<_,
                                            u64>(self.list_info.spec_index(list_addr)))),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn as_snapshot(self) -> KeyTableSnapshot<K> {
                    KeyTableSnapshot::<K> {
                        key_info: Map::<K,
                                KeyTableRowMetadata>::new(::builtin::closure_to_fn_spec(|k:
                                        K| self.key_info.contains_key(k)),
                            ::builtin::closure_to_fn_spec(|k: K|
                                    (self.row_info.spec_index(self.key_info.spec_index(k)).arrow_rm()))),
                        item_info: Map::<u64,
                                K>::new(::builtin::closure_to_fn_spec(|item_addr: u64|
                                    self.item_info.contains_key(item_addr)),
                            ::builtin::closure_to_fn_spec(|item_addr: u64|
                                    (self.row_info.spec_index(self.item_info.spec_index(item_addr)).arrow_k()))),
                        list_info: Map::<u64,
                                K>::new(::builtin::closure_to_fn_spec(|list_addr: u64|
                                    self.list_info.contains_key(list_addr)),
                            ::builtin::closure_to_fn_spec(|list_addr: u64|
                                    (self.row_info.spec_index(self.list_info.spec_index(list_addr)).arrow_k()))),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn complete(self, sm: KeyTableStaticMetadata)
                    -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] sm.table.validate_row_addr(row_addr),
                                self.row_info.contains_key(row_addr)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn row_info_consistent(self,
                    sm: KeyTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                {
                                    (sm.table.validate_row_addr(row_addr)) &&
                                        (((if let KeyRowDisposition::InHashTable { k, rm } =
                                                                (self.row_info.spec_index(row_addr)) {
                                                            {
                                                                (((((self.key_info.contains_key(k)) &&
                                                                                                    (::builtin::spec_eq(self.key_info.spec_index(k), row_addr)))
                                                                                            && (self.item_info.contains_key(rm.item_addr))) &&
                                                                                    (::builtin::spec_eq(self.item_info.spec_index(rm.item_addr),
                                                                                            row_addr))) &&
                                                                            (::builtin::imply(!::builtin::spec_eq(rm.list_addr,
                                                                                            ::builtin::spec_literal_nat("0")),
                                                                                    self.list_info.contains_key(rm.list_addr)))) &&
                                                                    (::builtin::imply(!::builtin::spec_eq(rm.list_addr,
                                                                                    ::builtin::spec_literal_nat("0")),
                                                                            ::builtin::spec_eq(self.list_info.spec_index(rm.list_addr),
                                                                                row_addr)))
                                                            }
                                                        } else { true })))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn key_info_consistent(self) -> bool {
                    ::builtin::forall(|k: K|
                            ::builtin::imply(#[verus::internal(trigger)] self.key_info.contains_key(k),
                                {
                                    let row_addr = self.key_info.spec_index(k);
                                    (self.row_info.contains_key(row_addr)) &&
                                        (((if let KeyRowDisposition::InHashTable { k: k2, rm: _ } =
                                                                (self.row_info.spec_index(row_addr)) {
                                                            ::builtin::spec_eq(k, k2)
                                                        } else { false })))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn item_info_consistent(self) -> bool {
                    ::builtin::forall(|item_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.item_info.contains_key(item_addr),
                                {
                                    let row_addr = self.item_info.spec_index(item_addr);
                                    (self.row_info.contains_key(row_addr)) &&
                                        (((if let KeyRowDisposition::InHashTable { k: _, rm } =
                                                                (self.row_info.spec_index(row_addr)) {
                                                            ::builtin::spec_eq(rm.item_addr, item_addr)
                                                        } else { false })))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn list_info_consistent(self) -> bool {
                    (!self.list_info.contains_key(::builtin::spec_literal_integer("0")))
                        &&
                        (::builtin::forall(|list_addr: u64|
                                    ::builtin::imply(#[verus::internal(trigger)] self.list_info.contains_key(list_addr),
                                        {
                                            let row_addr = self.list_info.spec_index(list_addr);
                                            (self.row_info.contains_key(row_addr)) &&
                                                (((if let KeyRowDisposition::InHashTable { k: _, rm } =
                                                                        (self.row_info.spec_index(row_addr)) {
                                                                    ::builtin::spec_eq(rm.list_addr, list_addr)
                                                                } else { false })))
                                        })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent(self, sm: KeyTableStaticMetadata)
                    -> bool {
                    (((self.row_info_consistent(sm)) &&
                                        (self.key_info_consistent())) &&
                                (self.item_info_consistent())) &&
                        (self.list_info_consistent())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn valid(self, sm: KeyTableStaticMetadata)
                    -> bool {
                    (self.complete(sm)) && (self.consistent(sm))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_state(self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                {
                                    let cdb =
                                        recover_cdb(s, (row_addr).spec_add(sm.row_cdb_start));
                                    match self.row_info.spec_index(row_addr) {
                                        KeyRowDisposition::InHashTable { k, rm } => {
                                            ((::builtin::spec_eq(cdb, Some(true))) &&
                                                        (::builtin::spec_eq(recover_object::<K>(s,
                                                                    (row_addr).spec_add(sm.row_key_start),
                                                                    (row_addr).spec_add(::builtin::spec_cast_integer::<_,
                                                                                u64>(sm.row_key_crc_start))), Some(k)))) &&
                                                (::builtin::spec_eq(recover_object::<KeyTableRowMetadata>(s,
                                                            (row_addr).spec_add(sm.row_metadata_start),
                                                            (row_addr).spec_add(sm.row_metadata_crc_start)), Some(rm)))
                                        }
                                        _ => ::builtin::spec_eq(cdb, Some(false)),
                                    }
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_free_list_and_pending_deallocations(self,
                    free_list: Seq<u64>, pending_deallocations: Seq<u64>)
                    -> bool {
                    ((::builtin::forall(|row_addr: u64|
                                            ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                                {
                                                    match self.row_info.spec_index(row_addr) {
                                                        KeyRowDisposition::InFreeList { pos } => {
                                                            ((pos).spec_lt(free_list.len())) &&
                                                                (::builtin::spec_eq(free_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(pos)), row_addr))
                                                        }
                                                        KeyRowDisposition::InPendingDeallocationList { pos } => {
                                                            ((pos).spec_lt(pending_deallocations.len())) &&
                                                                (::builtin::spec_eq(pending_deallocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(pos)), row_addr))
                                                        }
                                                        _ => true,
                                                    }
                                                }))) &&
                                (::builtin::forall(|i: int|
                                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), free_list.len())),
                                                {
                                                    (self.row_info.contains_key(#[verus::internal(trigger)] free_list.spec_index(i)))
                                                        &&
                                                        (((if let KeyRowDisposition::InFreeList { pos } =
                                                                                (self.row_info.spec_index(free_list.spec_index(i))) {
                                                                            ::builtin::spec_eq(pos, i)
                                                                        } else { false })))
                                                })))) &&
                        (::builtin::forall(|i: int|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), pending_deallocations.len())),
                                        {
                                            (self.row_info.contains_key(#[verus::internal(trigger)] pending_deallocations.spec_index(i)))
                                                &&
                                                (((if let KeyRowDisposition::InPendingDeallocationList { pos
                                                                        } =
                                                                        (self.row_info.spec_index(pending_deallocations.spec_index(i)))
                                                                    {
                                                                    ::builtin::spec_eq(pos, i)
                                                                } else { false })))
                                        })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_hash_table(self,
                    m: Map<K, ConcreteKeyInfo>) -> bool {
                    (::builtin::forall(|row_addr: u64|
                                    ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                        {
                                            match self.row_info.spec_index(row_addr) {
                                                KeyRowDisposition::InHashTable { k, rm } => {
                                                    ((m.contains_key(k)) &&
                                                                (::builtin::spec_eq(m.spec_index(k).row_addr, row_addr))) &&
                                                        (::builtin::spec_eq(m.spec_index(k).rm, rm))
                                                }
                                                _ => true,
                                            }
                                        }))) &&
                        (::builtin::forall(|k: K|
                                    ::builtin::imply(#[verus::internal(trigger)] m.contains_key(k),
                                        {
                                            (self.row_info.contains_key(m.spec_index(k).row_addr)) &&
                                                (::builtin::spec_eq(self.row_info.spec_index(m.spec_index(k).row_addr),
                                                        (KeyRowDisposition::InHashTable {
                                                                k,
                                                                rm: m.spec_index(k).rm,
                                                            })))
                                        })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn undo_create(self, row_addr: u64, k: K,
                    rm: KeyTableRowMetadata, free_list_pos: nat)
                    -> Option<Self> {
                    if {
                                ((if let KeyRowDisposition::InHashTable { k: k2, rm: rm2 } =
                                                    (self.row_info.spec_index(row_addr)) {
                                                (::builtin::spec_eq(k, k2)) && (::builtin::spec_eq(rm, rm2))
                                            } else { false }))
                            } {
                            Some(Self {
                                    row_info: self.row_info.insert(row_addr,
                                        KeyRowDisposition::InFreeList { pos: free_list_pos }),
                                    key_info: self.key_info.remove(k),
                                    item_info: self.item_info.remove(rm.item_addr),
                                    list_info: self.list_info.remove(rm.list_addr),
                                    ..self
                                })
                        } else { None }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn undo_update(self, row_addr: u64, k: K,
                    former_rm: KeyTableRowMetadata) -> Option<Self> {
                    if {
                                ((if let KeyRowDisposition::InHashTable { k: k2, rm } =
                                                    (self.row_info.spec_index(row_addr)) {
                                                ::builtin::spec_eq(k, k2)
                                            } else { false }))
                            } {
                            let rm = (self.row_info.spec_index(row_addr).arrow_rm());
                            let list_info_after_remove =
                                if !::builtin::spec_eq(rm.list_addr,
                                                ::builtin::spec_literal_nat("0")) {
                                        self.list_info.remove(rm.list_addr)
                                    } else { self.list_info };
                            let new_list_info =
                                if !::builtin::spec_eq(former_rm.list_addr,
                                                ::builtin::spec_literal_nat("0")) {
                                        list_info_after_remove.insert(former_rm.list_addr, row_addr)
                                    } else { list_info_after_remove };
                            Some(Self {
                                    row_info: self.row_info.insert(row_addr,
                                        KeyRowDisposition::InHashTable { k, rm: former_rm }),
                                    item_info: self.item_info.remove(rm.item_addr).insert(former_rm.item_addr,
                                        row_addr),
                                    list_info: new_list_info,
                                    ..self
                                })
                        } else { None }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn undo_delete(self, row_addr: u64, k: K,
                    rm: KeyTableRowMetadata) -> Option<Self> {
                    if ((if let KeyRowDisposition::InPendingDeallocationList {
                                                pos } = (self.row_info.spec_index(row_addr)) {
                                            true
                                        } else { false })) {
                            Some(Self {
                                    row_info: self.row_info.insert(row_addr,
                                        KeyRowDisposition::InHashTable { k, rm }),
                                    key_info: self.key_info.insert(k, row_addr),
                                    item_info: self.item_info.insert(rm.item_addr, row_addr),
                                    list_info: if ::builtin::spec_eq(rm.list_addr,
                                                ::builtin::spec_literal_nat("0")) {
                                            self.list_info
                                        } else { self.list_info.insert(rm.list_addr, row_addr) },
                                })
                        } else { None }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_corresponds_implication_for_free_list_length(self,
                    free_list: Seq<u64>, sm: KeyTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<K>(), self.valid(sm),
                                self.consistent_with_free_list_and_pending_deallocations(free_list,
                                    Seq::<u64>::empty())]);
                    ::builtin::ensures([::builtin::spec_eq(self.as_recovery_mapping().key_info.dom(),
                                    self.key_info.dom()), self.key_info.dom().finite(),
                                ::builtin::spec_eq(self.key_info.dom().len(),
                                    (sm.table.num_rows).spec_sub(free_list.len()))]);
                    {
                        ::builtin::assert_forall_by(|pos: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pos), free_list.len())));
                                    ::builtin::ensures(self.row_info.contains_key(#[verus::internal(trigger)] free_list.spec_index(pos)));
                                    ::builtin::assert_(::builtin::is_variant(self.row_info.spec_index(free_list.spec_index(pos)),
                                            "InFreeList"));
                                    ::builtin::assert_(self.row_info.contains_key(free_list.spec_index(pos)));
                                });
                    }
                    let free_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.row_info.contains_key(row_addr) &&
                                        ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                            "InFreeList")));
                    let key_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.row_info.contains_key(row_addr) &&
                                        ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                            "InHashTable")));
                    let valid_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64| self.row_info.contains_key(row_addr)));
                    {
                        ::builtin::assert_by(valid_row_addrs.finite() &&
                                ::builtin::spec_eq(valid_row_addrs.len(),
                                    sm.table.num_rows),
                            {
                                ::builtin::assert_(::builtin::ext_equal(valid_row_addrs,
                                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                                        u64| sm.table.validate_row_addr(row_addr)))));
                                sm.table.lemma_valid_row_set_len();
                            });
                    }
                    {
                        ::builtin::assert_by(free_row_addrs.finite(),
                            {
                                vstd::set_lib::lemma_len_subset(free_row_addrs,
                                    valid_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(key_row_addrs.finite(),
                            {
                                vstd::set_lib::lemma_len_subset(key_row_addrs,
                                    valid_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(::builtin::spec_eq(valid_row_addrs.len(),
                                (free_row_addrs.len()).spec_add(key_row_addrs.len())),
                            {
                                ::builtin::assert_(free_row_addrs.disjoint(key_row_addrs));
                                ::builtin::assert_(::builtin::ext_equal((free_row_addrs).spec_add(key_row_addrs),
                                        valid_row_addrs));
                                vstd::set_lib::lemma_set_disjoint_lens(free_row_addrs,
                                    key_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(::builtin::spec_eq(free_row_addrs.len(),
                                free_list.len()),
                            {
                                ::builtin::assert_(::builtin::ext_equal(free_list.to_set(),
                                        free_row_addrs));
                                free_list.unique_seq_to_set();
                            });
                    }
                    {
                        ::builtin::assert_by(self.key_info.dom().finite() &&
                                ::builtin::spec_eq(self.key_info.dom().len(),
                                    key_row_addrs.len()),
                            {
                                lemma_bijection_makes_sets_have_equal_size::<u64,
                                        K>(key_row_addrs, self.key_info.dom(),
                                    ::builtin::closure_to_fn_spec(|row_addr: u64|
                                            (self.row_info.spec_index(row_addr).arrow_InHashTable_k())),
                                    ::builtin::closure_to_fn_spec(|k: K|
                                            self.key_info.spec_index(k)));
                            });
                    }
                    ::builtin::assert_(::builtin::spec_eq(self.key_info.dom().len(),
                            (sm.table.num_rows).spec_sub(free_list.len())));
                    ::builtin::assert_(::builtin::ext_equal(self.as_recovery_mapping().key_info.dom(),
                            self.key_info.dom()));
                }
            }
            #[verifier::reject_recursive_types(K)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) struct KeyInternalView<K> {
                pub m: Map<K, ConcreteKeyInfo>,
                pub free_list: Seq<u64>,
                pub pending_deallocations: Seq<u64>,
                pub memory_mapping: KeyMemoryMapping<K>,
            }
            #[verus::internal(verus_macro)]
            impl<K> KeyInternalView<K> where K: Hash + Eq + Clone + PmCopy +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn valid(self, sm: KeyTableStaticMetadata)
                    -> bool {
                    ((self.memory_mapping.valid(sm)) &&
                                (::builtin::forall(|k: K|
                                            ::builtin::imply(#[verus::internal(trigger)] self.memory_mapping.key_info.contains_key(k),
                                                {
                                                    let row_addr = self.memory_mapping.key_info.spec_index(k);
                                                    ((self.m.contains_key(k)) &&
                                                                (::builtin::spec_eq(self.m.spec_index(k).row_addr,
                                                                        row_addr))) &&
                                                        (((if let KeyRowDisposition::InHashTable { k: k2, rm } =
                                                                                (self.memory_mapping.row_info.spec_index(row_addr)) {
                                                                            (::builtin::spec_eq(k2, k)) &&
                                                                                (::builtin::spec_eq(rm, self.m.spec_index(k).rm))
                                                                        } else { false })))
                                                })))) &&
                        (::builtin::forall(|k: K|
                                    ::builtin::imply(#[verus::internal(trigger)] self.m.contains_key(k),
                                        self.memory_mapping.key_info.contains_key(k))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_journaled_addrs(self,
                    journaled_addrs: Set<int>, sm: KeyTableStaticMetadata)
                    -> bool {
                    ::builtin::forall(|i: int, addr: int|
                            ::builtin::with_triggers(((self.free_list.spec_index(i),
                                        journaled_addrs.contains(addr)),),
                                ::builtin::imply({
                                        let row_addr = self.free_list.spec_index(i);
                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), self.free_list.len()))) &&
                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                            addr), (row_addr).spec_add(sm.table.row_size))))
                                    }, !journaled_addrs.contains(addr))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn apply_undo_record(self,
                    record: KeyUndoRecord<K>) -> Option<Self> {
                    match record {
                        KeyUndoRecord::UndoCreate { row_addr, k } => {
                            if !self.memory_mapping.row_info.contains_key(row_addr) {
                                    None
                                } else {
                                   match self.memory_mapping.row_info.spec_index(row_addr) {
                                       KeyRowDisposition::InHashTable { k: k2, rm } => {
                                           match self.memory_mapping.undo_create(row_addr, k, rm,
                                                   self.free_list.len()) {
                                               Some(memory_mapping) =>
                                                   Some(Self {
                                                           m: self.m.remove(k),
                                                           free_list: self.free_list.push(row_addr),
                                                           memory_mapping,
                                                           ..self
                                                       }),
                                               None => None,
                                           }
                                       }
                                       _ => None,
                                   }
                               }
                        }
                        KeyUndoRecord::UndoUpdate { row_addr, k, former_rm } => {
                            if !self.memory_mapping.row_info.contains_key(row_addr) {
                                    None
                                } else {
                                   match self.memory_mapping.row_info.spec_index(row_addr) {
                                       KeyRowDisposition::InHashTable { k: k2, rm } => {
                                           match self.memory_mapping.undo_update(row_addr, k,
                                                   former_rm) {
                                               Some(memory_mapping) =>
                                                   Some(Self {
                                                           m: self.m.insert(k,
                                                               ConcreteKeyInfo { row_addr, rm: former_rm }),
                                                           memory_mapping,
                                                           ..self
                                                       }),
                                               None => None,
                                           }
                                       }
                                       _ => None,
                                   }
                               }
                        }
                        KeyUndoRecord::UndoDelete { row_addr, k, rm } => {
                            if !self.memory_mapping.row_info.contains_key(row_addr) {
                                    None
                                } else {
                                   match self.memory_mapping.row_info.spec_index(row_addr) {
                                       KeyRowDisposition::InPendingDeallocationList { pos } => {
                                           if !::builtin::spec_eq((pos).spec_add(::builtin::spec_literal_nat("1")),
                                                           self.pending_deallocations.len()) {
                                                   None
                                               } else {
                                                  match self.memory_mapping.undo_delete(row_addr, k, rm) {
                                                      Some(memory_mapping) =>
                                                          Some(Self {
                                                                  m: self.m.insert(k, ConcreteKeyInfo { row_addr, rm }),
                                                                  pending_deallocations: self.pending_deallocations.drop_last(),
                                                                  memory_mapping,
                                                                  ..self
                                                              }),
                                                      None => None,
                                                  }
                                              }
                                       }
                                       _ => None,
                                   }
                               }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn apply_undo_records(self,
                    records: Seq<KeyUndoRecord<K>>, sm: KeyTableStaticMetadata)
                    -> Option<Self> {
                    ::builtin::decreases((records.len()));
                    if ::builtin::spec_eq(records.len(),
                                ::builtin::spec_literal_nat("0")) {
                            Some(self)
                        } else {
                           match self.apply_undo_record(records.last()) {
                               Some(new_self) =>
                                   if new_self.valid(sm) {
                                           new_self.apply_undo_records(records.drop_last(), sm)
                                       } else { None },
                               None => None,
                           }
                       }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_state(self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    ((self.memory_mapping.valid(sm)) &&
                                (self.memory_mapping.consistent_with_state(s, sm))) &&
                        (self.memory_mapping.consistent_with_free_list_and_pending_deallocations(self.free_list,
                                self.pending_deallocations))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_state_after_undo(self,
                    undo_records: Seq<KeyUndoRecord<K>>, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    ((if let Some(undone_self) =
                                        (self.apply_undo_records(undo_records, sm)) {
                                    ((undone_self.valid(sm)) &&
                                                (undone_self.consistent_with_state(s, sm))) &&
                                        (::builtin::spec_eq(undone_self.pending_deallocations,
                                                Seq::<u64>::empty()))
                                } else { false }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn as_snapshot(self) -> KeyTableSnapshot<K> {
                    self.memory_mapping.as_snapshot()
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_apply_undo_records_only_appends_to_free_list(self,
                    undo_records: Seq<KeyUndoRecord<K>>,
                    sm: KeyTableStaticMetadata) {
                    ::builtin::ensures([((if let Some(new_self) =
                                                    (self.apply_undo_records(undo_records, sm)) {
                                                {
                                                    ((new_self.free_list.len()).spec_ge(self.free_list.len()))
                                                        &&
                                                        (::builtin::forall(|i: int|
                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                    i), self.free_list.len())),
                                                                        ::builtin::spec_eq(new_self.free_list.spec_index(i),
                                                                            self.free_list.spec_index(i)))))
                                                }
                                            } else { true }))]);
                    ::builtin::decreases((undo_records.len()));
                    if (undo_records.len()).spec_gt(::builtin::spec_literal_nat("0"))
                            {
                            let next_self = self.apply_undo_record(undo_records.last());
                            if ::builtin::is_variant(next_self, "Some") {
                                    let next_self = next_self.unwrap();
                                    if next_self.valid(sm) {
                                            ::builtin::assert_((next_self.free_list.len()).spec_ge(self.free_list.len()));
                                            ::builtin::assert_(::builtin::forall(|i: int|
                                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        i), self.free_list.len())),
                                                            ::builtin::spec_eq(next_self.free_list.spec_index(i),
                                                                self.free_list.spec_index(i)))));
                                            next_self.lemma_apply_undo_records_only_appends_to_free_list(undo_records.drop_last(),
                                                sm);
                                        }
                                }
                        }
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn internal_view(self) -> KeyInternalView<K> {
                    KeyInternalView::<K> {
                        m: (self.m.view()),
                        free_list: (self.free_list.view()),
                        pending_deallocations: (self.pending_deallocations.view()),
                        memory_mapping: (self.memory_mapping.view()),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn inv(self, jv: JournalView) -> bool {
                    ((((((((vstd::std_specs::hash::obeys_key_model::<K>()) &&
                                                                                (self.sm.valid::<K>())) &&
                                                                        ((jv.constants.app_area_start).spec_le(self.sm.start()))) &&
                                                                ((self.sm.end()).spec_le(jv.constants.app_area_end))) &&
                                                        (self.internal_view().valid(self.sm))) &&
                                                (::builtin::imply(!(::builtin::is_variant((self.status.view()),
                                                                        "Inconsistent")) && !(self.must_abort.view()),
                                                        {
                                                            (self.internal_view().consistent_with_state(jv.commit_state,
                                                                        self.sm)) &&
                                                                (self.internal_view().consistent_with_journaled_addrs(jv.journaled_addrs,
                                                                        self.sm))
                                                        }))) &&
                                        (self.internal_view().consistent_with_state_after_undo((self.undo_records.view()),
                                                jv.durable_state, self.sm))) &&
                                (::builtin::forall(|i: int|
                                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), (self.free_list.view()).len())),
                                                self.sm.table.validate_row_addr(#[verus::internal(trigger)] (self.free_list.view()).spec_index(i))))))
                        &&
                        (::builtin::forall(|i: int|
                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), (self.pending_deallocations.view()).len())),
                                        self.sm.table.validate_row_addr(#[verus::internal(trigger)] (self.pending_deallocations.view()).spec_index(i)))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_valid_depends_only_on_my_area(&self,
                    old_jv: JournalView, new_jv: JournalView) {
                    ::builtin::requires([self.valid(old_jv),
                                ::builtin::spec_eq(old_jv.constants, new_jv.constants),
                                old_jv.matches_in_range(new_jv,
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.end()))]);
                    ::builtin::ensures([self.valid(new_jv)]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(self.valid(new_jv));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_valid_implications(&self, jv: JournalView) {
                    ::builtin::requires([self.valid(jv)]);
                    ::builtin::ensures([(self.view()).durable.valid(),
                                ((if let Some(tentative) = ((self.view()).tentative) {
                                                tentative.valid()
                                            } else { true })),
                                ::builtin::spec_eq(Self::recover(jv.durable_state,
                                        (self.view()).sm), Some((self.view()).durable)),
                                ::builtin::imply(::builtin::is_variant((self.view()).tentative,
                                        "Some"),
                                    ::builtin::spec_eq(Self::recover(jv.commit_state,
                                            (self.view()).sm), (self.view()).tentative))]);
                    {
                        ::builtin::assert_by(::builtin::is_variant(Self::recover(jv.durable_state,
                                    (self.view()).sm), "Some"),
                            {
                                self.internal_view().apply_undo_records((self.undo_records.view()),
                                                    self.sm).unwrap().memory_mapping.as_recovery_mapping().lemma_corresponds_implies_equals_new(jv.durable_state,
                                    (self.view()).sm);
                            });
                    }
                    ::builtin::assert_(::builtin::ext_equal(Self::recover(jv.durable_state,
                                (self.view()).sm), Some((self.view()).durable)));
                    if ::builtin::is_variant((self.view()).tentative, "Some") {
                            {
                                ::builtin::assert_by(::builtin::is_variant(Self::recover(jv.commit_state,
                                            (self.view()).sm), "Some"),
                                    {
                                        (self.memory_mapping.view()).as_recovery_mapping().lemma_corresponds_implies_equals_new(jv.commit_state,
                                            (self.view()).sm);
                                    });
                            }
                            ::builtin::assert_(::builtin::ext_equal(Self::recover(jv.commit_state,
                                        (self.view()).sm), (self.view()).tentative));
                        }
                }
            }
        }
        mod recover_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use std::hash::Hash;
            use super::impl_v::*;
            use super::spec_v::*;
            #[verifier::reject_recursive_types(K)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct KeyRecoveryMapping<K> where K: Hash + Eq + Clone +
                PmCopy + std::fmt::Debug {
                pub row_info: Map<u64, Option<(K, KeyTableRowMetadata)>>,
                pub key_info: Map<K, u64>,
                pub item_info: Map<u64, u64>,
                pub list_info: Map<u64, u64>,
            }
            #[verus::internal(verus_macro)]
            impl<K> KeyRecoveryMapping<K> where K: Hash + Eq + Clone +
                PmCopy + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn new(s: Seq<u8>, sm: KeyTableStaticMetadata)
                    -> Option<Self> {
                    if ::builtin::exists(|mapping: Self|
                                    mapping.corresponds(s, sm)) {
                            Some(::builtin::choose::<KeyRecoveryMapping<K>,
                                        _>(|mapping: KeyRecoveryMapping<K>|
                                        mapping.corresponds(s, sm)))
                        } else { None }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn new_empty(tm: TableMetadata) -> Self {
                    let row_info =
                        Map::<u64,
                                Option<(K,
                                KeyTableRowMetadata)>>::new(::builtin::closure_to_fn_spec(|addr:
                                        u64| tm.validate_row_addr(addr)),
                            ::builtin::closure_to_fn_spec(|addr: u64| None));
                    Self {
                        row_info,
                        key_info: Map::<K, u64>::empty(),
                        item_info: Map::<u64, u64>::empty(),
                        list_info: Map::<u64, u64>::empty(),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn row_info_corresponds(self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    (::builtin::forall(|row_addr: u64|
                                    ::builtin::imply(#[verus::internal(trigger)] sm.table.validate_row_addr(row_addr),
                                        self.row_info.contains_key(row_addr)))) &&
                        (::builtin::forall(|row_addr: u64|
                                    ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                        {
                                            let cdb =
                                                recover_cdb(s, (row_addr).spec_add(sm.row_cdb_start));
                                            (sm.table.validate_row_addr(row_addr)) &&
                                                (match self.row_info.spec_index(row_addr) {
                                                        None => ::builtin::spec_eq(cdb, Some(false)),
                                                        Some((k, rm)) => {
                                                            ((((((((::builtin::spec_eq(cdb, Some(true))) &&
                                                                                                                        (::builtin::spec_eq(recover_object::<K>(s,
                                                                                                                                    (row_addr).spec_add(sm.row_key_start),
                                                                                                                                    (row_addr).spec_add(::builtin::spec_cast_integer::<_,
                                                                                                                                                u64>(sm.row_key_crc_start))), Some(k)))) &&
                                                                                                                (::builtin::spec_eq(recover_object::<KeyTableRowMetadata>(s,
                                                                                                                            (row_addr).spec_add(sm.row_metadata_start),
                                                                                                                            (row_addr).spec_add(sm.row_metadata_crc_start)), Some(rm))))
                                                                                                        && (self.key_info.contains_key(k))) &&
                                                                                                (::builtin::spec_eq(self.key_info.spec_index(k), row_addr)))
                                                                                        && (self.item_info.contains_key(rm.item_addr))) &&
                                                                                (::builtin::spec_eq(self.item_info.spec_index(rm.item_addr),
                                                                                        row_addr))) &&
                                                                        (::builtin::imply(!::builtin::spec_eq(rm.list_addr,
                                                                                        ::builtin::spec_literal_nat("0")),
                                                                                self.list_info.contains_key(rm.list_addr)))) &&
                                                                (::builtin::imply(!::builtin::spec_eq(rm.list_addr,
                                                                                ::builtin::spec_literal_nat("0")),
                                                                        ::builtin::spec_eq(self.list_info.spec_index(rm.list_addr),
                                                                            row_addr)))
                                                        }
                                                    })
                                        })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn key_info_corresponds(self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    ::builtin::forall(|k: K|
                            ::builtin::imply(#[verus::internal(trigger)] self.key_info.contains_key(k),
                                {
                                    let row_addr = self.key_info.spec_index(k);
                                    (sm.table.validate_row_addr(row_addr)) &&
                                        (((if let Some((k2, _)) =
                                                                (self.row_info.spec_index(row_addr)) {
                                                            ::builtin::spec_eq(k2, k)
                                                        } else { false })))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn item_info_corresponds(self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    ::builtin::forall(|item_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.item_info.contains_key(item_addr),
                                {
                                    let row_addr = self.item_info.spec_index(item_addr);
                                    (sm.table.validate_row_addr(row_addr)) &&
                                        (((if let Some((_, rm)) =
                                                                (self.row_info.spec_index(row_addr)) {
                                                            ::builtin::spec_eq(rm.item_addr, item_addr)
                                                        } else { false })))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn list_info_corresponds(self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    (!self.list_info.contains_key(::builtin::spec_literal_integer("0")))
                        &&
                        (::builtin::forall(|list_addr: u64|
                                    ::builtin::imply(#[verus::internal(trigger)] self.list_info.contains_key(list_addr),
                                        {
                                            let row_addr = self.list_info.spec_index(list_addr);
                                            (sm.table.validate_row_addr(row_addr)) &&
                                                (((if let Some((_, rm)) =
                                                                        (self.row_info.spec_index(row_addr)) {
                                                                    ::builtin::spec_eq(rm.list_addr, list_addr)
                                                                } else { false })))
                                        })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn corresponds(self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) -> bool {
                    (((self.row_info_corresponds(s, sm)) &&
                                        (self.key_info_corresponds(s, sm))) &&
                                (self.item_info_corresponds(s, sm))) &&
                        (self.list_info_corresponds(s, sm))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn as_snapshot(self) -> KeyTableSnapshot<K> {
                    KeyTableSnapshot::<K> {
                        key_info: Map::<K,
                                KeyTableRowMetadata>::new(::builtin::closure_to_fn_spec(|k:
                                        K| self.key_info.contains_key(k)),
                            ::builtin::closure_to_fn_spec(|k: K|
                                    self.row_info.spec_index(self.key_info.spec_index(k)).unwrap().1)),
                        item_info: Map::<u64,
                                K>::new(::builtin::closure_to_fn_spec(|item_addr: u64|
                                    self.item_info.contains_key(item_addr)),
                            ::builtin::closure_to_fn_spec(|item_addr: u64|
                                    self.row_info.spec_index(self.item_info.spec_index(item_addr)).unwrap().0)),
                        list_info: Map::<u64,
                                K>::new(::builtin::closure_to_fn_spec(|list_addr: u64|
                                    self.list_info.contains_key(list_addr)),
                            ::builtin::closure_to_fn_spec(|list_addr: u64|
                                    self.row_info.spec_index(self.list_info.spec_index(list_addr)).unwrap().0)),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_uniqueness(self, other: Self, s: Seq<u8>,
                    sm: KeyTableStaticMetadata) {
                    ::builtin::requires([self.corresponds(s, sm),
                                other.corresponds(s, sm)]);
                    ::builtin::ensures([::builtin::spec_eq(self, other)]);
                    ::builtin::assert_(::builtin::ext_equal(self, other));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_corresponds_implies_equals_new(self,
                    s: Seq<u8>, sm: KeyTableStaticMetadata) {
                    ::builtin::requires([self.corresponds(s, sm)]);
                    ::builtin::ensures([::builtin::spec_eq(Self::new(s, sm),
                                    Some(self))]);
                    self.lemma_uniqueness(Self::new(s, sm).unwrap(), s, sm);
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_recover_depends_only_on_my_area_if_some(s1: Seq<u8>,
                    s2: Seq<u8>, sm: KeyTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<K>(),
                                (sm.end()).spec_le(s1.len()),
                                seqs_match_in_range(s1, s2,
                                    ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                    ::builtin::spec_cast_integer::<_, int>(sm.end())),
                                ::builtin::is_variant(Self::recover(s1, sm), "Some")]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(s1,
                                        sm), Self::recover(s2, sm))]);
                    let mapping1 =
                        KeyRecoveryMapping::<K>::new(s1, sm).unwrap();
                    {
                        ::builtin::assert_by(mapping1.corresponds(s2, sm),
                            {
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                            });
                    }
                    mapping1.lemma_corresponds_implies_equals_new(s2, sm);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_recover_depends_only_on_my_area(s1: Seq<u8>,
                    s2: Seq<u8>, sm: KeyTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<K>(),
                                (sm.end()).spec_le(s1.len()),
                                seqs_match_in_range(s1, s2,
                                    ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                    ::builtin::spec_cast_integer::<_, int>(sm.end()))]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(s1,
                                        sm), Self::recover(s2, sm))]);
                    if ::builtin::is_variant(Self::recover(s1, sm), "Some") {
                            Self::lemma_recover_depends_only_on_my_area_if_some(s1, s2,
                                sm);
                        } else if ::builtin::is_variant(Self::recover(s2, sm),
                               "Some") {
                           Self::lemma_recover_depends_only_on_my_area_if_some(s2, s1,
                               sm);
                       }
                }
            }
        }
        mod setup_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::align_v::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use std::hash::Hash;
            use super::impl_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            use vstd::arithmetic::overflow::CheckedU64;
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn space_needed_for_setup(ps: &SetupParameters,
                    min_start: &CheckedU64) -> CheckedU64 {
                    ::builtin::ensures(|result: CheckedU64|
                            [::builtin::spec_eq((result.view()),
                                        Self::spec_space_needed_for_setup(*ps,
                                            (min_start.view())))]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    let row_metadata_start =
                        CheckedU64::new(size_of::<u64>() as u64);
                    let row_metadata_end =
                        row_metadata_start.add_value(size_of::<KeyTableRowMetadata>()
                                as u64);
                    let row_metadata_crc_end =
                        row_metadata_end.add_value(size_of::<u64>() as u64);
                    let row_key_end =
                        row_metadata_crc_end.add_value(size_of::<K>() as u64);
                    let row_key_crc_end =
                        row_key_end.add_value(size_of::<u64>() as u64);
                    let num_rows = CheckedU64::new(ps.max_keys);
                    let table_size = num_rows.mul_checked(&row_key_crc_end);
                    let initial_space: u64 =
                        if min_start.is_overflowed() {
                                0u64
                            } else {
                               get_space_needed_for_alignment_usize(min_start.unwrap(),
                                       size_of::<u64>()) as u64
                           };
                    CheckedU64::new(initial_space).add_checked(&table_size)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn setup_given_metadata(pm: &mut PM,
                    sm: &KeyTableStaticMetadata) {
                    ::builtin::requires([old(pm).inv(),
                                (old(pm).view()).valid(), sm.valid::<K>(),
                                (sm.table.end).spec_le((old(pm).view()).len())]);
                    ::builtin::ensures([pm.inv(),
                                ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                (pm.view()).valid(),
                                ::builtin::spec_eq((pm.view()).len(),
                                    (old(pm).view()).len()),
                                ::builtin::spec_eq(Self::recover((pm.view()).read_state,
                                        *sm), Some(KeyTableSnapshot::<K>::init())),
                                seqs_match_except_in_range((old(pm).view()).read_state,
                                    (pm.view()).read_state,
                                    ::builtin::spec_cast_integer::<_, int>(sm.table.start),
                                    ::builtin::spec_cast_integer::<_, int>(sm.table.end))]);
                    let mut row_index: u64 = 0;
                    let mut row_addr: u64 = sm.table.start;
                    let cdb_false: u64 = CDB_FALSE;

                    #[verifier::proof_block]
                    { sm.table.lemma_start_is_valid_row(); }
                    while row_index < sm.table.num_rows {
                        ::builtin::invariant([pm.inv(),
                                    ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                    (pm.view()).valid(),
                                    ::builtin::spec_eq((pm.view()).len(),
                                        (old(pm).view()).len()), sm.valid::<K>(),
                                    (sm.table.end).spec_le((pm.view()).len()),
                                    ::builtin::spec_eq(cdb_false, CDB_FALSE),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                row_index), sm.table.num_rows)),
                                    ::builtin::spec_eq(sm.table.row_addr_to_index(row_addr),
                                        ::builtin::spec_cast_integer::<_, int>(row_index)),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(sm.table.start),
                                                row_addr), sm.table.end)),
                                    ::builtin::imply((row_index).spec_lt(sm.table.num_rows),
                                        sm.table.validate_row_addr(row_addr)),
                                    ::builtin::forall(|any_row_addr: u64|
                                            ::builtin::imply({
                                                    (#[verus::internal(trigger)] sm.table.validate_row_addr(any_row_addr))
                                                        &&
                                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        sm.table.row_addr_to_index(any_row_addr)), row_index)))
                                                },
                                                ::builtin::spec_eq(recover_cdb((pm.view()).read_state,
                                                        (any_row_addr).spec_add(sm.row_cdb_start)), Some(false)))),
                                    seqs_match_except_in_range((old(pm).view()).read_state,
                                        (pm.view()).read_state,
                                        ::builtin::spec_cast_integer::<_, int>(sm.table.start),
                                        ::builtin::spec_cast_integer::<_, int>(sm.table.end))]);

                        #[verifier::proof_block]
                        {
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            sm.table.lemma_row_addr_successor_is_valid(row_addr);
                        }
                        let cdb_addr = row_addr + sm.row_cdb_start;
                        pm.serialize_and_write::<u64>(cdb_addr, &cdb_false);

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::spec_eq(recover_cdb((pm.view()).read_state,
                                                (row_addr).spec_add(sm.row_cdb_start)), Some(false)))
                                };
                        };
                        row_index = row_index + 1;
                        row_addr = row_addr + sm.table.row_size;
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_forall_by(|row_addr: u64|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] sm.table.validate_row_addr(row_addr));
                                                ::builtin::ensures(::builtin::spec_eq(recover_cdb((pm.view()).read_state,
                                                            (row_addr).spec_add(sm.row_cdb_start)), Some(false)));
                                                let row_index = sm.table.row_addr_to_index(row_addr);
                                                {
                                                    ::builtin::reveal_hide_({
                                                            #[verus::internal(reveal_fn)]
                                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                            }

                                                            #[verus::internal(broadcast_use_reveal)]
                                                            __VERUS_REVEAL_INTERNAL__
                                                        }, 1);
                                                }
                                            });
                                }
                            };
                    }
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp = KeyRecoveryMapping::<K>::new_empty(sm.table)
                    };
                    #[verus::internal(spec)]
                    let mut mapping;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_mapping = verus_tmp;
                        mapping = verus_tmp_mapping;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(KeyRecoveryMapping::<K>::new((pm.view()).read_state,
                                                *sm), Some(mapping)),
                                        {
                                            ::builtin::assert_(mapping.corresponds((pm.view()).read_state,
                                                    *sm));
                                            mapping.lemma_corresponds_implies_equals_new((pm.view()).read_state,
                                                *sm);
                                        });
                                }
                            };
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(mapping.as_snapshot(),
                                        KeyTableSnapshot::<K>::init()))
                            };
                    };
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn setup(pm: &mut PM, ps: &SetupParameters,
                    min_start: u64, max_end: u64)
                    -> Result<KeyTableStaticMetadata, KvError> {
                    ::builtin::requires([old(pm).inv(),
                                (old(pm).view()).valid(), ps.valid(),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(min_start),
                                            max_end), (old(pm).view()).len()))]);
                    ::builtin::ensures(|result:
                                Result<KeyTableStaticMetadata, KvError>|
                            [pm.inv(),
                                    ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                    (pm.view()).valid(),
                                    ::builtin::spec_eq((pm.view()).len(),
                                        (old(pm).view()).len()),
                                    match result {
                                        Ok(sm) => {
                                            (((((::builtin::spec_eq(Self::recover((pm.view()).read_state,
                                                                                            sm), Some(KeyTableSnapshot::<K>::init()))) &&
                                                                                (seqs_match_except_in_range((old(pm).view()).read_state,
                                                                                        (pm.view()).read_state,
                                                                                        ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                                                                        ::builtin::spec_cast_integer::<_, int>(sm.end())))) &&
                                                                        (sm.valid::<K>())) &&
                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(min_start),
                                                                                    sm.start()), sm.end()), max_end)))) &&
                                                        (::builtin::spec_eq((sm.end()).spec_sub(min_start),
                                                                Self::spec_space_needed_for_setup(*ps,
                                                                    ::builtin::spec_cast_integer::<_, nat>(min_start))))) &&
                                                (::builtin::spec_eq(sm.num_rows(), ps.max_keys))
                                        }
                                        Err(KvError::KeySizeTooSmall) =>
                                            ::builtin::spec_eq(K::spec_size_of(),
                                                ::builtin::spec_literal_nat("0")),
                                        Err(KvError::OutOfSpace) =>
                                            ((max_end).spec_sub(min_start)).spec_lt(Self::spec_space_needed_for_setup(*ps,
                                                    ::builtin::spec_cast_integer::<_, nat>(min_start))),
                                        _ => false,
                                    }]);
                    let key_size = size_of::<K>();
                    if key_size == 0 {

                            #[verus::internal(proof_block)]
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(axiom_bytes_len)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            return Err(KvError::KeySizeTooSmall);
                        }
                    let row_cdb_start = CheckedU64::new(0);
                    let row_metadata_start =
                        row_cdb_start.add_value(size_of::<u64>() as u64);
                    let row_metadata_end =
                        row_metadata_start.add_value(size_of::<KeyTableRowMetadata>()
                                as u64);
                    let row_metadata_crc_end =
                        row_metadata_end.add_value(size_of::<u64>() as u64);
                    let row_key_end =
                        row_metadata_crc_end.add_value(key_size as u64);
                    let row_key_crc_end =
                        row_key_end.add_value(size_of::<u64>() as u64);
                    let start =
                        align_checked_u64_to_usize(&CheckedU64::new(min_start),
                            size_of::<u64>());
                    let num_rows = ps.max_keys;
                    let space_required =
                        CheckedU64::new(num_rows).mul_checked(&row_key_crc_end);
                    let end = start.add_checked(&space_required);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(((end.view())).spec_sub((min_start.view())),
                                        Self::spec_space_needed_for_setup(*ps,
                                            ::builtin::spec_cast_integer::<_, nat>(min_start))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(((space_required.view())).spec_ge((row_key_crc_end.view())),
                                        {
                                            vstd::arithmetic::mul::lemma_mul_ordering(::builtin::spec_cast_integer::<_,
                                                        int>(num_rows),
                                                ::builtin::spec_cast_integer::<_,
                                                        int>((row_key_crc_end.view())));
                                        });
                                }
                            };
                    }
                    if end.is_overflowed() { return Err(KvError::OutOfSpace); }
                    if end.unwrap() > max_end {
                            return Err(KvError::OutOfSpace);
                        }
                    let table =
                        TableMetadata::new(start.unwrap(), end.unwrap(), num_rows,
                            row_key_crc_end.unwrap());
                    let sm =
                        KeyTableStaticMetadata {
                            table,
                            key_size: key_size as u64,
                            row_cdb_start: 0,
                            row_metadata_start: row_metadata_start.unwrap(),
                            row_metadata_end: row_metadata_end.unwrap(),
                            row_metadata_crc_start: row_metadata_end.unwrap(),
                            row_key_start: row_metadata_crc_end.unwrap(),
                            row_key_end: row_key_end.unwrap(),
                            row_key_crc_start: row_key_end.unwrap(),
                        };
                    Self::setup_given_metadata(pm, &sm);
                    Ok(sm)
                }
            }
        }
        mod spec_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::util_v::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use deps_hack::PmCopy;
            use super::impl_v::*;
            #[repr(C)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct KeyTableRowMetadata {
                pub item_addr: u64,
                pub list_addr: u64,
            }
            unsafe impl pmcopy for KeyTableRowMetadata where u64: pmcopy,
                u64: pmcopy {}
            #[verus::internal(verus_macro)]
            impl SpecPmSized for KeyTableRowMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_size_of() -> ::builtin::nat {
                    let offset: ::builtin::nat =
                        ::builtin::spec_literal_integer("0");
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        (offset).spec_add(spec_padding_needed(offset,
                                <KeyTableRowMetadata>::spec_align_of()));
                    offset
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_align_of() -> ::builtin::nat {
                    let alignment_seq =
                        <_ as
                                ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of(),
                                        <u64>::spec_align_of()]);
                    nat_seq_max(alignment_seq)
                }
            }
            unsafe impl PmSized for KeyTableRowMetadata {
                fn size_of() -> usize { Self::SIZE }
                fn align_of() -> usize { Self::ALIGN }
            }
            unsafe impl ConstPmSized for KeyTableRowMetadata {
                const SIZE: usize =
                    {
                        let offset: usize = 0;
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset +
                                padding_needed(offset, <KeyTableRowMetadata>::ALIGN);
                        offset
                    };
                const ALIGN: usize =
                    {
                        let mut largest_alignment: usize = 0;
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        largest_alignment
                    };
            }
            const SIZE_CHECK_KEYTABLEROWMETADATA: usize =
                (core::mem::size_of::<KeyTableRowMetadata>() ==
                                <KeyTableRowMetadata>::SIZE) as usize - 1;
            const ALIGN_CHECK_KEYTABLEROWMETADATA: usize =
                (core::mem::align_of::<KeyTableRowMetadata>() ==
                                <KeyTableRowMetadata>::ALIGN) as usize - 1;
            unsafe impl UnsafeSpecPmSized for KeyTableRowMetadata {}
            impl Clone for KeyTableRowMetadata {
                fn clone(&self) -> Self {
                    Self {
                        item_addr: self.item_addr.clone(),
                        list_addr: self.list_addr.clone(),
                    }
                }
            }
            impl PartialEq for KeyTableRowMetadata {
                fn eq(&self, other: &Self) -> bool {
                    self.item_addr == other.item_addr &&
                        self.list_addr == other.list_addr
                }
            }
            impl Eq for KeyTableRowMetadata {}
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_keytablerowmetadata_clone(b: &KeyTableRowMetadata)
                -> KeyTableRowMetadata {
                ::builtin::ensures(|res: KeyTableRowMetadata|
                        [::builtin::spec_eq(*b, res)]);
                b.clone()
            }
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_keytablerowmetadata_eq(lhs: &KeyTableRowMetadata,
                rhs: &KeyTableRowMetadata) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
                lhs.eq(rhs)
            }
            #[verus::internal(verus_macro)]
            impl CloneProof for KeyTableRowMetadata {
                #[verus::internal(verus_macro)]
                fn clone_provable(&self) -> KeyTableRowMetadata {
                    ::builtin::ensures(|res: KeyTableRowMetadata|
                            [::builtin::spec_eq(*self, res)]);
                    self.clone()
                }
            }
            #[verus::internal(verus_macro)]
            impl EqProof for KeyTableRowMetadata {
                #[verus::internal(verus_macro)]
                fn eq_provable(&self, other: &Self) -> bool {
                    ::builtin::ensures(|b: bool|
                            [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                    self.eq(other)
                }
            }
            impl PmCopy for KeyTableRowMetadata {}
            #[automatically_derived]
            impl ::core::marker::Copy for KeyTableRowMetadata { }
            #[verifier::reject_recursive_types(K)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct KeyTableSnapshot<K> {
                pub key_info: Map<K, KeyTableRowMetadata>,
                pub item_info: Map<u64, K>,
                pub list_info: Map<u64, K>,
            }
            #[verus::internal(verus_macro)]
            impl<K> KeyTableSnapshot<K> {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn init() -> Self {
                    Self {
                        key_info: Map::<K, KeyTableRowMetadata>::empty(),
                        item_info: Map::<u64, K>::empty(),
                        list_info: Map::<u64, K>::empty(),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn key_info_valid(self) -> bool {
                    ::builtin::forall(|k: K|
                            ::builtin::imply(#[verus::internal(trigger)] self.key_info.contains_key(k),
                                {
                                    let rm = self.key_info.spec_index(k);
                                    (((self.item_info.contains_key(rm.item_addr)) &&
                                                        (::builtin::spec_eq(self.item_info.spec_index(rm.item_addr),
                                                                k))) &&
                                                (::builtin::imply(!::builtin::spec_eq(rm.list_addr,
                                                                ::builtin::spec_literal_nat("0")),
                                                        self.list_info.contains_key(rm.list_addr)))) &&
                                        (::builtin::imply(!::builtin::spec_eq(rm.list_addr,
                                                        ::builtin::spec_literal_nat("0")),
                                                ::builtin::spec_eq(self.list_info.spec_index(rm.list_addr),
                                                    k)))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn item_info_valid(self) -> bool {
                    ::builtin::forall(|addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.item_info.contains_key(addr),
                                {
                                    let k = self.item_info.spec_index(addr);
                                    (self.key_info.contains_key(k)) &&
                                        (::builtin::spec_eq(self.key_info.spec_index(k).item_addr,
                                                addr))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn list_info_valid(self) -> bool {
                    (!self.list_info.contains_key(::builtin::spec_literal_integer("0")))
                        &&
                        (::builtin::forall(|addr: u64|
                                    ::builtin::imply(#[verus::internal(trigger)] self.list_info.contains_key(addr),
                                        {
                                            let k = self.list_info.spec_index(addr);
                                            (self.key_info.contains_key(k)) &&
                                                (::builtin::spec_eq(self.key_info.spec_index(k).list_addr,
                                                        addr))
                                        })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn valid(self) -> bool {
                    ((self.key_info_valid()) && (self.item_info_valid())) &&
                        (self.list_info_valid())
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn item_addrs(self) -> Set<u64> { self.item_info.dom() }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn list_addrs(self) -> Set<u64> { self.list_info.dom() }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn create(self, k: K, item_addr: u64) -> Self {
                    let rm =
                        KeyTableRowMetadata {
                            item_addr,
                            list_addr: ::builtin::spec_literal_integer("0"),
                        };
                    Self {
                        key_info: self.key_info.insert(k, rm),
                        item_info: self.item_info.insert(item_addr, k),
                        list_info: self.list_info,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn delete(self, k: K) -> Self {
                    let rm = self.key_info.spec_index(k);
                    let new_list_info =
                        if ::builtin::spec_eq(rm.list_addr,
                                    ::builtin::spec_literal_nat("0")) {
                                self.list_info
                            } else { self.list_info.remove(rm.list_addr) };
                    Self {
                        key_info: self.key_info.remove(k),
                        item_info: self.item_info.remove(rm.item_addr),
                        list_info: new_list_info,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn update(self, k: K, new_rm: KeyTableRowMetadata,
                    former_rm: KeyTableRowMetadata) -> Self {
                    let list_info_after_remove =
                        if !::builtin::spec_eq(former_rm.list_addr,
                                        ::builtin::spec_literal_nat("0")) {
                                self.list_info.remove(former_rm.list_addr)
                            } else { self.list_info };
                    let new_list_info =
                        if !::builtin::spec_eq(new_rm.list_addr,
                                        ::builtin::spec_literal_nat("0")) {
                                list_info_after_remove.insert(new_rm.list_addr, k)
                            } else { list_info_after_remove };
                    Self {
                        key_info: self.key_info.insert(k, new_rm),
                        item_info: self.item_info.remove(former_rm.item_addr).insert(new_rm.item_addr,
                            k),
                        list_info: new_list_info,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_valid_implies_num_keys_equals_num_items(self) {
                    ::builtin::requires([self.valid(),
                                self.key_info.dom().finite()]);
                    ::builtin::ensures([::builtin::spec_eq(self.item_info.dom().len(),
                                    self.key_info.dom().len())]);
                    lemma_bijection_makes_sets_have_equal_size::<K,
                            u64>(self.key_info.dom(), self.item_info.dom(),
                        ::builtin::closure_to_fn_spec(|k: K|
                                self.key_info.spec_index(k).item_addr),
                        ::builtin::closure_to_fn_spec(|row_addr: u64|
                                self.item_info.spec_index(row_addr)));
                }
            }
            #[verifier::reject_recursive_types(K)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct KeyTableView<K> {
                pub sm: KeyTableStaticMetadata,
                pub used_slots: int,
                pub durable: KeyTableSnapshot<K>,
                pub tentative: Option<KeyTableSnapshot<K>>,
            }
        }
        mod start_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::Journal;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use std::collections::{HashMap, HashSet};
            use std::hash::Hash;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            #[verus::internal(item_broadcast_use)]
            const _: () =
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                };
            #[verus::internal(verus_macro)]
            impl<PM, K> KeyTable<PM, K> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn start(journal: &Journal<PM>,
                    sm: &KeyTableStaticMetadata)
                    -> Result<(Self, HashSet<u64>, Vec<u64>), KvError> {
                    ::builtin::requires([journal.valid(),
                                journal.recover_idempotent(), (journal.view()).valid(),
                                ::builtin::spec_eq((journal.view()).journaled_addrs,
                                    Set::<int>::empty()),
                                ::builtin::spec_eq((journal.view()).durable_state,
                                    (journal.view()).read_state),
                                ::builtin::spec_eq((journal.view()).read_state,
                                    (journal.view()).commit_state),
                                ((journal.view()).constants.app_area_start).spec_le(sm.start()),
                                (sm.end()).spec_le((journal.view()).constants.app_area_end),
                                ::builtin::is_variant(Self::recover((journal.view()).read_state,
                                        *sm), "Some"), sm.valid::<K>(),
                                (sm.end()).spec_le((journal.view()).durable_state.len()),
                                vstd::std_specs::hash::obeys_key_model::<K>()]);
                    ::builtin::ensures(|result:
                                Result<(Self, HashSet<u64>, Vec<u64>), KvError>|
                            [match result {
                                        Ok((keys, item_addrs, list_addrs)) => {
                                            let recovered_state =
                                                Self::recover((journal.view()).read_state, *sm).unwrap();
                                            ((((((((keys.valid((journal.view()))) &&
                                                                                                        (::builtin::spec_eq((keys.view()).sm, *sm))) &&
                                                                                                (::builtin::spec_eq((keys.view()).durable,
                                                                                                        recovered_state))) &&
                                                                                        (::builtin::spec_eq((keys.view()).tentative,
                                                                                                Some(recovered_state)))) &&
                                                                                (recovered_state.key_info.dom().finite())) &&
                                                                        (::builtin::spec_eq((keys.view()).used_slots,
                                                                                recovered_state.key_info.dom().len()))) &&
                                                                (::builtin::spec_eq((item_addrs.view()),
                                                                        recovered_state.item_addrs()))) &&
                                                        (::builtin::spec_eq((list_addrs.view()).to_set(),
                                                                recovered_state.list_addrs()))) &&
                                                (!(list_addrs.view()).contains(::builtin::spec_literal_integer("0")))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        Err(_) => false,
                                    }]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            KeyRecoveryMapping::<K>::new((journal.view()).read_state,
                                    *sm).unwrap()
                    };
                    #[verus::internal(spec)]
                    let mut recovery_mapping;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_recovery_mapping = verus_tmp;
                        recovery_mapping = verus_tmp_recovery_mapping;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(recovery_mapping.corresponds((journal.view()).read_state,
                                        *sm))
                            };
                    };
                    let mut m = HashMap::<K, ConcreteKeyInfo>::new();
                    let mut free_list = Vec::<u64>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = KeyMemoryMapping::<K>::new() };
                    #[verus::internal(spec)]
                    let mut memory_mapping;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let mut verus_tmp_memory_mapping = verus_tmp;
                        memory_mapping = verus_tmp_memory_mapping;
                    };
                    let mut item_addrs = HashSet::<u64>::new();
                    let mut list_addrs = Vec::<u64>::new();
                    let pm = journal.get_pm_region_ref();
                    let mut row_index: u64 = 0;
                    let mut row_addr: u64 = sm.table.start;

                    #[verifier::proof_block]
                    { sm.table.lemma_start_is_valid_row(); }
                    while row_index < sm.table.num_rows {
                        ::builtin::invariant([journal.valid(),
                                    journal.recover_idempotent(), (journal.view()).valid(),
                                    ::builtin::spec_eq((journal.view()).journaled_addrs,
                                        Set::<int>::empty()),
                                    ::builtin::spec_eq((journal.view()).durable_state,
                                        (journal.view()).read_state),
                                    ::builtin::spec_eq((journal.view()).read_state,
                                        (journal.view()).commit_state),
                                    ((journal.view()).constants.app_area_start).spec_le(sm.start()),
                                    (sm.end()).spec_le((journal.view()).constants.app_area_end),
                                    ::builtin::is_variant(Self::recover((journal.view()).read_state,
                                            *sm), "Some"), sm.valid::<K>(),
                                    (sm.end()).spec_le((journal.view()).durable_state.len()),
                                    vstd::std_specs::hash::obeys_key_model::<K>(),
                                    ::builtin::spec_eq(KeyRecoveryMapping::<K>::new((journal.view()).read_state,
                                            *sm), Some(recovery_mapping)), pm.inv(),
                                    ::builtin::spec_eq(pm.constants(),
                                        (journal.view()).pm_constants), (pm.view()).valid(),
                                    ::builtin::spec_eq((pm.view()).read_state,
                                        (journal.view()).read_state),
                                    (sm.table.end).spec_le((pm.view()).len()),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                row_index), sm.table.num_rows)),
                                    ::builtin::spec_eq(sm.table.row_addr_to_index(row_addr),
                                        ::builtin::spec_cast_integer::<_, int>(row_index)),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(sm.table.start),
                                                row_addr), sm.table.end)),
                                    ::builtin::imply((row_index).spec_lt(sm.table.num_rows),
                                        sm.table.validate_row_addr(row_addr)),
                                    ::builtin::forall(|any_row_addr: u64|
                                            ::builtin::imply({
                                                    (#[verus::internal(trigger)] sm.table.validate_row_addr(any_row_addr))
                                                        &&
                                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        sm.table.row_addr_to_index(any_row_addr)), row_index)))
                                                },
                                                {
                                                    (memory_mapping.row_info.contains_key(any_row_addr)) &&
                                                        (memory_mapping.corresponds_to_snapshot_at_addr(recovery_mapping,
                                                                any_row_addr))
                                                })),
                                    ::builtin::forall(|any_row_addr: u64|
                                            ::builtin::imply(#[verus::internal(trigger)] memory_mapping.row_info.contains_key(any_row_addr),
                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            sm.table.row_addr_to_index(any_row_addr)), row_index)))),
                                    memory_mapping.consistent(*sm),
                                    memory_mapping.consistent_with_state((journal.view()).read_state,
                                        *sm),
                                    memory_mapping.consistent_with_free_list_and_pending_deallocations((free_list.view()),
                                        Seq::<u64>::empty()),
                                    memory_mapping.consistent_with_hash_table((m.view())),
                                    ::builtin::forall(|i: int|
                                            ::builtin::with_triggers((((free_list.view()).spec_index(i),),),
                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i), (free_list.view()).len())),
                                                    {
                                                        let free_row_addr = (free_list.view()).spec_index(i);
                                                        (sm.table.validate_row_addr(free_row_addr)) &&
                                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                            sm.table.row_addr_to_index(free_row_addr)), row_index)))
                                                    }))),
                                    ::builtin::forall(|k: K|
                                            ::builtin::imply(#[verus::internal(trigger)] (m.view()).contains_key(k),
                                                {
                                                    let used_row_addr = (m.view()).spec_index(k).row_addr;
                                                    (((sm.table.validate_row_addr(used_row_addr)) &&
                                                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                        sm.table.row_addr_to_index(used_row_addr)), row_index)))) &&
                                                                (memory_mapping.row_info.contains_key(used_row_addr))) &&
                                                        (::builtin::is_variant(memory_mapping.row_info.spec_index(used_row_addr),
                                                                "InHashTable"))
                                                })),
                                    !memory_mapping.list_info.contains_key(::builtin::spec_literal_integer("0")),
                                    ::builtin::forall(|any_row_addr: u64|
                                            ::builtin::imply({
                                                    ((#[verus::internal(trigger)] recovery_mapping.row_info.contains_key(any_row_addr))
                                                                &&
                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                sm.table.row_addr_to_index(any_row_addr)), row_index)))) &&
                                                        (::builtin::is_variant(recovery_mapping.row_info.spec_index(any_row_addr),
                                                                "Some"))
                                                },
                                                {
                                                    let (_, rm) =
                                                        recovery_mapping.row_info.spec_index(any_row_addr).unwrap();
                                                    ((item_addrs.view()).contains(rm.item_addr)) &&
                                                        (::builtin::imply(!::builtin::spec_eq(rm.list_addr,
                                                                        ::builtin::spec_literal_nat("0")),
                                                                (list_addrs.view()).contains(rm.list_addr)))
                                                })),
                                    ::builtin::forall(|item_addr: u64|
                                            ::builtin::imply(#[verus::internal(trigger)] (item_addrs.view()).contains(item_addr),
                                                recovery_mapping.item_info.contains_key(item_addr))),
                                    ::builtin::forall(|list_addr: u64|
                                            ::builtin::imply(#[verus::internal(trigger)] (list_addrs.view()).contains(list_addr),
                                                recovery_mapping.list_info.contains_key(list_addr))),
                                    !(list_addrs.view()).contains(::builtin::spec_literal_integer("0"))]);

                        #[verifier::proof_block]
                        {
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            sm.table.lemma_row_addr_successor_is_valid(row_addr);
                        }
                        let cdb_addr = row_addr + sm.row_cdb_start;
                        let cdb = exec_recover_cdb::<PM>(pm, cdb_addr);
                        if cdb.is_none() { return Err(KvError::CRCMismatch); }
                        let cdb = cdb.unwrap();
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = memory_mapping };
                        #[verus::internal(spec)]
                        let mut old_memory_mapping;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_old_memory_mapping = verus_tmp;
                            old_memory_mapping = verus_tmp_old_memory_mapping;
                        };
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = (m.view()) };
                        #[verus::internal(spec)]
                        let mut old_m;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_old_m = verus_tmp;
                            old_m = verus_tmp_old_m;
                        };
                        #[verus::internal(spec)]
                        #[verus::internal(unwrapped_binding)]
                        let mut verus_tmp;

                        #[verifier::proof_block]
                        { verus_tmp = (list_addrs.view()) };
                        #[verus::internal(spec)]
                        let mut old_list_addrs;

                        #[verifier::proof_block]
                        {
                            #[verus::internal(spec)]
                            let verus_tmp_old_list_addrs = verus_tmp;
                            old_list_addrs = verus_tmp_old_list_addrs;
                        };
                        if cdb {
                                let key_addr = row_addr + sm.row_key_start;
                                let key_crc_addr = row_addr + sm.row_key_crc_start;
                                let k =
                                    match exec_recover_object::<PM,
                                                K>(pm, key_addr, key_crc_addr) {
                                        None => { return Err(KvError::CRCMismatch); }
                                        Some(k) => k,
                                    };
                                let rm_addr = row_addr + sm.row_metadata_start;
                                let rm_crc_addr = row_addr + sm.row_metadata_crc_start;
                                let rm =
                                    match exec_recover_object::<PM,
                                                KeyTableRowMetadata>(pm, rm_addr, rm_crc_addr) {
                                        None => { return Err(KvError::CRCMismatch); }
                                        Some(r) => r,
                                    };

                                #[verifier::proof_block]
                                {
                                    memory_mapping =
                                        memory_mapping.initialize_row(row_addr, k, rm);
                                }
                                let concrete_key_info = ConcreteKeyInfo { row_addr, rm };
                                m.insert(k, concrete_key_info);
                                item_addrs.insert(rm.item_addr);
                                if rm.list_addr != 0 {
                                        list_addrs.push(rm.list_addr);

                                        #[verifier::proof_block]
                                        {

                                            #[verus::internal(const_header_wrapper)]
                                            ||
                                                {
                                                    ::builtin::assert_(::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (list_addrs.view()).contains(list_addr),
                                                                    old_list_addrs.contains(list_addr) ||
                                                                        ::builtin::spec_eq(list_addr, rm.list_addr))))
                                                };
                                        };

                                        #[verifier::proof_block]
                                        {

                                            #[verus::internal(const_header_wrapper)]
                                            ||
                                                {
                                                    {
                                                        ::builtin::assert_forall_by(|list_addr: u64|
                                                                {
                                                                    ::builtin::requires(#[verus::internal(trigger)] old_list_addrs.contains(list_addr));
                                                                    ::builtin::ensures((list_addrs.view()).contains(list_addr));
                                                                    let i =
                                                                        ::builtin::choose::<int,
                                                                                _>(|i: int|
                                                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                i), old_list_addrs.len())) &&
                                                                                    ::builtin::spec_eq(#[verus::internal(trigger)] old_list_addrs.spec_index(i),
                                                                                        list_addr));
                                                                    ::builtin::assert_(::builtin::spec_eq((list_addrs.view()).spec_index(i),
                                                                            old_list_addrs.spec_index(i)));
                                                                });
                                                    }
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {

                                            #[verus::internal(const_header_wrapper)]
                                            ||
                                                {
                                                    ::builtin::assert_(::builtin::spec_eq((list_addrs.view()).spec_index(((list_addrs.view()).len()).spec_sub(::builtin::spec_literal_nat("1"))),
                                                            rm.list_addr))
                                                };
                                        };
                                    }
                            } else {

                               #[verifier::proof_block]
                               {
                                   memory_mapping =
                                       memory_mapping.mark_in_free_list(row_addr,
                                           ::builtin::spec_cast_integer::<_, nat>(free_list.len()));
                               }
                               free_list.push(row_addr);
                           }
                        row_index = row_index + 1;
                        row_addr = row_addr + sm.table.row_size;
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_forall_by(|row_addr: u64|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] sm.table.validate_row_addr(row_addr));
                                                ::builtin::ensures(memory_mapping.row_info.contains_key(row_addr));
                                                let row_index = sm.table.row_addr_to_index(row_addr);
                                                {
                                                    ::builtin::reveal_hide_({
                                                            #[verus::internal(reveal_fn)]
                                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                            }

                                                            #[verus::internal(broadcast_use_reveal)]
                                                            __VERUS_REVEAL_INTERNAL__
                                                        }, 1);
                                                }
                                            });
                                }
                            };
                    }
                    let keys =
                        Self {
                            status: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KeyTableStatus::Quiescent),
                            must_abort: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] false),
                            sm: sm.clone(),
                            m,
                            free_list,
                            pending_deallocations: Vec::<u64>::new(),
                            memory_mapping: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] memory_mapping),
                            undo_records: Vec::<KeyUndoRecord<K>>::new(),
                            phantom_pm: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] core::marker::PhantomData),
                        };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            Self::recover((journal.view()).read_state, *sm).unwrap()
                    };
                    #[verus::internal(spec)]
                    let mut recovered_state;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_recovered_state = verus_tmp;
                        recovered_state = verus_tmp_recovered_state;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((keys.view()).durable,
                                        recovered_state))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((item_addrs.view()),
                                        recovered_state.item_addrs()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((list_addrs.view()).to_set(),
                                        recovered_state.list_addrs()))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        memory_mapping.lemma_corresponds_implication_for_free_list_length((free_list.view()),
                            *sm);
                    }
                    Ok((keys, item_addrs, list_addrs))
                }
            }
        }
        pub use spec_v::{KeyTableRowMetadata, KeyTableSnapshot, KeyTableView};
        pub use impl_v::{KeyTable, KeyTableStaticMetadata};
    }
    pub mod lists {
        #![allow(unused_imports)]
        pub mod abort_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::subrange_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn abort_m(self)
                    -> Map<u64, ListTableEntryView<L>> {
                    Map::<u64,
                            ListTableEntryView<L>>::new(::builtin::closure_to_fn_spec(|list_addr:
                                    u64|
                                {
                                    (self.deletes_inverse.contains_key(list_addr)) ||
                                        ({
                                                (self.m.contains_key(list_addr)) &&
                                                    (::builtin::is_variant(self.m.spec_index(list_addr),
                                                            "Durable"))
                                            })
                                }),
                        ::builtin::closure_to_fn_spec(|list_addr: u64|
                                {
                                    if self.deletes_inverse.contains_key(list_addr) {
                                            ListTableEntryView::Durable {
                                                summary: self.deletes.spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(self.deletes_inverse.spec_index(list_addr))),
                                            }
                                        } else { self.m.spec_index(list_addr) }
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn abort_row_info(self)
                    -> Map<u64, ListRowDisposition> {
                    Map::<u64,
                            ListRowDisposition>::new(::builtin::closure_to_fn_spec(|row_addr:
                                    u64| self.row_info.contains_key(row_addr)),
                        ::builtin::closure_to_fn_spec(|row_addr: u64|
                                match self.row_info.spec_index(row_addr) {
                                    ListRowDisposition::InPendingAllocationList { pos } =>
                                        ListRowDisposition::InFreeList {
                                            pos: (self.free_list.len()).spec_add(pos),
                                        },
                                    ListRowDisposition::InPendingDeallocationList { pos } =>
                                        ListRowDisposition::NowhereFree,
                                    ListRowDisposition::InBothPendingLists {
                                        alloc_pos, dealloc_pos } =>
                                        ListRowDisposition::InFreeList {
                                            pos: (self.free_list.len()).spec_add(alloc_pos),
                                        },
                                    _ => self.row_info.spec_index(row_addr),
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn abort(self) -> Self {
                    Self {
                        tentative_mapping: self.durable_mapping,
                        row_info: self.abort_row_info(),
                        m: self.abort_m(),
                        deletes_inverse: Map::<u64, nat>::empty(),
                        deletes: Seq::<ListSummary>::empty(),
                        modifications: Seq::<Option<u64>>::empty(),
                        free_list: (self.free_list).spec_add(self.pending_allocations),
                        pending_allocations: Seq::<u64>::empty(),
                        pending_deallocations: Seq::<u64>::empty(),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_abort_works(self, s: Seq<u8>,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([self.valid(sm),
                                self.corresponds_to_durable_state(s, sm)]);
                    ::builtin::ensures([self.abort().valid(sm),
                                self.abort().corresponds_to_durable_state(s, sm)]);
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_m_to_reflect_abort_of_modifications(&mut self) {
                    ::builtin::requires([::builtin::forall(|i: int|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), old(self).modifications.len())),
                                            (((if let Some(list_addr) =
                                                                    (#[verus::internal(trigger)] old(self).modifications.spec_index(i))
                                                                {
                                                                {
                                                                    ((old(self).m.view()).contains_key(list_addr)) &&
                                                                        (!(::builtin::is_variant((old(self).m.view()).spec_index(list_addr),
                                                                                        "Durable")))
                                                                }
                                                            } else { true })))))]);
                    ::builtin::ensures([::builtin::spec_eq(self,
                                    (Self { m: self.m, ..*old(self) })),
                                ::builtin::spec_eq(self.internal_view(),
                                    (ListTableInternalView {
                                            m: self.internal_view().m,
                                            ..old(self).internal_view()
                                        })),
                                ::builtin::forall(|i: int|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), self.modifications.len())),
                                            (((if let Some(list_addr) =
                                                                    (#[verus::internal(trigger)] old(self).modifications.spec_index(i))
                                                                {
                                                                !(self.m.view()).contains_key(list_addr)
                                                            } else { true }))))),
                                ::builtin::forall(|list_addr: u64|
                                        ::builtin::imply(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr),
                                            {
                                                ((old(self).m.view()).contains_key(list_addr)) &&
                                                    (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                            ((old(self).m.view()).spec_index(list_addr).view())))
                                            })),
                                ::builtin::forall(|list_addr: u64|
                                        ::builtin::imply({
                                                (#[verus::internal(trigger)] (old(self).m.view()).contains_key(list_addr))
                                                    &&
                                                    (::builtin::is_variant(old(self).m.spec_index(list_addr),
                                                            "Durable"))
                                            }, (self.m.view()).contains_key(list_addr)))]);
                    let num_modifications = self.modifications.len();
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..num_modifications)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..num_modifications)),
                                                            true)),
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(self, (Self { m: self.m, ..*old(self) }))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(num_modifications,
                                                            self.modifications.len())
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                i), old(self).modifications.len())),
                                                                    (((if let Some(list_addr) =
                                                                                            (#[verus::internal(trigger)] old(self).modifications.spec_index(i))
                                                                                        {
                                                                                        {
                                                                                            ((old(self).m.view()).contains_key(list_addr)) &&
                                                                                                (!(::builtin::is_variant((old(self).m.view()).spec_index(list_addr),
                                                                                                                "Durable")))
                                                                                        }
                                                                                    } else { true })))))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr),
                                                                    {
                                                                        ((old(self).m.view()).contains_key(list_addr)) &&
                                                                            (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                                    ((old(self).m.view()).spec_index(list_addr).view())))
                                                                    }))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply({
                                                                        (#[verus::internal(trigger)] (old(self).m.view()).contains_key(list_addr))
                                                                            &&
                                                                            (::builtin::is_variant(old(self).m.spec_index(list_addr),
                                                                                    "Durable"))
                                                                    }, (self.m.view()).contains_key(list_addr)))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                i), which_modification)),
                                                                    (((if let Some(list_addr) =
                                                                                            (#[verus::internal(trigger)] self.modifications.spec_index(i))
                                                                                        {
                                                                                        !(self.m.view()).contains_key(list_addr)
                                                                                    } else { true })))))
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let which_modification = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verus::internal(proof_block)]
                                                    {
                                                        ::builtin::reveal_hide_({
                                                                #[verus::internal(reveal_fn)]
                                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                                    ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                                                }

                                                                #[verus::internal(broadcast_use_reveal)]
                                                                __VERUS_REVEAL_INTERNAL__
                                                            }, 1);
                                                    }
                                                    match self.modifications[which_modification] {
                                                        None => {}
                                                        Some(list_addr) => { self.m.remove(&list_addr); }
                                                    };
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_m_to_reflect_abort_of_deletes(&mut self) {
                    ::builtin::requires([::builtin::forall(|list_addr: u64|
                                        ::builtin::imply(#[verus::internal(trigger)] (old(self).deletes_inverse.view()).contains_key(list_addr),
                                            {
                                                let which_delete =
                                                    (old(self).deletes_inverse.view()).spec_index(list_addr);
                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    which_delete), (old(self).deletes.view()).len()))) &&
                                                    (::builtin::spec_eq((old(self).deletes.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(which_delete)).head, list_addr))
                                            })),
                                ::builtin::forall(|i: int|
                                        ::builtin::with_triggers((((old(self).deletes.view()).spec_index(i),),),
                                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), (old(self).deletes.view()).len())),
                                                {
                                                    let summary = (old(self).deletes.view()).spec_index(i);
                                                    ((old(self).deletes_inverse.view()).contains_key(summary.head))
                                                        &&
                                                        (::builtin::spec_eq((old(self).deletes_inverse.view()).spec_index(summary.head),
                                                                i))
                                                }))),
                                ::builtin::forall(|list_addr: u64|
                                        ::builtin::imply(#[verus::internal(trigger)] (old(self).m.view()).contains_key(list_addr),
                                            ::builtin::is_variant((old(self).m.view()).spec_index(list_addr),
                                                "Durable")))]);
                    ::builtin::ensures([::builtin::spec_eq(self,
                                    (Self { m: self.m, ..*old(self) })),
                                ::builtin::forall(|i: int|
                                        ::builtin::with_triggers(((self.deletes.spec_index(i),),),
                                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), self.deletes.len())),
                                                {
                                                    let summary = self.deletes.spec_index(i);
                                                    ((self.m.view()).contains_key(summary.head)) &&
                                                        (::builtin::spec_eq((self.m.view()).spec_index(summary.head),
                                                                ListTableEntry::<L>::Durable { summary }))
                                                }))),
                                ::builtin::forall(|list_addr: u64|
                                        ::builtin::imply(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr),
                                            {
                                                if (self.deletes_inverse.view()).contains_key(list_addr) {
                                                        let summary =
                                                            (self.deletes.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>((self.deletes_inverse.view()).spec_index(list_addr)));
                                                        ::builtin::spec_eq((self.m.view()).spec_index(list_addr),
                                                            ListTableEntry::<L>::Durable { summary })
                                                    } else {
                                                       ((old(self).m.view()).contains_key(list_addr)) &&
                                                           (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                   ((old(self).m.view()).spec_index(list_addr).view())))
                                                   }
                                            })),
                                ::builtin::forall(|list_addr: u64|
                                        ::builtin::imply(#[verus::internal(trigger)] (old(self).m.view()).contains_key(list_addr),
                                            {
                                                ({
                                                            (((old(self).deletes_inverse.view()).contains_key(list_addr))
                                                                        && ((self.m.view()).contains_key(list_addr))) &&
                                                                (::builtin::spec_eq((self.m.view()).spec_index(list_addr),
                                                                        ListTableEntry::<L>::Durable {
                                                                            summary: (self.deletes.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                                        int>((self.deletes_inverse.view()).spec_index(list_addr))),
                                                                        }))
                                                        }) ||
                                                    ({
                                                            ((self.m.view()).contains_key(list_addr)) &&
                                                                (::builtin::spec_eq((self.m.view()).spec_index(list_addr),
                                                                        (old(self).m.view()).spec_index(list_addr)))
                                                        })
                                            }))]);
                    let num_deletes = self.deletes.len();
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..num_deletes)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..num_deletes)),
                                                            true)),
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(self, (Self { m: self.m, ..*old(self) }))
                                                    },
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(num_deletes, self.deletes.len())
                                                    },
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (self.deletes_inverse.view()).contains_key(list_addr),
                                                                    {
                                                                        let which_delete =
                                                                            (self.deletes_inverse.view()).spec_index(list_addr);
                                                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                            which_delete), (self.deletes.view()).len()))) &&
                                                                            (::builtin::spec_eq((self.deletes.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                                                    int>(which_delete)).head, list_addr))
                                                                    }))
                                                    },
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::with_triggers((((self.deletes.view()).spec_index(i),),),
                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                    i), (self.deletes.view()).len())),
                                                                        {
                                                                            let summary = (self.deletes.view()).spec_index(i);
                                                                            ((self.deletes_inverse.view()).contains_key(summary.head))
                                                                                &&
                                                                                (::builtin::spec_eq((self.deletes_inverse.view()).spec_index(summary.head),
                                                                                        i))
                                                                        })))
                                                    },
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::with_triggers(((self.deletes.spec_index(i),),),
                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                    i), which_delete)),
                                                                        {
                                                                            let summary = self.deletes.spec_index(i);
                                                                            ((self.m.view()).contains_key(summary.head)) &&
                                                                                (::builtin::spec_eq((self.m.view()).spec_index(summary.head),
                                                                                        ListTableEntry::<L>::Durable { summary }))
                                                                        })))
                                                    },
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr),
                                                                    ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                                                        "Durable")))
                                                    },
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr),
                                                                    {
                                                                        ({
                                                                                    ((self.deletes_inverse.view()).contains_key(list_addr)) &&
                                                                                        (::builtin::spec_eq((self.m.view()).spec_index(list_addr),
                                                                                                ListTableEntry::<L>::Durable {
                                                                                                    summary: (self.deletes.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                                                                int>((self.deletes_inverse.view()).spec_index(list_addr))),
                                                                                                }))
                                                                                }) ||
                                                                            ({
                                                                                    ((old(self).m.view()).contains_key(list_addr)) &&
                                                                                        (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                                                ((old(self).m.view()).spec_index(list_addr).view())))
                                                                                })
                                                                    }))
                                                    },
                                                    {
                                                        let which_delete =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (old(self).m.view()).contains_key(list_addr),
                                                                    {
                                                                        ({
                                                                                    (((old(self).deletes_inverse.view()).contains_key(list_addr))
                                                                                                && ((self.m.view()).contains_key(list_addr))) &&
                                                                                        (::builtin::spec_eq((self.m.view()).spec_index(list_addr),
                                                                                                ListTableEntry::<L>::Durable {
                                                                                                    summary: (self.deletes.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                                                                int>((self.deletes_inverse.view()).spec_index(list_addr))),
                                                                                                }))
                                                                                }) ||
                                                                            ({
                                                                                    ((self.m.view()).contains_key(list_addr)) &&
                                                                                        (::builtin::spec_eq((self.m.view()).spec_index(list_addr),
                                                                                                (old(self).m.view()).spec_index(list_addr)))
                                                                                })
                                                                    }))
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let which_delete = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verus::internal(proof_block)]
                                                    {
                                                        ::builtin::reveal_hide_({
                                                                #[verus::internal(reveal_fn)]
                                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                                    ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                                                }

                                                                #[verus::internal(broadcast_use_reveal)]
                                                                __VERUS_REVEAL_INTERNAL__
                                                            }, 1);
                                                    }
                                                    #[verus::internal(spec)]
                                                    #[verus::internal(unwrapped_binding)]
                                                    let mut verus_tmp;

                                                    #[verifier::proof_block]
                                                    { verus_tmp = *self };
                                                    #[verus::internal(spec)]
                                                    let mut prev_self;

                                                    #[verifier::proof_block]
                                                    {
                                                        #[verus::internal(spec)]
                                                        let verus_tmp_prev_self = verus_tmp;
                                                        prev_self = verus_tmp_prev_self;
                                                    };
                                                    let summary = self.deletes[which_delete];
                                                    self.m.insert(summary.head,
                                                        ListTableEntry::<L>::Durable { summary });
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_m_to_reflect_abort(&mut self,
                    verus_tmp_jv: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv;

                    #[verifier::proof_block]
                    { jv = verus_tmp_jv.view() };
                    ::builtin::requires([old(self).valid(jv)]);
                    ::builtin::ensures([::builtin::spec_eq(self,
                                    (Self { m: self.m, ..*old(self) })),
                                ::builtin::spec_eq(self.internal_view().m,
                                    old(self).internal_view().abort().m)]);
                    self.update_m_to_reflect_abort_of_modifications();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_forall_by(|list_addr: u64|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr));
                                                ::builtin::ensures(::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                                        "Durable"));
                                                ::builtin::assert_(old(self).internal_view().m.contains_key(list_addr));
                                            });
                                }
                            };
                    }
                    self.update_m_to_reflect_abort_of_deletes();

                    #[verifier::proof_block]
                    {
                        let m1 = self.internal_view().m;
                        let m2 = old(self).internal_view().abort().m;
                        ::builtin::assert_(::builtin::forall(|list_addr: u64|
                                    ::builtin::imply(m2.contains_key(list_addr),
                                        m1.contains_key(list_addr))));
                        ::builtin::assert_(::builtin::forall(|list_addr: u64|
                                    ::builtin::imply(m1.contains_key(list_addr),
                                        m2.contains_key(list_addr))));
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view().m,
                                        old(self).internal_view().abort().m))
                            };
                    };
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn abort(&mut self,
                    verus_tmp_jv_before_abort: Ghost<JournalView>,
                    verus_tmp_jv_after_abort: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_before_abort;

                    #[verifier::proof_block]
                    { jv_before_abort = verus_tmp_jv_before_abort.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_after_abort;

                    #[verifier::proof_block]
                    { jv_after_abort = verus_tmp_jv_after_abort.view() };
                    ::builtin::requires([old(self).valid(jv_before_abort),
                                jv_before_abort.valid(), jv_after_abort.valid(),
                                ::builtin::spec_eq(jv_after_abort,
                                    jv_before_abort.abort())]);
                    ::builtin::ensures([self.valid(jv_after_abort),
                                ::builtin::spec_eq((self.view()),
                                    (ListTableView {
                                            tentative: Some((old(self).view()).durable),
                                            used_slots: (self.view()).used_slots,
                                            ..(old(self).view())
                                        })),
                                ({
                                        let m = (self.view()).durable.m;
                                        (m.dom().finite()) &&
                                            (::builtin::spec_eq((self.view()).used_slots,
                                                    m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                                                        ::builtin::closure_to_fn_spec(|total: int, row_addr: u64|
                                                                (total).spec_add(m.spec_index(row_addr).len())))))
                                    })]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = self.internal_view().abort() };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };

                    #[verifier::proof_block]
                    {
                        self.internal_view().lemma_abort_works(jv_before_abort.durable_state,
                            self.sm);
                    }
                    self.update_m_to_reflect_abort(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_abort));
                    self.tentative_mapping = self.durable_mapping;
                    self.deletes_inverse =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.deletes_inverse);
                    self.deletes.clear();
                    self.modifications.clear();
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.row_info);
                    self.free_list.append(&mut self.pending_allocations);
                    self.pending_allocations.clear();
                    self.pending_deallocations.clear();
                    self.must_abort =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] false);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        old(self).internal_view().abort()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid(jv_after_abort)) };
                    };

                    #[verifier::proof_block]
                    {
                        self.internal_view().lemma_corresponds_implication_for_free_list_length(self.sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()),
                                        (ListTableView {
                                                tentative: Some((old(self).view()).durable),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })))
                            };
                    };
                }
            }
        }
        pub mod append_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use crate::pmem::pmemutil_v::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::util_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntryView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn append(self, new_row_addr: u64, new_element: L)
                    -> Self {
                    ::builtin::recommends([match self {
                                    ListTableEntryView::Durable { summary } => false,
                                    ListTableEntryView::Modified { summary, .. } =>
                                        (summary.length).spec_lt(usize::MAX),
                                }]);
                    match self {
                        ListTableEntryView::Modified {
                            which_modification, durable_head, summary, addrs, elements }
                            =>
                            ListTableEntryView::Modified {
                                which_modification,
                                durable_head,
                                summary: ListSummary {
                                    tail: new_row_addr,
                                    length: ::builtin::spec_cast_integer::<_,
                                            usize>(((summary.length).spec_add(::builtin::spec_literal_nat("1")))),
                                    end_of_logical_range: new_element.end(),
                                    ..summary
                                },
                                addrs: addrs.push(new_row_addr),
                                elements: elements.push(new_element),
                            },
                        _ => self,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn update_by_appending(self,
                    which_modification: nat, new_row_addr: u64, new_element: L)
                    -> Self {
                    ::builtin::recommends([match self {
                                    ListTableEntryView::Durable { summary } =>
                                        (summary.length).spec_lt(usize::MAX),
                                    _ => false,
                                }]);
                    match self {
                        ListTableEntryView::Durable { summary } => {
                            let new_summary =
                                ListSummary {
                                    tail: new_row_addr,
                                    length: ::builtin::spec_cast_integer::<_,
                                            usize>(((summary.length).spec_add(::builtin::spec_literal_nat("1")))),
                                    end_of_logical_range: new_element.end(),
                                    ..summary
                                };
                            ListTableEntryView::Modified {
                                which_modification,
                                durable_head: summary.head,
                                summary: new_summary,
                                addrs: ::vstd::vstd::seq::Seq::empty().push(new_row_addr),
                                elements: ::vstd::vstd::seq::Seq::empty().push(new_element),
                            }
                        }
                        _ => self,
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntry<L> where L: PmCopy + LogicalRange + Sized +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub(super) fn append(self, new_row_addr: u64, new_element: L)
                    -> Self {
                    ::builtin::requires([match self {
                                    ListTableEntry::Modified { summary, .. } =>
                                        (summary.length).spec_lt(usize::MAX),
                                    _ => false,
                                }]);
                    ::builtin::ensures(|result: Self|
                            [::builtin::spec_eq((result.view()),
                                        (self.view()).append(new_row_addr, new_element))]);
                    match self {
                        ListTableEntry::Modified {
                            which_modification,
                            durable_head,
                            mut summary,
                            mut addrs,
                            mut elements } => {
                            summary.tail = new_row_addr;
                            summary.length = summary.length + 1;
                            summary.end_of_logical_range = new_element.end();
                            addrs.push(new_row_addr);
                            elements.push(new_element);
                            ListTableEntry::Modified {
                                which_modification,
                                durable_head,
                                summary,
                                addrs,
                                elements,
                            }
                        }
                        _ => self,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub(super) fn update_by_appending(&self,
                    which_modification: usize, new_row_addr: u64,
                    new_element: L) -> Self {
                    ::builtin::requires([match self {
                                    ListTableEntry::Durable { summary } =>
                                        (summary.length).spec_lt(usize::MAX),
                                    _ => false,
                                }]);
                    ::builtin::ensures(|result: Self|
                            [::builtin::spec_eq((result.view()),
                                        (self.view()).update_by_appending(::builtin::spec_cast_integer::<_,
                                                    nat>(which_modification), new_row_addr, new_element))]);
                    match self {
                        ListTableEntry::Durable { ref summary } => {
                            let new_summary =
                                ListSummary {
                                    head: summary.head,
                                    tail: new_row_addr,
                                    length: (summary.length + 1) as usize,
                                    end_of_logical_range: new_element.end(),
                                };
                            let addrs =
                                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([new_row_addr]));
                            let elements =
                                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([new_element]));

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal((addrs.view()),
                                                ::vstd::vstd::seq::Seq::empty().push(new_row_addr)))
                                    };
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal((elements.view()),
                                                ::vstd::vstd::seq::Seq::empty().push(new_element)))
                                    };
                            };
                            ListTableEntry::Modified {
                                which_modification,
                                durable_head: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (summary.head.view())),
                                summary: new_summary,
                                addrs,
                                elements,
                            }
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            Self::default()
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListRecoveryMapping<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn append(self, list_addr: u64, new_row_addr: u64,
                    new_element: L) -> Self {
                    ::builtin::recommends([self.list_info.contains_key(list_addr),
                                (self.list_info.spec_index(list_addr).len()).spec_lt(usize::MAX)]);
                    let old_addrs = self.list_info.spec_index(list_addr);
                    let former_tail_addr = old_addrs.last();
                    let former_tail_new_info =
                        ListRowRecoveryInfo::<L> {
                            next: new_row_addr,
                            ..self.row_info.spec_index(former_tail_addr)
                        };
                    let new_tail_info =
                        ListRowRecoveryInfo::<L> {
                            element: new_element,
                            head: list_addr,
                            next: ::builtin::spec_literal_integer("0"),
                            pos: ::builtin::spec_cast_integer::<_, int>(old_addrs.len()),
                        };
                    let new_addrs = old_addrs.push(new_row_addr);
                    let old_elements = self.list_elements.spec_index(list_addr);
                    let new_elements = old_elements.push(new_element);
                    Self {
                        row_info: self.row_info.insert(former_tail_addr,
                                former_tail_new_info).insert(new_row_addr, new_tail_info),
                        list_info: self.list_info.insert(list_addr, new_addrs),
                        list_elements: self.list_elements.insert(list_addr,
                            new_elements),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn create_singleton(self, list_addr: u64,
                    element: L) -> Self {
                    let info =
                        ListRowRecoveryInfo::<L> {
                            element,
                            head: list_addr,
                            next: ::builtin::spec_literal_integer("0"),
                            pos: ::builtin::spec_literal_integer("0"),
                        };
                    Self {
                        row_info: self.row_info.insert(list_addr, info),
                        list_info: self.list_info.insert(list_addr,
                            ::vstd::vstd::seq::Seq::empty().push(list_addr)),
                        list_elements: self.list_elements.insert(list_addr,
                            ::vstd::vstd::seq::Seq::empty().push(element)),
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn append_case_durable(self, list_addr: u64,
                    new_element: L) -> Self {
                    ::builtin::recommends([self.m.contains_key(list_addr),
                                ::builtin::is_variant(self.m.spec_index(list_addr),
                                    "Durable")]);
                    let which_delete = self.deletes.len();
                    let which_modification = self.modifications.len();
                    let new_row_addr = self.free_list.last();
                    let new_delete =
                        (self.m.spec_index(list_addr).arrow_Durable_summary());
                    let summary =
                        self.m.spec_index(list_addr).update_by_appending(which_modification,
                            new_row_addr, new_element);
                    let disposition =
                        ListRowDisposition::InPendingAllocationList {
                            pos: ::builtin::spec_cast_integer::<_,
                                    nat>(self.pending_allocations.len()),
                        };
                    Self {
                        tentative_mapping: self.tentative_mapping.append(list_addr,
                            new_row_addr, new_element),
                        row_info: self.row_info.insert(new_row_addr, disposition),
                        m: self.m.insert(list_addr, summary),
                        deletes_inverse: self.deletes_inverse.insert(list_addr,
                            which_delete),
                        deletes: self.deletes.push(new_delete),
                        modifications: self.modifications.push(Some(list_addr)),
                        free_list: self.free_list.drop_last(),
                        pending_allocations: self.pending_allocations.push(new_row_addr),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn append_case_modified(self, list_addr: u64,
                    new_element: L) -> Self {
                    ::builtin::recommends([self.m.contains_key(list_addr),
                                !(::builtin::is_variant(self.m.spec_index(list_addr),
                                            "Durable"))]);
                    let new_row_addr = self.free_list.last();
                    let summary =
                        self.m.spec_index(list_addr).append(new_row_addr,
                            new_element);
                    let disposition =
                        ListRowDisposition::InPendingAllocationList {
                            pos: ::builtin::spec_cast_integer::<_,
                                    nat>(self.pending_allocations.len()),
                        };
                    Self {
                        tentative_mapping: self.tentative_mapping.append(list_addr,
                            new_row_addr, new_element),
                        row_info: self.row_info.insert(new_row_addr, disposition),
                        m: self.m.insert(list_addr, summary),
                        free_list: self.free_list.drop_last(),
                        pending_allocations: self.pending_allocations.push(new_row_addr),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn create_singleton(self, new_element: L) -> Self {
                    let row_addr = self.free_list.last();
                    let disposition =
                        ListRowDisposition::InPendingAllocationList {
                            pos: ::builtin::spec_cast_integer::<_,
                                    nat>(self.pending_allocations.len()),
                        };
                    let which_modification = self.modifications.len();
                    let summary =
                        ListSummary {
                            head: row_addr,
                            tail: row_addr,
                            length: ::builtin::spec_literal_integer("1"),
                            end_of_logical_range: new_element.end(),
                        };
                    let entry_view =
                        ListTableEntryView::<L>::Modified {
                            durable_head: ::builtin::spec_literal_integer("0"),
                            which_modification,
                            summary,
                            addrs: ::vstd::vstd::seq::Seq::empty().push(row_addr),
                            elements: ::vstd::vstd::seq::Seq::empty().push(new_element),
                        };
                    Self {
                        tentative_mapping: self.tentative_mapping.create_singleton(row_addr,
                            new_element),
                        row_info: self.row_info.insert(row_addr, disposition),
                        modifications: self.modifications.push(Some(row_addr)),
                        free_list: self.free_list.drop_last(),
                        pending_allocations: self.pending_allocations.push(row_addr),
                        m: self.m.insert(row_addr, entry_view),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_append_case_durable_works(self,
                    list_addr: u64, new_element: L,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(), self.valid(sm),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                self.durable_mapping.internally_consistent(sm),
                                self.tentative_mapping.internally_consistent(sm),
                                (self.free_list.len()).spec_gt(::builtin::spec_literal_nat("0")),
                                self.m.contains_key(list_addr),
                                match self.m.spec_index(list_addr) {
                                    ListTableEntryView::Durable { summary } =>
                                        (summary.length).spec_lt(usize::MAX),
                                    _ => false,
                                }]);
                    ::builtin::ensures([self.append_case_durable(list_addr,
                                        new_element).valid(sm),
                                ::builtin::spec_eq(self.append_case_durable(list_addr,
                                                new_element).tentative_mapping.as_snapshot(),
                                    self.tentative_mapping.as_snapshot().append(list_addr,
                                        list_addr, new_element))]);
                    let new_self =
                        self.append_case_durable(list_addr, new_element);
                    let old_snapshot = self.tentative_mapping.as_snapshot();
                    let new_snapshot = new_self.tentative_mapping.as_snapshot();
                    let tail_row_addr =
                        match self.m.spec_index(list_addr) {
                            ListTableEntryView::Durable { summary } => summary.tail,
                            _ => { ::builtin::assert_(false); 0u64 }
                        };
                    let new_row_addr = self.free_list.last();
                    ::builtin::assert_(::builtin::ext_equal(new_snapshot,
                            old_snapshot.append(list_addr, list_addr, new_element)));
                    {
                        ::builtin::assert_by((new_row_addr).spec_gt(::builtin::spec_literal_nat("0")),
                            {
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                            });
                    }
                    match new_self.m.spec_index(list_addr) {
                        ListTableEntryView::Modified {
                            durable_head, summary, addrs, elements, .. } => {
                            let durable_addrs =
                                new_self.durable_mapping.list_info.spec_index(durable_head);
                            let durable_elements =
                                new_self.durable_mapping.list_elements.spec_index(durable_head);
                            let tentative_addrs =
                                new_self.tentative_mapping.list_info.spec_index(list_addr);
                            let tentative_elements =
                                new_self.tentative_mapping.list_elements.spec_index(list_addr);
                            ::builtin::assert_(::builtin::ext_equal(tentative_addrs,
                                    (durable_addrs.skip((durable_addrs.len()).spec_sub(((summary.length).spec_sub(addrs.len()))))).spec_add(addrs)));
                            ::builtin::assert_(::builtin::ext_equal(tentative_elements,
                                    (durable_elements.skip((durable_elements.len()).spec_sub(((summary.length).spec_sub(elements.len()))))).spec_add(elements)));
                        }
                        _ => { ::builtin::assert_(false); }
                    }
                    ::builtin::assert_(::builtin::ext_equal(self.append_case_durable(list_addr,
                                        new_element).tentative_mapping.as_snapshot(),
                            self.tentative_mapping.as_snapshot().append(list_addr,
                                list_addr, new_element)));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_append_case_modified_works(self,
                    list_addr: u64, new_element: L,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(), self.valid(sm),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                self.durable_mapping.internally_consistent(sm),
                                self.tentative_mapping.internally_consistent(sm),
                                (self.free_list.len()).spec_gt(::builtin::spec_literal_nat("0")),
                                self.m.contains_key(list_addr),
                                match self.m.spec_index(list_addr) {
                                    ListTableEntryView::Modified { summary, .. } =>
                                        (summary.length).spec_lt(usize::MAX),
                                    _ => false,
                                }]);
                    ::builtin::ensures([self.append_case_modified(list_addr,
                                        new_element).valid(sm),
                                ::builtin::spec_eq(self.append_case_modified(list_addr,
                                                new_element).tentative_mapping.as_snapshot(),
                                    self.tentative_mapping.as_snapshot().append(list_addr,
                                        list_addr, new_element))]);
                    let new_self =
                        self.append_case_modified(list_addr, new_element);
                    let old_snapshot = self.tentative_mapping.as_snapshot();
                    let new_snapshot = new_self.tentative_mapping.as_snapshot();
                    let tail_row_addr =
                        match self.m.spec_index(list_addr) {
                            ListTableEntryView::Modified { summary, .. } =>
                                summary.tail,
                            _ => { ::builtin::assert_(false); 0u64 }
                        };
                    let new_row_addr = self.free_list.last();
                    ::builtin::assert_(::builtin::ext_equal(new_snapshot,
                            old_snapshot.append(list_addr, list_addr, new_element)));
                    {
                        ::builtin::assert_by((new_row_addr).spec_gt(::builtin::spec_literal_nat("0")),
                            {
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                            });
                    }
                    match new_self.m.spec_index(list_addr) {
                        ListTableEntryView::Modified {
                            durable_head, summary, addrs, elements, .. } => {
                            let durable_addrs =
                                new_self.durable_mapping.list_info.spec_index(durable_head);
                            let durable_elements =
                                new_self.durable_mapping.list_elements.spec_index(durable_head);
                            let tentative_addrs =
                                new_self.tentative_mapping.list_info.spec_index(list_addr);
                            let tentative_elements =
                                new_self.tentative_mapping.list_elements.spec_index(list_addr);
                            ::builtin::assert_(::builtin::ext_equal(tentative_addrs,
                                    (durable_addrs.skip((durable_addrs.len()).spec_sub(((summary.length).spec_sub(addrs.len()))))).spec_add(addrs)));
                            ::builtin::assert_(::builtin::ext_equal(tentative_elements,
                                    (durable_elements.skip((durable_elements.len()).spec_sub(((summary.length).spec_sub(elements.len()))))).spec_add(elements)));
                        }
                        _ => { ::builtin::assert_(false); }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_create_singleton_works(self,
                    new_element: L, sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(), self.valid(sm),
                                self.durable_mapping.internally_consistent(sm),
                                self.tentative_mapping.internally_consistent(sm),
                                (self.free_list.len()).spec_gt(::builtin::spec_literal_nat("0"))]);
                    ::builtin::ensures([self.create_singleton(new_element).valid(sm),
                                ::builtin::spec_eq(self.create_singleton(new_element).tentative_mapping.as_snapshot(),
                                    self.tentative_mapping.as_snapshot().create_singleton(self.free_list.last(),
                                        new_element))]);
                    let new_self = self.create_singleton(new_element);
                    let old_snapshot = self.tentative_mapping.as_snapshot();
                    let new_snapshot = new_self.tentative_mapping.as_snapshot();
                    let row_addr = self.free_list.last();
                    let tentative_addrs =
                        ::vstd::vstd::seq::Seq::empty().push(row_addr);
                    let tentative_elements =
                        ::vstd::vstd::seq::Seq::empty().push(new_element);
                    let which_modification = self.modifications.len();
                    ::builtin::assert_(::builtin::ext_equal(tentative_elements,
                            new_self.tentative_mapping.list_elements.spec_index(row_addr)));
                    ::builtin::assert_(::builtin::forall(|list_addr: u64|
                                ::builtin::imply(#[verus::internal(trigger)] new_self.m.contains_key(list_addr),
                                    ::builtin::spec_eq(list_addr, row_addr) ||
                                        self.m.contains_key(list_addr))));
                    {
                        ::builtin::assert_forall_by(|list_addr: u64|
                                {
                                    ::builtin::requires(#[verus::internal(trigger)] new_snapshot.m.contains_key(list_addr));
                                    ::builtin::ensures({
                                            (old_snapshot.create_singleton(row_addr,
                                                                new_element).m.contains_key(list_addr)) &&
                                                (::builtin::spec_eq(new_snapshot.m.spec_index(list_addr),
                                                        old_snapshot.create_singleton(row_addr,
                                                                    new_element).m.spec_index(list_addr)))
                                        });
                                    ::builtin::assert_(::builtin::imply(!::builtin::spec_eq(list_addr,
                                                    row_addr), old_snapshot.m.contains_key(list_addr)));
                                    ::builtin::assert_(old_snapshot.create_singleton(row_addr,
                                                    new_element).m.contains_key(list_addr));
                                    ::builtin::assert_(::builtin::ext_equal(new_snapshot.m.spec_index(list_addr),
                                            old_snapshot.create_singleton(row_addr,
                                                        new_element).m.spec_index(list_addr)));
                                });
                    }
                    ::builtin::assert_(::builtin::ext_equal(new_snapshot,
                            old_snapshot.create_singleton(row_addr, new_element)));
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn append_case_durable(&mut self, list_addr: u64,
                    new_element: L, journal: &mut Journal<PM>,
                    new_row_addr: u64, entry: ListTableEntry<L>,
                    verus_tmp_prev_self: Ghost<Self>,
                    verus_tmp_prev_jv: Ghost<JournalView>)
                    -> Result<u64, KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_self;

                    #[verifier::proof_block]
                    { prev_self = verus_tmp_prev_self.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_jv;

                    #[verifier::proof_block]
                    { prev_jv = verus_tmp_prev_jv.view() };
                    ::builtin::requires([::builtin::spec_eq(old(self),
                                    (Self {
                                            free_list: old(self).free_list,
                                            m: old(self).m,
                                            ..prev_self
                                        })),
                                ((prev_self.free_list.view()).len()).spec_gt(::builtin::spec_literal_nat("0")),
                                ::builtin::spec_eq((old(self).free_list.view()),
                                    (prev_self.free_list.view()).drop_last()),
                                ::builtin::spec_eq((old(self).m.view()),
                                    (prev_self.m.view()).remove(list_addr)),
                                ::builtin::spec_eq(new_row_addr,
                                    (prev_self.free_list.view()).last()),
                                prev_self.valid(prev_jv), old(journal).valid(),
                                ((old(journal).view()).remaining_capacity).spec_ge(old(self).space_needed_to_journal_next),
                                ::builtin::is_variant((prev_self.view()).tentative, "Some"),
                                (prev_self.view()).tentative.unwrap().m.contains_key(list_addr),
                                prev_self.internal_view().corresponds_to_durable_state((old(journal).view()).durable_state,
                                    prev_self.sm),
                                prev_self.internal_view().corresponds_to_durable_state((old(journal).view()).read_state,
                                    prev_self.sm),
                                (old(journal).view()).matches_except_in_range(prev_jv,
                                    ::builtin::spec_cast_integer::<_,
                                            int>((old(self).view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((old(self).view()).sm.end())),
                                ::builtin::spec_eq((old(journal).view()),
                                    (JournalView {
                                            durable_state: (old(journal).view()).durable_state,
                                            read_state: (old(journal).view()).read_state,
                                            commit_state: (old(journal).view()).commit_state,
                                            ..prev_jv
                                        })),
                                ::builtin::spec_eq(new_row_addr,
                                    (prev_self.free_list.view()).last()),
                                ::builtin::forall(|other_row_addr: u64|
                                        ::builtin::imply({
                                                (old(self).sm.table.validate_row_addr(other_row_addr)) &&
                                                    (!::builtin::spec_eq(other_row_addr, new_row_addr))
                                            },
                                            {
                                                (::builtin::spec_eq(recover_object::<L>((old(journal).view()).commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_element_start),
                                                                (other_row_addr).spec_add(old(self).sm.row_element_crc_start)),
                                                            recover_object::<L>(prev_jv.commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_element_start),
                                                                (other_row_addr).spec_add(old(self).sm.row_element_crc_start))))
                                                    &&
                                                    (::builtin::spec_eq(recover_object::<u64>((old(journal).view()).commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_next_start),
                                                                ((other_row_addr).spec_add(old(self).sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                            recover_object::<u64>(prev_jv.commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_next_start),
                                                                ((other_row_addr).spec_add(old(self).sm.row_next_start)).spec_add(u64::spec_size_of()))))
                                            })),
                                ::builtin::spec_eq(recover_object::<u64>((old(journal).view()).commit_state,
                                        (new_row_addr).spec_add(old(self).sm.row_next_start),
                                        ((new_row_addr).spec_add(old(self).sm.row_next_start)).spec_add(u64::spec_size_of())),
                                    Some(0u64)),
                                ::builtin::spec_eq(recover_object::<L>((old(journal).view()).commit_state,
                                        (new_row_addr).spec_add(old(self).sm.row_element_start),
                                        (new_row_addr).spec_add(old(self).sm.row_element_crc_start)),
                                    Some(new_element)),
                                (prev_self.m.view()).contains_key(list_addr),
                                ::builtin::spec_eq(entry,
                                    prev_self.m.spec_index(list_addr)),
                                match (entry.view()) {
                                    ListTableEntryView::Durable { summary } => {
                                        (((summary.length).spec_lt(usize::MAX)) &&
                                                    ((new_element.start()).spec_ge(summary.end_of_logical_range)))
                                            &&
                                            (::builtin::imply(::builtin::is_variant(old(self).logical_range_gaps_policy,
                                                        "LogicalRangeGapsForbidden"),
                                                    ::builtin::spec_eq(new_element.start(),
                                                        summary.end_of_logical_range)))
                                    }
                                    _ => false,
                                }]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range(prev_jv,
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(new_list_addr) => {
                                            (((((!::builtin::spec_eq(new_list_addr,
                                                                                            ::builtin::spec_literal_nat("0"))) &&
                                                                                (::builtin::spec_eq(new_list_addr, list_addr) ||
                                                                                        !(prev_self.view()).tentative.unwrap().m.contains_key(new_list_addr)))
                                                                        &&
                                                                        (match (self.view()).logical_range_gaps_policy {
                                                                                LogicalRangeGapsPolicy::LogicalRangeGapsPermitted =>
                                                                                    (new_element.start()).spec_ge(end_of_range((prev_self.view()).tentative.unwrap().m.spec_index(list_addr))),
                                                                                LogicalRangeGapsPolicy::LogicalRangeGapsForbidden =>
                                                                                    ::builtin::spec_eq(new_element.start(),
                                                                                        end_of_range((prev_self.view()).tentative.unwrap().m.spec_index(list_addr))),
                                                                            })) &&
                                                                (::builtin::spec_eq((self.view()),
                                                                        (ListTableView {
                                                                                tentative: Some((prev_self.view()).tentative.unwrap().append(list_addr,
                                                                                        new_list_addr, new_element)),
                                                                                used_slots: (old(self).view()).used_slots,
                                                                                ..(prev_self.view())
                                                                            })))) && (self.validate_list_addr(new_list_addr))) &&
                                                (((journal.view()).remaining_capacity).spec_ge(((old(journal).view()).remaining_capacity).spec_sub(self.space_needed_to_journal_next)))
                                        }
                                        Err(KvError::CRCMismatch) => {
                                            (!(journal.view()).pm_constants.impervious_to_corruption())
                                                &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(prev_self.view()) })))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_transitive)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let tail_row_addr =
                        match &entry {
                            ListTableEntry::<L>::Durable { summary } => summary.tail,
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                0u64
                            }
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(tail_row_addr,
                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr).last()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(self.sm.table.validate_row_addr(tail_row_addr))
                            };
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (self.deletes.view()).len() };
                    #[verus::internal(spec)]
                    let mut which_delete;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_which_delete = verus_tmp;
                        which_delete = verus_tmp_which_delete;
                    };
                    let which_modification = self.modifications.len();
                    self.tentative_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.tentative_mapping.view()).append(list_addr,
                                new_row_addr, new_element));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ListRowDisposition::InPendingAllocationList {
                                pos: ::builtin::spec_cast_integer::<_,
                                        nat>((self.pending_allocations.view()).len()),
                            }
                    };
                    #[verus::internal(spec)]
                    let mut disposition;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_disposition = verus_tmp;
                        disposition = verus_tmp_disposition;
                    };
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.row_info.view()).insert(new_row_addr,
                                disposition));
                    let new_entry =
                        entry.update_by_appending(which_modification, new_row_addr,
                            new_element);
                    let new_delete = entry.unwrap_durable();
                    self.m.insert(list_addr, new_entry);
                    self.deletes_inverse =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.deletes_inverse.view()).insert(list_addr,
                                which_delete));
                    self.deletes.push(new_delete);
                    self.modifications.push(Some(list_addr));
                    self.pending_allocations.push(new_row_addr);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        prev_self.internal_view().append_case_durable(list_addr,
                                            new_element)))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        prev_self.internal_view().lemma_append_case_durable_works(list_addr,
                            new_element, prev_self.sm);
                    }
                    let next_addr = tail_row_addr + self.sm.row_next_start;
                    let next_crc = calculate_crc(&new_row_addr);
                    let mut bytes_to_write = Vec::<u8>::new();
                    extend_vec_u8_from_slice(&mut bytes_to_write,
                        new_row_addr.as_byte_slice());
                    extend_vec_u8_from_slice(&mut bytes_to_write,
                        next_crc.as_byte_slice());
                    match journal.journal_write(next_addr, bytes_to_write) {
                        Ok(()) => {}
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::InternalError);
                        }
                    }

                    #[verifier::proof_block]
                    {
                        lemma_writing_next_and_crc_together_effect_on_recovery::<L>((old(journal).view()).commit_state,
                            (journal.view()).commit_state, tail_row_addr, new_row_addr,
                            self.sm);
                    }
                    Ok(list_addr)
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn append_case_modified(&mut self, list_addr: u64,
                    new_element: L, journal: &mut Journal<PM>,
                    new_row_addr: u64, entry: ListTableEntry<L>,
                    verus_tmp_prev_self: Ghost<Self>,
                    verus_tmp_prev_jv: Ghost<JournalView>)
                    -> Result<u64, KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_self;

                    #[verifier::proof_block]
                    { prev_self = verus_tmp_prev_self.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_jv;

                    #[verifier::proof_block]
                    { prev_jv = verus_tmp_prev_jv.view() };
                    ::builtin::requires([::builtin::spec_eq(old(self),
                                    (Self {
                                            free_list: old(self).free_list,
                                            m: old(self).m,
                                            ..prev_self
                                        })),
                                ((prev_self.free_list.view()).len()).spec_gt(::builtin::spec_literal_nat("0")),
                                ::builtin::spec_eq((old(self).free_list.view()),
                                    (prev_self.free_list.view()).drop_last()),
                                ::builtin::spec_eq((old(self).m.view()),
                                    (prev_self.m.view()).remove(list_addr)),
                                ::builtin::spec_eq(new_row_addr,
                                    (prev_self.free_list.view()).last()),
                                prev_self.valid(prev_jv), old(journal).valid(),
                                ((old(journal).view()).remaining_capacity).spec_ge(old(self).space_needed_to_journal_next),
                                ::builtin::is_variant((prev_self.view()).tentative, "Some"),
                                (prev_self.view()).tentative.unwrap().m.contains_key(list_addr),
                                prev_self.internal_view().corresponds_to_durable_state((old(journal).view()).durable_state,
                                    prev_self.sm),
                                prev_self.internal_view().corresponds_to_durable_state((old(journal).view()).read_state,
                                    prev_self.sm),
                                (old(journal).view()).matches_except_in_range(prev_jv,
                                    ::builtin::spec_cast_integer::<_,
                                            int>((old(self).view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((old(self).view()).sm.end())),
                                ::builtin::spec_eq((old(journal).view()),
                                    (JournalView {
                                            durable_state: (old(journal).view()).durable_state,
                                            read_state: (old(journal).view()).read_state,
                                            commit_state: (old(journal).view()).commit_state,
                                            ..prev_jv
                                        })),
                                ::builtin::spec_eq(new_row_addr,
                                    (prev_self.free_list.view()).last()),
                                ::builtin::forall(|other_row_addr: u64|
                                        ::builtin::imply({
                                                (old(self).sm.table.validate_row_addr(other_row_addr)) &&
                                                    (!::builtin::spec_eq(other_row_addr, new_row_addr))
                                            },
                                            {
                                                (::builtin::spec_eq(recover_object::<L>((old(journal).view()).commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_element_start),
                                                                (other_row_addr).spec_add(old(self).sm.row_element_crc_start)),
                                                            recover_object::<L>(prev_jv.commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_element_start),
                                                                (other_row_addr).spec_add(old(self).sm.row_element_crc_start))))
                                                    &&
                                                    (::builtin::spec_eq(recover_object::<u64>((old(journal).view()).commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_next_start),
                                                                ((other_row_addr).spec_add(old(self).sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                            recover_object::<u64>(prev_jv.commit_state,
                                                                (other_row_addr).spec_add(old(self).sm.row_next_start),
                                                                ((other_row_addr).spec_add(old(self).sm.row_next_start)).spec_add(u64::spec_size_of()))))
                                            })),
                                ::builtin::spec_eq(recover_object::<u64>((old(journal).view()).commit_state,
                                        (new_row_addr).spec_add(old(self).sm.row_next_start),
                                        ((new_row_addr).spec_add(old(self).sm.row_next_start)).spec_add(u64::spec_size_of())),
                                    Some(0u64)),
                                ::builtin::spec_eq(recover_object::<L>((old(journal).view()).commit_state,
                                        (new_row_addr).spec_add(old(self).sm.row_element_start),
                                        (new_row_addr).spec_add(old(self).sm.row_element_crc_start)),
                                    Some(new_element)),
                                (prev_self.m.view()).contains_key(list_addr),
                                ::builtin::spec_eq(entry,
                                    prev_self.m.spec_index(list_addr)),
                                match (entry.view()) {
                                    ListTableEntryView::Modified { summary, .. } => {
                                        (((summary.length).spec_lt(usize::MAX)) &&
                                                    ((new_element.start()).spec_ge(summary.end_of_logical_range)))
                                            &&
                                            (::builtin::imply(::builtin::is_variant(old(self).logical_range_gaps_policy,
                                                        "LogicalRangeGapsForbidden"),
                                                    ::builtin::spec_eq(new_element.start(),
                                                        summary.end_of_logical_range)))
                                    }
                                    _ => false,
                                }]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range(prev_jv,
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(new_list_addr) => {
                                            ((((((!::builtin::spec_eq(new_list_addr,
                                                                                                    ::builtin::spec_literal_nat("0"))) &&
                                                                                        (::builtin::spec_eq(new_list_addr, list_addr) ||
                                                                                                !(prev_self.view()).tentative.unwrap().m.contains_key(new_list_addr)))
                                                                                &&
                                                                                (match (self.view()).logical_range_gaps_policy {
                                                                                        LogicalRangeGapsPolicy::LogicalRangeGapsPermitted =>
                                                                                            (new_element.start()).spec_ge(end_of_range((prev_self.view()).tentative.unwrap().m.spec_index(list_addr))),
                                                                                        LogicalRangeGapsPolicy::LogicalRangeGapsForbidden =>
                                                                                            ::builtin::spec_eq(new_element.start(),
                                                                                                end_of_range((prev_self.view()).tentative.unwrap().m.spec_index(list_addr))),
                                                                                    })) &&
                                                                        (::builtin::spec_eq((self.view()),
                                                                                (ListTableView {
                                                                                        tentative: Some((prev_self.view()).tentative.unwrap().append(list_addr,
                                                                                                new_list_addr, new_element)),
                                                                                        used_slots: (old(self).view()).used_slots,
                                                                                        ..(prev_self.view())
                                                                                    })))) &&
                                                                (((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                        && (self.validate_list_addr(new_list_addr))) &&
                                                (((journal.view()).remaining_capacity).spec_ge(((old(journal).view()).remaining_capacity).spec_sub(self.space_needed_to_journal_next)))
                                        }
                                        Err(KvError::CRCMismatch) => {
                                            (!(journal.view()).pm_constants.impervious_to_corruption())
                                                &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(prev_self.view()) })))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_transitive)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let tail_row_addr =
                        match &entry {
                            ListTableEntry::<L>::Modified { summary, .. } =>
                                summary.tail,
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                0u64
                            }
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(tail_row_addr,
                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr).last()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(self.sm.table.validate_row_addr(tail_row_addr))
                            };
                    };
                    self.tentative_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.tentative_mapping.view()).append(list_addr,
                                new_row_addr, new_element));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ListRowDisposition::InPendingAllocationList {
                                pos: ::builtin::spec_cast_integer::<_,
                                        nat>((self.pending_allocations.view()).len()),
                            }
                    };
                    #[verus::internal(spec)]
                    let mut disposition;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_disposition = verus_tmp;
                        disposition = verus_tmp_disposition;
                    };
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.row_info.view()).insert(new_row_addr,
                                disposition));
                    let new_entry = entry.append(new_row_addr, new_element);
                    self.m.insert(list_addr, new_entry);
                    self.pending_allocations.push(new_row_addr);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        prev_self.internal_view().append_case_modified(list_addr,
                                            new_element)))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        prev_self.internal_view().lemma_append_case_modified_works(list_addr,
                            new_element, prev_self.sm);
                    }
                    let next_addr = tail_row_addr + self.sm.row_next_start;
                    let next_crc = calculate_crc(&new_row_addr);
                    let mut bytes_to_write = Vec::<u8>::new();
                    extend_vec_u8_from_slice(&mut bytes_to_write,
                        new_row_addr.as_byte_slice());
                    extend_vec_u8_from_slice(&mut bytes_to_write,
                        next_crc.as_byte_slice());
                    match journal.journal_write(next_addr, bytes_to_write) {
                        Ok(()) => {}
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::InternalError);
                        }
                    }

                    #[verifier::proof_block]
                    {
                        lemma_writing_next_and_crc_together_effect_on_recovery::<L>((old(journal).view()).commit_state,
                            (journal.view()).commit_state, tail_row_addr, new_row_addr,
                            self.sm);
                    }
                    Ok(list_addr)
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn write_tail_to_free_slot<PermFactory>(&self, new_element: L,
                    row_addr: u64, journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>,
                    verus_tmp_prev_self: Ghost<Self>) where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_self;

                    #[verifier::proof_block]
                    { prev_self = verus_tmp_prev_self.view() };
                    ::builtin::requires([::builtin::spec_eq(self,
                                    (Self {
                                            free_list: self.free_list,
                                            m: self.m,
                                            ..prev_self
                                        })),
                                ((prev_self.free_list.view()).len()).spec_gt(::builtin::spec_literal_nat("0")),
                                ::builtin::spec_eq((self.free_list.view()),
                                    (prev_self.free_list.view()).drop_last()),
                                ::builtin::spec_eq(row_addr,
                                    (prev_self.free_list.view()).last()),
                                prev_self.valid((old(journal).view())),
                                ::builtin::is_variant((prev_self.view()).tentative, "Some"),
                                old(journal).valid(),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                self.perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures([journal.valid(),
                                ::builtin::spec_eq((journal.view()).powerpm_id,
                                    (old(journal).view()).powerpm_id),
                                (journal.view()).matches_except_in_range((old(journal).view()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.end())),
                                ::builtin::spec_eq((journal.view()).journaled_addrs,
                                    (old(journal).view()).journaled_addrs),
                                ::builtin::spec_eq((journal.view()).remaining_capacity,
                                    (old(journal).view()).remaining_capacity),
                                self.internal_view().corresponds_to_durable_state((journal.view()).durable_state,
                                    self.sm),
                                self.internal_view().corresponds_to_durable_state((journal.view()).read_state,
                                    self.sm),
                                ::builtin::forall(|other_row_addr: u64|
                                        ::builtin::imply({
                                                (self.sm.table.validate_row_addr(other_row_addr)) &&
                                                    (!::builtin::spec_eq(other_row_addr, row_addr))
                                            },
                                            {
                                                (::builtin::spec_eq(recover_object::<L>((journal.view()).commit_state,
                                                                (other_row_addr).spec_add(self.sm.row_element_start),
                                                                (other_row_addr).spec_add(self.sm.row_element_crc_start)),
                                                            recover_object::<L>((old(journal).view()).commit_state,
                                                                (other_row_addr).spec_add(self.sm.row_element_start),
                                                                (other_row_addr).spec_add(self.sm.row_element_crc_start))))
                                                    &&
                                                    (::builtin::spec_eq(recover_object::<u64>((journal.view()).commit_state,
                                                                (other_row_addr).spec_add(self.sm.row_next_start),
                                                                ((other_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                            recover_object::<u64>((old(journal).view()).commit_state,
                                                                (other_row_addr).spec_add(self.sm.row_next_start),
                                                                ((other_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of()))))
                                            })),
                                ::builtin::spec_eq(recover_object::<L>((journal.view()).commit_state,
                                        (row_addr).spec_add(self.sm.row_element_start),
                                        (row_addr).spec_add(self.sm.row_element_crc_start)),
                                    Some(new_element)),
                                ::builtin::spec_eq(recover_object::<u64>((journal.view()).commit_state,
                                        (row_addr).spec_add(self.sm.row_next_start),
                                        ((row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())),
                                    Some(0u64))]);

                    #[verifier::proof_block]
                    {
                        prev_self.lemma_valid_implications((journal.view()));
                        journal.lemma_valid_implications();
                        Self::lemma_writing_to_free_slot_has_permission_later_forall(prev_self.internal_view(),
                            (journal.view()), prev_self.sm,
                            ((prev_self.free_list.view()).len()).spec_sub(::builtin::spec_literal_nat("1")),
                            row_addr, *perm_factory);
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_transitive)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let element_addr = row_addr + self.sm.row_element_start;
                    let element_crc_addr =
                        row_addr + self.sm.row_element_crc_start;
                    let element_crc = calculate_crc(&new_element);
                    journal.write_object::<L,
                        PermFactory::Perm>(element_addr, &new_element,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    journal.write_object::<u64,
                        PermFactory::Perm>(element_crc_addr, &element_crc,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    let next_addr = row_addr + self.sm.row_next_start;
                    let next_crc_addr = next_addr + size_of::<u64>() as u64;
                    let next: u64 = 0;
                    let next_crc = calculate_crc(&next);
                    journal.write_object::<u64,
                        PermFactory::Perm>(next_addr, &next,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    journal.write_object::<u64,
                        PermFactory::Perm>(next_crc_addr, &next_crc,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(self.internal_view().corresponds_to_durable_state((journal.view()).durable_state,
                                        self.sm))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(self.internal_view().corresponds_to_durable_state((journal.view()).read_state,
                                        self.sm))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        lemma_writing_element_and_next_effect_on_recovery((old(journal).view()).commit_state,
                            (journal.view()).commit_state, row_addr, new_element, 0u64,
                            self.sm);
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn append<PermFactory>(&mut self, list_addr: u64,
                    new_element: L, journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<u64, KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().m.contains_key(list_addr),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(new_list_addr) => {
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            (((((((!::builtin::spec_eq(new_list_addr,
                                                                                                            ::builtin::spec_literal_nat("0"))) &&
                                                                                                (::builtin::spec_eq(new_list_addr, list_addr) ||
                                                                                                        !(old(self).view()).tentative.unwrap().m.contains_key(new_list_addr)))
                                                                                        && ((old_list.len()).spec_lt(usize::MAX))) &&
                                                                                (match (self.view()).logical_range_gaps_policy {
                                                                                        LogicalRangeGapsPolicy::LogicalRangeGapsPermitted =>
                                                                                            (new_element.start()).spec_ge(end_of_range(old_list)),
                                                                                        LogicalRangeGapsPolicy::LogicalRangeGapsForbidden =>
                                                                                            ::builtin::spec_eq(new_element.start(),
                                                                                                end_of_range(old_list)),
                                                                                    })) &&
                                                                        (::builtin::spec_eq((self.view()),
                                                                                (ListTableView {
                                                                                        tentative: Some((old(self).view()).tentative.unwrap().append(list_addr,
                                                                                                new_list_addr, new_element)),
                                                                                        used_slots: (self.view()).used_slots,
                                                                                        ..(old(self).view())
                                                                                    })))) &&
                                                                (((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                        && (self.validate_list_addr(new_list_addr))) &&
                                                (((journal.view()).remaining_capacity).spec_ge(((((old(journal).view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())).spec_sub(u64::spec_size_of())))
                                        }
                                        Err(KvError::ListLengthWouldExceedUsizeMax) => {
                                            ((::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                                        (((old(self).view()).tentative.unwrap().m.spec_index(list_addr).len()).spec_ge(usize::MAX)))
                                                &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::PageLeavesLogicalRangeGap { end_of_valid_range
                                            }) => {
                                            (((((::builtin::spec_eq((self.view()), (old(self).view())))
                                                                                &&
                                                                                (::builtin::is_variant((self.view()).logical_range_gaps_policy,
                                                                                        "LogicalRangeGapsForbidden"))) &&
                                                                        (((old(self).view()).tentative.unwrap().m.spec_index(list_addr).len()).spec_lt(usize::MAX)))
                                                                &&
                                                                ((new_element.start()).spec_gt(end_of_range((old(self).view()).tentative.unwrap().m.spec_index(list_addr)))))
                                                        &&
                                                        (::builtin::spec_eq(end_of_valid_range,
                                                                end_of_range((old(self).view()).tentative.unwrap().m.spec_index(list_addr)))))
                                                &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::PageOutOfLogicalRangeOrder { end_of_valid_range
                                            }) => {
                                            ((((::builtin::spec_eq((self.view()), (old(self).view())))
                                                                        &&
                                                                        (((old(self).view()).tentative.unwrap().m.spec_index(list_addr).len()).spec_lt(usize::MAX)))
                                                                &&
                                                                ((new_element.start()).spec_lt(end_of_range((old(self).view()).tentative.unwrap().m.spec_index(list_addr)))))
                                                        &&
                                                        (::builtin::spec_eq(end_of_valid_range,
                                                                end_of_range((old(self).view()).tentative.unwrap().m.spec_index(list_addr)))))
                                                &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                                &&
                                                ({
                                                        (((old(journal).view()).remaining_capacity).spec_lt(((spec_journal_entry_overhead()).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of())))
                                                            ||
                                                            (::builtin::spec_eq((self.view()).used_slots,
                                                                    (self.view()).sm.num_rows()))
                                                    })
                                        }
                                        Err(KvError::CRCMismatch) => {
                                            (!(journal.view()).pm_constants.impervious_to_corruption())
                                                &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        self.lemma_valid_implications((journal.view()));
                        journal.lemma_valid_implications();
                        if ((self.free_list.view()).len()).spec_gt(::builtin::spec_literal_nat("0"))
                                {
                                Self::lemma_writing_to_free_slot_has_permission_later_forall(self.internal_view(),
                                    (journal.view()), self.sm,
                                    ((self.free_list.view()).len()).spec_sub(::builtin::spec_literal_nat("1")),
                                    (self.free_list.view()).last(), *perm_factory);
                            }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_transitive)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    if self.free_list.len() == 0 {
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                    if journal.remaining_capacity() <
                                self.space_needed_to_journal_next {
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                    let entry =
                        match self.m.remove(&list_addr) {
                            None => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError)
                            }
                            Some(e) => e,
                        };
                    let (length, end_of_valid_range) =
                        match &entry {
                            ListTableEntry::<L>::Modified { ref summary, .. } =>
                                (summary.length, summary.end_of_logical_range),
                            ListTableEntry::<L>::Durable { ref summary } =>
                                (summary.length, summary.end_of_logical_range),
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(length,
                                        (self.tentative_mapping.view()).list_elements.spec_index(list_addr).len()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(end_of_valid_range,
                                        end_of_range((self.tentative_mapping.view()).list_elements.spec_index(list_addr))))
                            };
                    };
                    if length >= usize::MAX {
                            self.m.insert(list_addr, entry);

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                                old(self).internal_view()))
                                    };
                            };
                            return Err(KvError::ListLengthWouldExceedUsizeMax);
                        }
                    if new_element.start() < end_of_valid_range {
                            self.m.insert(list_addr, entry);

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                                old(self).internal_view()))
                                    };
                            };
                            return Err(KvError::PageOutOfLogicalRangeOrder {
                                        end_of_valid_range,
                                    });
                        }
                    match self.logical_range_gaps_policy {
                        LogicalRangeGapsPolicy::LogicalRangeGapsForbidden =>
                            if new_element.start() > end_of_valid_range {
                                    self.m.insert(list_addr, entry);

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        ||
                                            {
                                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                                        old(self).internal_view()))
                                            };
                                    };
                                    return Err(KvError::PageLeavesLogicalRangeGap {
                                                end_of_valid_range,
                                            });
                                },
                        _ => {}
                    }
                    let row_addr =
                        match self.free_list.pop() {
                            None => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                0u64
                            }
                            Some(a) => a,
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(row_addr,
                                        (old(self).free_list.view()).spec_index(((old(self).free_list.view()).len()).spec_sub(::builtin::spec_literal_nat("1")))))
                            };
                    };
                    self.write_tail_to_free_slot::<PermFactory>(new_element,
                        row_addr, journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] *old(self)));
                    match entry {
                        ListTableEntry::<L>::Durable { .. } =>
                            self.append_case_durable(list_addr, new_element, journal,
                                row_addr, entry,
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] *old(self)),
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (old(journal).view()))),
                        ListTableEntry::<L>::Modified { .. } =>
                            self.append_case_modified(list_addr, new_element, journal,
                                row_addr, entry,
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] *old(self)),
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (old(journal).view()))),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn create_singleton<PermFactory>(&mut self,
                    new_element: L, journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<u64, KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                old(journal).valid(),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(new_row_addr) => {
                                            ((((((!::builtin::spec_eq(new_row_addr,
                                                                                                    ::builtin::spec_literal_nat("0"))) &&
                                                                                        (::builtin::imply(::builtin::is_variant((self.view()).logical_range_gaps_policy,
                                                                                                    "LogicalRangeGapsForbidden"),
                                                                                                ::builtin::spec_eq(new_element.start(),
                                                                                                    ::builtin::spec_literal_nat("0"))))) &&
                                                                                (!(old(self).view()).tentative.unwrap().m.contains_key(new_row_addr)))
                                                                        &&
                                                                        (::builtin::spec_eq((self.view()),
                                                                                (ListTableView {
                                                                                        tentative: Some((old(self).view()).tentative.unwrap().create_singleton(new_row_addr,
                                                                                                new_element)),
                                                                                        used_slots: (self.view()).used_slots,
                                                                                        ..(old(self).view())
                                                                                    })))) &&
                                                                (((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                        && (self.validate_list_addr(new_row_addr))) &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::PageLeavesLogicalRangeGap { end_of_valid_range
                                            }) => {
                                            ((((::builtin::spec_eq((self.view()), (old(self).view())))
                                                                        &&
                                                                        (::builtin::is_variant((self.view()).logical_range_gaps_policy,
                                                                                "LogicalRangeGapsForbidden"))) &&
                                                                (!::builtin::spec_eq(new_element.start(),
                                                                            ::builtin::spec_literal_nat("0")))) &&
                                                        (::builtin::spec_eq(end_of_valid_range,
                                                                ::builtin::spec_literal_nat("0")))) &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                                &&
                                                (::builtin::spec_eq((self.view()).used_slots,
                                                        (self.view()).sm.num_rows()))
                                        }
                                        Err(KvError::CRCMismatch) => {
                                            (!(journal.view()).pm_constants.impervious_to_corruption())
                                                &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        self.lemma_valid_implications((journal.view()));
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    match self.logical_range_gaps_policy {
                        LogicalRangeGapsPolicy::LogicalRangeGapsForbidden =>
                            if new_element.start() != 0 {
                                    return Err(KvError::PageLeavesLogicalRangeGap {
                                                end_of_valid_range: 0,
                                            });
                                },
                        _ => {}
                    }
                    let row_addr =
                        match self.free_list.pop() {
                            None => {
                                self.must_abort =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                                return Err(KvError::OutOfSpace);
                            }
                            Some(a) => a,
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((old(self).free_list.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                    int>((self.free_list.view()).len())), row_addr))
                            };
                    };
                    self.write_tail_to_free_slot::<PermFactory>(new_element,
                        row_addr, journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory),
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] *old(self)));
                    self.tentative_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.tentative_mapping.view()).create_singleton(row_addr,
                                new_element));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ListRowDisposition::InPendingAllocationList {
                                pos: ::builtin::spec_cast_integer::<_,
                                        nat>(self.pending_allocations.len()),
                            }
                    };
                    #[verus::internal(spec)]
                    let mut disposition;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_disposition = verus_tmp;
                        disposition = verus_tmp_disposition;
                    };
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.row_info.view()).insert(row_addr,
                                disposition));
                    let which_modification = self.modifications.len();
                    self.modifications.push(Some(row_addr));
                    self.pending_allocations.push(row_addr);
                    let addrs =
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([row_addr]));
                    let elements =
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([new_element]));

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((addrs.view()),
                                        ::vstd::vstd::seq::Seq::empty().push(row_addr)))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((elements.view()),
                                        ::vstd::vstd::seq::Seq::empty().push(new_element)))
                            };
                    };
                    let summary =
                        ListSummary {
                            head: row_addr,
                            tail: row_addr,
                            length: 1,
                            end_of_logical_range: new_element.end(),
                        };
                    let entry =
                        ListTableEntry::<L>::Modified {
                            which_modification,
                            durable_head: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0")),
                            summary,
                            addrs,
                            elements,
                        };
                    self.m.insert(row_addr, entry);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        old(self).internal_view().create_singleton(new_element)))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        old(self).internal_view().lemma_create_singleton_works(new_element,
                            self.sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((self.view()),
                                        (ListTableView {
                                                tentative: Some((old(self).view()).tentative.unwrap().create_singleton(row_addr,
                                                        new_element)),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(self.valid((journal.view()))) };
                    };
                    Ok(row_addr)
                }
            }
        }
        pub mod commit_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::subrange_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn commit_m(self)
                    -> Map<u64, ListTableEntryView<L>> {
                    Map::<u64,
                            ListTableEntryView<L>>::new(::builtin::closure_to_fn_spec(|list_addr:
                                    u64| self.m.contains_key(list_addr)),
                        ::builtin::closure_to_fn_spec(|list_addr: u64|
                                self.m.spec_index(list_addr).commit()))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn commit_row_info(self)
                    -> Map<u64, ListRowDisposition> {
                    Map::<u64,
                            ListRowDisposition>::new(::builtin::closure_to_fn_spec(|row_addr:
                                    u64| self.row_info.contains_key(row_addr)),
                        ::builtin::closure_to_fn_spec(|row_addr: u64|
                                match self.row_info.spec_index(row_addr) {
                                    ListRowDisposition::InPendingAllocationList { pos } =>
                                        ListRowDisposition::NowhereFree,
                                    ListRowDisposition::InPendingDeallocationList { pos } =>
                                        ListRowDisposition::InFreeList {
                                            pos: (self.free_list.len()).spec_add(pos),
                                        },
                                    ListRowDisposition::InBothPendingLists {
                                        alloc_pos, dealloc_pos } =>
                                        ListRowDisposition::InFreeList {
                                            pos: (self.free_list.len()).spec_add(dealloc_pos),
                                        },
                                    _ => self.row_info.spec_index(row_addr),
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn commit(self) -> Self {
                    Self {
                        durable_mapping: self.tentative_mapping,
                        row_info: self.commit_row_info(),
                        m: self.commit_m(),
                        deletes_inverse: Map::<u64, nat>::empty(),
                        deletes: Seq::<ListSummary>::empty(),
                        modifications: Seq::<Option<u64>>::empty(),
                        free_list: (self.free_list).spec_add(self.pending_deallocations),
                        pending_allocations: Seq::<u64>::empty(),
                        pending_deallocations: Seq::<u64>::empty(),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_commit_works(self, s: Seq<u8>,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([self.valid(sm),
                                self.corresponds_to_tentative_state(s, sm)]);
                    ::builtin::ensures([self.commit().valid(sm),
                                self.commit().corresponds_to_durable_state(s, sm)]);
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntry<L> where L: PmCopy + LogicalRange + Sized +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub(super) fn commit(self) -> Self {
                    ::builtin::ensures(|result: Self|
                            [::builtin::spec_eq((result.view()),
                                        (self.view()).commit()),
                                    ::builtin::spec_eq((result.view()),
                                        (result.view()).commit())]);
                    match self {
                        ListTableEntry::Durable { summary } =>
                            ListTableEntry::Durable { summary },
                        ListTableEntry::Modified { summary, .. } =>
                            ListTableEntry::Durable { summary },
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_m_to_reflect_commit_of_modifications(&mut self) {
                    ::builtin::requires([::builtin::forall(|which_modification:
                                            int|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        which_modification), old(self).modifications.len())),
                                            (((if let Some(list_addr) =
                                                                    (#[verus::internal(trigger)] old(self).modifications.spec_index(which_modification))
                                                                {
                                                                (old(self).m.view()).contains_key(list_addr)
                                                            } else { true })))))]);
                    ::builtin::ensures([::builtin::spec_eq(self,
                                    (Self { m: self.m, ..*old(self) })),
                                ::builtin::forall(|i: int|
                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), self.modifications.len())),
                                            (((if let Some(list_addr) =
                                                                    (#[verus::internal(trigger)] old(self).modifications.spec_index(i))
                                                                {
                                                                {
                                                                    ((self.m.view()).contains_key(list_addr)) &&
                                                                        (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                                ((old(self).m.view()).spec_index(list_addr).view()).commit()))
                                                                }
                                                            } else { true }))))),
                                ::builtin::forall(|list_addr: u64|
                                        ::builtin::imply(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr),
                                            {
                                                ((old(self).m.view()).contains_key(list_addr)) &&
                                                    ({
                                                            (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                        ((old(self).m.view()).spec_index(list_addr).view()))) ||
                                                                (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                        ((old(self).m.view()).spec_index(list_addr).view()).commit()))
                                                        })
                                            })),
                                ::builtin::forall(|list_addr: u64|
                                        ::builtin::imply(#[verus::internal(trigger)] (old(self).m.view()).contains_key(list_addr),
                                            (self.m.view()).contains_key(list_addr)))]);
                    let num_modifications = self.modifications.len();
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..num_modifications)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..num_modifications)),
                                                            true)),
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(self, (Self { m: self.m, ..*old(self) }))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(num_modifications,
                                                            self.modifications.len())
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                i), old(self).modifications.len())),
                                                                    (((if let Some(list_addr) =
                                                                                            (#[verus::internal(trigger)] old(self).modifications.spec_index(i))
                                                                                        {
                                                                                        (old(self).m.view()).contains_key(list_addr)
                                                                                    } else { true })))))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (self.m.view()).contains_key(list_addr),
                                                                    {
                                                                        ((old(self).m.view()).contains_key(list_addr)) &&
                                                                            ({
                                                                                    (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                                                ((old(self).m.view()).spec_index(list_addr).view()))) ||
                                                                                        (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                                                ((old(self).m.view()).spec_index(list_addr).view()).commit()))
                                                                                })
                                                                    }))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (old(self).m.view()).contains_key(list_addr),
                                                                    (self.m.view()).contains_key(list_addr)))
                                                    },
                                                    {
                                                        let which_modification =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                i), which_modification)),
                                                                    (((if let Some(list_addr) =
                                                                                            (#[verus::internal(trigger)] self.modifications.spec_index(i))
                                                                                        {
                                                                                        {
                                                                                            ((((old(self).m.view()).contains_key(list_addr)) &&
                                                                                                                ((self.m.view()).contains_key(list_addr))) &&
                                                                                                        (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                                                                ((old(self).m.view()).spec_index(list_addr).view()).commit())))
                                                                                                &&
                                                                                                (::builtin::spec_eq(((self.m.view()).spec_index(list_addr).view()),
                                                                                                        ((self.m.view()).spec_index(list_addr).view()).commit()))
                                                                                        }
                                                                                    } else { true })))))
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let which_modification = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verus::internal(proof_block)]
                                                    {
                                                        ::builtin::reveal_hide_({
                                                                #[verus::internal(reveal_fn)]
                                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                                    ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                                                }

                                                                #[verus::internal(broadcast_use_reveal)]
                                                                __VERUS_REVEAL_INTERNAL__
                                                            }, 1);
                                                    }
                                                    match self.modifications[which_modification] {
                                                        None => {}
                                                        Some(list_addr) => {
                                                            let old_entry = self.m.remove(&list_addr);

                                                            #[verifier::proof_block]
                                                            {

                                                                #[verus::internal(const_header_wrapper)]
                                                                ||
                                                                    {
                                                                        ::builtin::assert_(::builtin::is_variant(old_entry, "Some"))
                                                                    };
                                                            };
                                                            let new_entry = old_entry.unwrap().commit();
                                                            self.m.insert(list_addr, new_entry);
                                                        }
                                                    };
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_m_to_reflect_commit(&mut self,
                    verus_tmp_jv: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv;

                    #[verifier::proof_block]
                    { jv = verus_tmp_jv.view() };
                    ::builtin::requires([old(self).valid(jv)]);
                    ::builtin::ensures([::builtin::spec_eq(self,
                                    (Self { m: self.m, ..*old(self) })),
                                ::builtin::spec_eq(self.internal_view().m,
                                    old(self).internal_view().commit().m)]);
                    self.update_m_to_reflect_commit_of_modifications();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view().m,
                                        old(self).internal_view().commit().m))
                            };
                    };
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn commit(&mut self,
                    verus_tmp_jv_before_commit: Ghost<JournalView>,
                    verus_tmp_jv_after_commit: Ghost<JournalView>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_before_commit;

                    #[verifier::proof_block]
                    { jv_before_commit = verus_tmp_jv_before_commit.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let jv_after_commit;

                    #[verifier::proof_block]
                    { jv_after_commit = verus_tmp_jv_after_commit.view() };
                    ::builtin::requires([old(self).valid(jv_before_commit),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                jv_before_commit.valid(), jv_after_commit.valid(),
                                jv_after_commit.committed_from(jv_before_commit)]);
                    ::builtin::ensures([self.valid(jv_after_commit),
                                ::builtin::spec_eq((self.view()),
                                    (ListTableView {
                                            durable: (old(self).view()).tentative.unwrap(),
                                            used_slots: (self.view()).used_slots,
                                            ..(old(self).view())
                                        })),
                                ({
                                        let m = (self.view()).durable.m;
                                        (m.dom().finite()) &&
                                            (::builtin::spec_eq((self.view()).used_slots,
                                                    m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                                                        ::builtin::closure_to_fn_spec(|total: int, row_addr: u64|
                                                                (total).spec_add(m.spec_index(row_addr).len())))))
                                    })]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = self.internal_view().commit() };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };

                    #[verifier::proof_block]
                    {
                        self.internal_view().lemma_commit_works(jv_before_commit.commit_state,
                            self.sm);
                    }
                    self.update_m_to_reflect_commit(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] jv_before_commit));
                    self.durable_mapping = self.tentative_mapping;
                    self.deletes_inverse =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.deletes_inverse);
                    self.deletes.clear();
                    self.modifications.clear();
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.row_info);
                    self.free_list.append(&mut self.pending_deallocations);
                    self.pending_allocations.clear();
                    self.pending_deallocations.clear();

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        old(self).internal_view().commit()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(self.valid(jv_after_commit),
                                        {
                                            let jv_committed =
                                                JournalView {
                                                    durable_state: jv_before_commit.commit_state,
                                                    read_state: jv_before_commit.commit_state,
                                                    commit_state: jv_before_commit.commit_state,
                                                    remaining_capacity: ::builtin::spec_cast_integer::<_,
                                                            int>(jv_before_commit.constants.journal_capacity),
                                                    journaled_addrs: Set::<int>::empty(),
                                                    ..jv_before_commit
                                                };
                                            ::builtin::assert_(self.valid(jv_committed));
                                            self.lemma_valid_depends_only_on_my_area(jv_committed,
                                                jv_after_commit);
                                        });
                                }
                            };
                    }

                    #[verifier::proof_block]
                    {
                        self.internal_view().lemma_corresponds_implication_for_free_list_length(self.sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((self.view()),
                                        (ListTableView {
                                                durable: (old(self).view()).tentative.unwrap(),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })))
                            };
                    };
                }
            }
        }
        pub mod delete_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<L> ListRecoveryMapping<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn delete(self, list_addr: u64) -> Self {
                    ::builtin::recommends([self.list_info.contains_key(list_addr)]);
                    let new_row_info =
                        Map::<u64,
                                ListRowRecoveryInfo<L>>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.row_info.contains_key(row_addr) &&
                                        !::builtin::spec_eq(self.row_info.spec_index(row_addr).head,
                                                list_addr)),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    self.row_info.spec_index(row_addr)));
                    Self {
                        row_info: new_row_info,
                        list_info: self.list_info.remove(list_addr),
                        list_elements: self.list_elements.remove(list_addr),
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl ListRowDisposition {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn add_to_pending_deallocations(self,
                    dealloc_pos: nat) -> Self {
                    match self {
                        ListRowDisposition::NowhereFree =>
                            ListRowDisposition::InPendingDeallocationList {
                                pos: dealloc_pos,
                            },
                        ListRowDisposition::InPendingAllocationList { pos } =>
                            ListRowDisposition::InBothPendingLists {
                                alloc_pos: pos,
                                dealloc_pos: dealloc_pos,
                            },
                        _ => self,
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn delete(self, list_addr: u64) -> Self {
                    ::builtin::recommends([self.m.contains_key(list_addr)]);
                    let new_row_info =
                        Map::<u64,
                                ListRowDisposition>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64| self.row_info.contains_key(row_addr)),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    if {
                                                (self.tentative_mapping.row_info.contains_key(row_addr)) &&
                                                    (::builtin::spec_eq(self.tentative_mapping.row_info.spec_index(row_addr).head,
                                                            list_addr))
                                            } {
                                            self.row_info.spec_index(row_addr).add_to_pending_deallocations((self.pending_deallocations.len()).spec_add(::builtin::spec_cast_integer::<_,
                                                            nat>(self.tentative_mapping.row_info.spec_index(row_addr).pos)))
                                        } else { self.row_info.spec_index(row_addr) }));
                    let new_deletes =
                        if let ListTableEntryView::Durable { summary } =
                                    self.m.spec_index(list_addr) {
                                self.deletes.push(summary)
                            } else { self.deletes };
                    let new_deletes_inverse =
                        if ::builtin::is_variant(self.m.spec_index(list_addr),
                                    "Durable") {
                                self.deletes_inverse.insert(list_addr, self.deletes.len())
                            } else { self.deletes_inverse };
                    let new_modifications =
                        if let ListTableEntryView::Modified { which_modification, ..
                                    } = self.m.spec_index(list_addr) {
                                self.modifications.update(::builtin::spec_cast_integer::<_,
                                            int>(which_modification), None)
                            } else { self.modifications };
                    Self {
                        tentative_mapping: self.tentative_mapping.delete(list_addr),
                        row_info: new_row_info,
                        m: self.m.remove(list_addr),
                        deletes_inverse: new_deletes_inverse,
                        deletes: new_deletes,
                        modifications: new_modifications,
                        pending_deallocations: (self.pending_deallocations).spec_add(self.tentative_mapping.list_info.spec_index(list_addr)),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_delete_works(self, list_addr: u64,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(), self.valid(sm),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                self.durable_mapping.internally_consistent(sm),
                                self.tentative_mapping.internally_consistent(sm),
                                self.m.contains_key(list_addr)]);
                    ::builtin::ensures([self.delete(list_addr).valid(sm),
                                ::builtin::spec_eq(self.delete(list_addr).tentative_mapping.as_snapshot(),
                                    self.tentative_mapping.as_snapshot().delete(list_addr))]);
                    let new_self = self.delete(list_addr);
                    let old_snapshot = self.tentative_mapping.as_snapshot();
                    let new_snapshot = new_self.tentative_mapping.as_snapshot();
                    ::builtin::assert_(::builtin::ext_equal(new_snapshot,
                            old_snapshot.delete(list_addr)));
                    ::builtin::assert_(::builtin::ext_equal(self.delete(list_addr).tentative_mapping.as_snapshot(),
                            self.tentative_mapping.as_snapshot().delete(list_addr)));
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_row_addrs_case_durable(&self, list_addr: u64,
                    summary: &ListSummary, journal: &Journal<PM>)
                    -> Result<Vec<u64>, KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                    "Durable"),
                                ::builtin::spec_eq(summary,
                                    ((self.m.view()).spec_index(list_addr).arrow_Durable_summary()))]);
                    ::builtin::ensures(|result: Result<Vec<u64>, KvError>|
                            [match result {
                                        Ok(addrs) =>
                                            ::builtin::spec_eq((addrs.view()),
                                                (self.tentative_mapping.view()).list_info.spec_index(list_addr)),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    let mut current_addr = list_addr;
                    let mut result = Vec::<u64>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = ::builtin::spec_literal_integer("0") };
                    #[verus::internal(spec)]
                    let mut current_pos;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_current_pos: int = verus_tmp;
                        current_pos = verus_tmp_current_pos;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_addrs = verus_tmp;
                        addrs = verus_tmp_addrs;
                    };
                    let pm = journal.get_pm_region_ref();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(addrs.take(current_pos),
                                        Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    while current_addr != 0 {
                        ::builtin::invariant([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                current_pos), addrs.len())),
                                    (::builtin::spec_eq(current_pos, addrs.len())) ==
                                        (::builtin::spec_eq(current_addr,
                                                ::builtin::spec_literal_nat("0"))),
                                    ::builtin::imply((current_pos).spec_lt(addrs.len()),
                                        ::builtin::spec_eq(current_addr,
                                            addrs.spec_index(current_pos))),
                                    ::builtin::spec_eq((result.view()),
                                        addrs.take(current_pos)), self.valid((journal.view())),
                                    journal.valid(),
                                    (self.durable_mapping.view()).list_info.contains_key(list_addr),
                                    ::builtin::spec_eq(addrs,
                                        (self.durable_mapping.view()).list_info.spec_index(list_addr)),
                                    pm.inv(),
                                    ::builtin::spec_eq((pm.view()).read_state,
                                        (journal.view()).read_state),
                                    ::builtin::spec_eq(pm.constants(),
                                        (journal.view()).pm_constants)]);
                        ::builtin::decreases(((addrs.len()).spec_sub((result.view()).len()),));

                        #[verifier::proof_block]
                        {
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                        }

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal(addrs.take(current_pos).push(current_addr),
                                            addrs.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                };
                        };
                        result.push(current_addr);
                        let next_addr = current_addr + self.sm.row_next_start;
                        let next_crc_addr = next_addr + size_of::<u64>() as u64;
                        current_addr =
                            match exec_recover_object::<PM,
                                        u64>(pm, next_addr, next_crc_addr) {
                                Some(n) => n,
                                None => { return Err(KvError::CRCMismatch); }
                            };

                        #[verifier::proof_block]
                        {
                            current_pos =
                                (current_pos).spec_add(::builtin::spec_literal_nat("1"));
                        }
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(addrs.take(current_pos),
                                        addrs))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((self.tentative_mapping.view()).list_info.spec_index(list_addr),
                                        (self.durable_mapping.view()).list_info.spec_index(list_addr)))
                            };
                    };
                    Ok(result)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_row_addrs_case_modified(&self, list_addr: u64,
                    verus_tmp_durable_head: Ghost<u64>, summary: &ListSummary,
                    addrs: &Vec<u64>, journal: &Journal<PM>)
                    -> Result<Vec<u64>, KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let durable_head;

                    #[verifier::proof_block]
                    { durable_head = verus_tmp_durable_head.view() };
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                    "Modified"),
                                ::builtin::spec_eq(durable_head,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_durable_head())),
                                ::builtin::spec_eq(summary,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_summary())),
                                ::builtin::spec_eq(addrs,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_addrs()))]);
                    ::builtin::ensures(|result: Result<Vec<u64>, KvError>|
                            [match result {
                                        Ok(addrs) =>
                                            ::builtin::spec_eq((addrs.view()),
                                                (self.tentative_mapping.view()).list_info.spec_index(list_addr)),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    if summary.length == addrs.len() {
                            return Ok(addrs.clone());
                        }
                    let mut current_addr = list_addr;
                    let mut result = Vec::<u64>::new();
                    let mut current_pos: usize = 0;
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_info.spec_index(durable_head)
                    };
                    #[verus::internal(spec)]
                    let mut durable_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_addrs = verus_tmp;
                        durable_addrs = verus_tmp_durable_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.tentative_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut tentative_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_tentative_addrs = verus_tmp;
                        tentative_addrs = verus_tmp_tentative_addrs;
                    };
                    let pm = journal.get_pm_region_ref();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                    int>(current_pos)), Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    let num_durable_addrs = summary.length - addrs.len();
                    while current_pos < num_durable_addrs {
                        ::builtin::invariant([::builtin::spec_eq(num_durable_addrs,
                                        (summary.length).spec_sub(addrs.len())),
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                current_pos), num_durable_addrs)),
                                    ::builtin::imply((current_pos).spec_lt(num_durable_addrs),
                                        ::builtin::spec_eq(current_addr,
                                            tentative_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                        int>(current_pos)))),
                                    ::builtin::spec_eq((result.view()),
                                        tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                    int>(current_pos))), self.valid((journal.view())),
                                    journal.valid(),
                                    (self.durable_mapping.view()).list_info.contains_key(durable_head),
                                    (self.tentative_mapping.view()).list_info.contains_key(list_addr),
                                    (::builtin::spec_literal_nat("0")).spec_lt(durable_addrs.len()),
                                    (addrs.len()).spec_lt(summary.length),
                                    ((summary.length).spec_sub(addrs.len())).spec_le(durable_addrs.len()),
                                    ::builtin::spec_eq(durable_addrs,
                                        (self.durable_mapping.view()).list_info.spec_index(durable_head)),
                                    ::builtin::spec_eq(tentative_addrs,
                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr)),
                                    ::builtin::spec_eq(tentative_addrs,
                                        (durable_addrs.skip((durable_addrs.len()).spec_sub(((summary.length).spec_sub(addrs.len()))))).spec_add((addrs.view()))),
                                    pm.inv(),
                                    ::builtin::spec_eq((pm.view()).read_state,
                                        (journal.view()).read_state),
                                    ::builtin::spec_eq(pm.constants(),
                                        (journal.view()).pm_constants)]);
                        ::builtin::decreases(((num_durable_addrs).spec_sub(current_pos),));

                        #[verifier::proof_block]
                        {
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                        }

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                            int>(current_pos)).push(current_addr),
                                            tentative_addrs.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                };
                        };
                        result.push(current_addr);
                        let next_addr = current_addr + self.sm.row_next_start;
                        let next_crc_addr = next_addr + size_of::<u64>() as u64;
                        current_addr =
                            match exec_recover_object::<PM,
                                        u64>(pm, next_addr, next_crc_addr) {
                                Some(n) => n,
                                None => { return Err(KvError::CRCMismatch); }
                            };
                        current_pos = current_pos + 1;
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(tentative_addrs,
                                            ((result.view())).spec_add((addrs.view()))),
                                        {
                                            ::builtin::assert_(::builtin::ext_equal(tentative_addrs,
                                                    (tentative_addrs.take((summary.length).spec_sub(addrs.len()))).spec_add((addrs.view()))));
                                        });
                                }
                            };
                    }
                    let mut addrs_cloned = addrs.clone();
                    result.append(&mut addrs_cloned);
                    Ok(result)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_row_addrs(&self, list_addr: u64, journal: &Journal<PM>)
                    -> Result<Vec<u64>, KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr)]);
                    ::builtin::ensures(|result: Result<Vec<u64>, KvError>|
                            [match result {
                                        Ok(addrs) =>
                                            ::builtin::spec_eq((addrs.view()),
                                                (self.tentative_mapping.view()).list_info.spec_index(list_addr)),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    match self.m.get(&list_addr) {
                        None => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            Err(KvError::InternalError)
                        }
                        Some(ListTableEntry::<L>::Durable { ref summary }) =>
                            self.get_row_addrs_case_durable(list_addr, summary,
                                journal),
                        Some(ListTableEntry::<L>::Modified {
                            ref durable_head, ref summary, ref addrs, .. }) =>
                            self.get_row_addrs_case_modified(list_addr,
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (durable_head.view())),
                                summary, addrs, journal),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn delete<PermFactory>(&mut self, list_addr: u64,
                    journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<(), KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                (old(self).view()).tentative.is_some(),
                                (old(self).view()).tentative.unwrap().m.contains_key(list_addr),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<(), KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    ::builtin::spec_eq((journal.view()).remaining_capacity,
                                        (old(journal).view()).remaining_capacity),
                                    match result {
                                        Ok(_) => {
                                            ::builtin::spec_eq((self.view()),
                                                (ListTableView {
                                                        tentative: Some((old(self).view()).tentative.unwrap().delete(list_addr)),
                                                        ..(old(self).view())
                                                    }))
                                        }
                                        Err(KvError::CRCMismatch) => {
                                            (!(journal.view()).pm_constants.impervious_to_corruption())
                                                &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        self.lemma_valid_implications((journal.view()));
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let mut row_addrs =
                        match self.get_row_addrs(list_addr, journal) {
                            Ok(addrs) => addrs,
                            Err(KvError::CRCMismatch) => {
                                self.must_abort =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                                return Err(KvError::CRCMismatch);
                            }
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                        };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = self.internal_view() };
                    #[verus::internal(spec)]
                    let mut old_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_old_iv = verus_tmp;
                        old_iv = verus_tmp_old_iv;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = old_iv.delete(list_addr) };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };
                    let entry =
                        match self.m.remove(&list_addr) {
                            Some(e) => e,
                            None => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                        };
                    match entry {
                        ListTableEntry::Durable { summary } => {
                            self.deletes.push(summary);
                        }
                        ListTableEntry::Modified { which_modification, .. } => {
                            self.modifications.set(which_modification, None);
                        }
                    }
                    self.tentative_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.tentative_mapping);
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.row_info);
                    self.deletes_inverse =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.deletes_inverse);
                    self.pending_deallocations.append(&mut row_addrs);

                    #[verifier::proof_block]
                    {
                        ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                new_iv));
                        old_iv.lemma_delete_works(list_addr, self.sm);
                    }
                    Ok(())
                }
            }
        }
        pub mod impl_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::align_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use deps_hack::PmCopy;
            use std::collections::hash_map::HashMap;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[repr(C)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct ListTableStaticMetadata {
                pub(super) table: TableMetadata,
                pub(super) element_size: u64,
                pub(super) row_next_start: u64,
                pub(super) row_element_start: u64,
                pub(super) row_element_crc_start: u64,
            }
            unsafe impl pmcopy for ListTableStaticMetadata where
                TableMetadata: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy,
                u64: pmcopy {}
            #[verus::internal(verus_macro)]
            impl SpecPmSized for ListTableStaticMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_size_of() -> ::builtin::nat {
                    let offset: ::builtin::nat =
                        ::builtin::spec_literal_integer("0");
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<TableMetadata>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <TableMetadata>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        (offset).spec_add(spec_padding_needed(offset,
                                <ListTableStaticMetadata>::spec_align_of()));
                    offset
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_align_of() -> ::builtin::nat {
                    let alignment_seq =
                        <_ as
                                ::vstd::vstd::view::View>::view(&[<TableMetadata>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of(),
                                        <u64>::spec_align_of(), <u64>::spec_align_of()]);
                    nat_seq_max(alignment_seq)
                }
            }
            unsafe impl PmSized for ListTableStaticMetadata {
                fn size_of() -> usize { Self::SIZE }
                fn align_of() -> usize { Self::ALIGN }
            }
            unsafe impl ConstPmSized for ListTableStaticMetadata {
                const SIZE: usize =
                    {
                        let offset: usize = 0;
                        let offset: usize =
                            offset + <TableMetadata>::SIZE +
                                padding_needed(offset, <TableMetadata>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset +
                                padding_needed(offset, <ListTableStaticMetadata>::ALIGN);
                        offset
                    };
                const ALIGN: usize =
                    {
                        let mut largest_alignment: usize = 0;
                        if largest_alignment <= <TableMetadata>::ALIGN {
                                largest_alignment = <TableMetadata>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        largest_alignment
                    };
            }
            const SIZE_CHECK_LISTTABLESTATICMETADATA: usize =
                (core::mem::size_of::<ListTableStaticMetadata>() ==
                                <ListTableStaticMetadata>::SIZE) as usize - 1;
            const ALIGN_CHECK_LISTTABLESTATICMETADATA: usize =
                (core::mem::align_of::<ListTableStaticMetadata>() ==
                                <ListTableStaticMetadata>::ALIGN) as usize - 1;
            unsafe impl UnsafeSpecPmSized for ListTableStaticMetadata {}
            impl Clone for ListTableStaticMetadata {
                fn clone(&self) -> Self {
                    Self {
                        table: self.table.clone(),
                        element_size: self.element_size.clone(),
                        row_next_start: self.row_next_start.clone(),
                        row_element_start: self.row_element_start.clone(),
                        row_element_crc_start: self.row_element_crc_start.clone(),
                    }
                }
            }
            impl PartialEq for ListTableStaticMetadata {
                fn eq(&self, other: &Self) -> bool {
                    self.table == other.table &&
                                    self.element_size == other.element_size &&
                                self.row_next_start == other.row_next_start &&
                            self.row_element_start == other.row_element_start &&
                        self.row_element_crc_start == other.row_element_crc_start
                }
            }
            impl Eq for ListTableStaticMetadata {}
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_listtablestaticmetadata_clone(b:
                    &ListTableStaticMetadata) -> ListTableStaticMetadata {
                ::builtin::ensures(|res: ListTableStaticMetadata|
                        [::builtin::spec_eq(*b, res)]);
                b.clone()
            }
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_listtablestaticmetadata_eq(lhs:
                    &ListTableStaticMetadata, rhs: &ListTableStaticMetadata)
                -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
                lhs.eq(rhs)
            }
            #[verus::internal(verus_macro)]
            impl CloneProof for ListTableStaticMetadata {
                #[verus::internal(verus_macro)]
                fn clone_provable(&self) -> ListTableStaticMetadata {
                    ::builtin::ensures(|res: ListTableStaticMetadata|
                            [::builtin::spec_eq(*self, res)]);
                    self.clone()
                }
            }
            #[verus::internal(verus_macro)]
            impl EqProof for ListTableStaticMetadata {
                #[verus::internal(verus_macro)]
                fn eq_provable(&self, other: &Self) -> bool {
                    ::builtin::ensures(|b: bool|
                            [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                    self.eq(other)
                }
            }
            impl PmCopy for ListTableStaticMetadata {}
            #[automatically_derived]
            impl ::core::marker::Copy for ListTableStaticMetadata { }
            #[verus::internal(verus_macro)]
            impl ListTableStaticMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn valid<L>(self) -> bool where L: PmCopy {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    (((((::builtin::spec_eq(self.element_size,
                                                                L::spec_size_of())) && (self.table.valid())) &&
                                                ((self.table.start).spec_le(self.table.end))) &&
                                        ((((self.row_next_start).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of())).spec_le(self.row_element_start)))
                                &&
                                (((self.row_element_start).spec_add(self.element_size)).spec_le(self.row_element_crc_start)))
                        &&
                        (((self.row_element_crc_start).spec_add(u64::spec_size_of())).spec_le(self.table.row_size))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_start(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.start
                }
                #[verifier::when_used_as_spec(spec_start)]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn start(self) -> u64 {
                    ::builtin::ensures(|result: u64|
                            [::builtin::spec_eq(result, self.spec_start())]);
                    self.table.start
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_end(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.end
                }
                #[verifier::when_used_as_spec(spec_end)]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn end(self) -> u64 {
                    ::builtin::ensures(|result: u64|
                            [::builtin::spec_eq(result, self.spec_end())]);
                    self.table.end
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn num_rows(self) -> u64 {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.table.num_rows
                }
            }
            #[verifier::ext_equal]
            #[verifier::reject_recursive_types(L)]
            #[verus::internal(verus_macro)]
            pub struct ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                pub(super) status: Ghost<ListTableStatus>,
                pub(super) sm: ListTableStaticMetadata,
                pub(super) must_abort: Ghost<bool>,
                pub(super) logical_range_gaps_policy: LogicalRangeGapsPolicy,
                pub(super) space_needed_to_journal_next: u64,
                pub(super) durable_mapping: Ghost<ListRecoveryMapping<L>>,
                pub(super) tentative_mapping: Ghost<ListRecoveryMapping<L>>,
                pub(super) row_info: Ghost<Map<u64, ListRowDisposition>>,
                pub(super) m: HashMap<u64, ListTableEntry<L>>,
                pub(super) deletes_inverse: Ghost<Map<u64, nat>>,
                pub(super) deletes: Vec<ListSummary>,
                pub(super) modifications: Vec<Option<u64>>,
                pub(super) free_list: Vec<u64>,
                pub(super) pending_allocations: Vec<u64>,
                pub(super) pending_deallocations: Vec<u64>,
                pub(super) phantom_pm: Ghost<core::marker::PhantomData<PM>>,
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn view(&self) -> ListTableView<L> {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    ListTableView::<L> {
                        sm: self.sm,
                        logical_range_gaps_policy: self.logical_range_gaps_policy,
                        used_slots: (self.sm.table.num_rows).spec_sub(self.free_list.len()),
                        durable: (self.durable_mapping.view()).as_snapshot(),
                        tentative: if (self.must_abort.view()) {
                                None
                            } else {
                               Some((self.tentative_mapping.view()).as_snapshot())
                           },
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn valid(self, jv: JournalView) -> bool {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    (::builtin::is_variant((self.status.view()), "Quiescent"))
                        && (self.inv(jv))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn recover(s: Seq<u8>, addrs: Set<u64>,
                    sm: ListTableStaticMetadata)
                    -> Option<ListTableSnapshot<L>> {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    match ListRecoveryMapping::<L>::new(s, addrs, sm) {
                        None => None,
                        Some(mapping) => Some(mapping.as_snapshot()),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn spec_space_needed_for_setup(ps: SetupParameters,
                    min_start: nat) -> nat {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    ::builtin::recommends([ps.valid()]);
                    let row_element_start =
                        (u64::spec_size_of()).spec_add(u64::spec_size_of());
                    let row_element_crc_start =
                        (row_element_start).spec_add(L::spec_size_of());
                    let row_size =
                        (row_element_crc_start).spec_add(u64::spec_size_of());
                    let num_rows = ps.max_list_elements;
                    let table_size =
                        (::builtin::spec_cast_integer::<_,
                                        int>(num_rows)).spec_mul(row_size);
                    let initial_space =
                        if (min_start).spec_gt(u64::MAX) {
                                ::builtin::spec_literal_integer("0")
                            } else {
                               space_needed_for_alignment(::builtin::spec_cast_integer::<_,
                                           int>(min_start),
                                   ::builtin::spec_cast_integer::<_, int>(u64::spec_size_of()))
                           };
                    ::builtin::spec_cast_integer::<_,
                            nat>(((initial_space).spec_add(table_size)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn validate_list_addr(&self, addr: u64) -> bool {
                    #[verus::internal(open_visibility_qualifier)]
                    pub(super) use crate as _;
                    self.sm.table.validate_row_addr(addr)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn state_equivalent_for_me(s: Seq<u8>,
                    durable_state: Seq<u8>, list_addrs: Set<u64>,
                    constants: JournalConstants, sm: ListTableStaticMetadata)
                    -> bool {
                    ((seqs_match_except_in_range(durable_state, s,
                                        ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                        ::builtin::spec_cast_integer::<_, int>(sm.end()))) &&
                                (Journal::<PM>::state_recovery_idempotent(s, constants))) &&
                        (::builtin::spec_eq(Self::recover(s, list_addrs, sm),
                                Self::recover(durable_state, list_addrs, sm)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn perm_factory_permits_states_equivalent_for_me<PermFactory>(&self,
                    jv: JournalView, perm_factory: PermFactory) -> bool where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                            ::builtin::imply({
                                    (Self::state_equivalent_for_me(s1, jv.durable_state,
                                                (self.view()).durable.m.dom(), jv.constants,
                                                (self.view()).sm)) &&
                                        (Self::state_equivalent_for_me(s2, jv.durable_state,
                                                (self.view()).durable.m.dom(), jv.constants,
                                                (self.view()).sm))
                                },
                                #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                    s2)))
                }
            }
        }
        pub mod inv_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use deps_hack::PmCopy;
            use super::impl_v::*;
            use super::recover_v::*;
            use super::super::spec_t::*;
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ListTableStatus { Quiescent, PoppedEntry, }
            #[verifier::ext_equal]
            #[repr(C)]
            #[verus::internal(verus_macro)]
            pub(super) struct ListSummary {
                pub head: u64,
                pub tail: u64,
                pub length: usize,
                pub end_of_logical_range: usize,
            }
            unsafe impl pmcopy for ListSummary where u64: pmcopy, u64: pmcopy,
                usize: pmcopy, usize: pmcopy {}
            #[verus::internal(verus_macro)]
            impl SpecPmSized for ListSummary {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_size_of() -> ::builtin::nat {
                    let offset: ::builtin::nat =
                        ::builtin::spec_literal_integer("0");
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <u64>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<usize>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <usize>::spec_align_of()));
                    let offset: ::builtin::nat =
                        ((offset).spec_add(<usize>::spec_size_of())).spec_add(spec_padding_needed(offset,
                                <usize>::spec_align_of()));
                    let offset: ::builtin::nat =
                        (offset).spec_add(spec_padding_needed(offset,
                                <ListSummary>::spec_align_of()));
                    offset
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                fn spec_align_of() -> ::builtin::nat {
                    let alignment_seq =
                        <_ as
                                ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of(),
                                        <u64>::spec_align_of(), <usize>::spec_align_of(),
                                        <usize>::spec_align_of()]);
                    nat_seq_max(alignment_seq)
                }
            }
            unsafe impl PmSized for ListSummary {
                fn size_of() -> usize { Self::SIZE }
                fn align_of() -> usize { Self::ALIGN }
            }
            unsafe impl ConstPmSized for ListSummary {
                const SIZE: usize =
                    {
                        let offset: usize = 0;
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                        let offset: usize =
                            offset + <usize>::SIZE +
                                padding_needed(offset, <usize>::ALIGN);
                        let offset: usize =
                            offset + <usize>::SIZE +
                                padding_needed(offset, <usize>::ALIGN);
                        let offset: usize =
                            offset + padding_needed(offset, <ListSummary>::ALIGN);
                        offset
                    };
                const ALIGN: usize =
                    {
                        let mut largest_alignment: usize = 0;
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <u64>::ALIGN {
                                largest_alignment = <u64>::ALIGN;
                            }
                        if largest_alignment <= <usize>::ALIGN {
                                largest_alignment = <usize>::ALIGN;
                            }
                        if largest_alignment <= <usize>::ALIGN {
                                largest_alignment = <usize>::ALIGN;
                            }
                        largest_alignment
                    };
            }
            const SIZE_CHECK_LISTSUMMARY: usize =
                (core::mem::size_of::<ListSummary>() == <ListSummary>::SIZE)
                        as usize - 1;
            const ALIGN_CHECK_LISTSUMMARY: usize =
                (core::mem::align_of::<ListSummary>() == <ListSummary>::ALIGN)
                        as usize - 1;
            unsafe impl UnsafeSpecPmSized for ListSummary {}
            impl Clone for ListSummary {
                fn clone(&self) -> Self {
                    Self {
                        head: self.head.clone(),
                        tail: self.tail.clone(),
                        length: self.length.clone(),
                        end_of_logical_range: self.end_of_logical_range.clone(),
                    }
                }
            }
            impl PartialEq for ListSummary {
                fn eq(&self, other: &Self) -> bool {
                    self.head == other.head && self.tail == other.tail &&
                            self.length == other.length &&
                        self.end_of_logical_range == other.end_of_logical_range
                }
            }
            impl Eq for ListSummary {}
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_listsummary_clone(b: &ListSummary) -> ListSummary {
                ::builtin::ensures(|res: ListSummary|
                        [::builtin::spec_eq(*b, res)]);
                b.clone()
            }
            #[verifier::external_fn_specification]
            #[verus::internal(verus_macro)]
            pub fn ex_listsummary_eq(lhs: &ListSummary, rhs: &ListSummary)
                -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
                lhs.eq(rhs)
            }
            #[verus::internal(verus_macro)]
            impl CloneProof for ListSummary {
                #[verus::internal(verus_macro)]
                fn clone_provable(&self) -> ListSummary {
                    ::builtin::ensures(|res: ListSummary|
                            [::builtin::spec_eq(*self, res)]);
                    self.clone()
                }
            }
            #[verus::internal(verus_macro)]
            impl EqProof for ListSummary {
                #[verus::internal(verus_macro)]
                fn eq_provable(&self, other: &Self) -> bool {
                    ::builtin::ensures(|b: bool|
                            [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                    self.eq(other)
                }
            }
            impl PmCopy for ListSummary {}
            #[automatically_derived]
            impl ::core::marker::Copy for ListSummary { }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ListTableEntryView<L> where L: PmCopy +
                LogicalRange + Sized + std::fmt::Debug {
                Durable {
                    summary: ListSummary,
                },
                Modified {
                    which_modification: nat,
                    durable_head: u64,
                    summary: ListSummary,
                    addrs: Seq<u64>,
                    elements: Seq<L>,
                },
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntryView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_addrs(self) -> Seq<u64> {
                    ::builtin::get_variant_field(self, "Modified", "addrs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_elements(self) -> Seq<L> {
                    ::builtin::get_variant_field(self, "Modified", "elements")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_which_modification(self) -> nat {
                    ::builtin::get_variant_field(self, "Modified",
                        "which_modification")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_summary(self) -> ListSummary {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_durable_head(self) -> u64 {
                    ::builtin::get_variant_field(self, "Modified",
                        "durable_head")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Durable_summary(self) -> ListSummary {
                    ::builtin::get_variant_field(self, "Durable", "summary")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_which_modification(self) -> nat {
                    ::builtin::get_variant_field(self, "Modified",
                        "which_modification")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_durable_head(self) -> u64 {
                    ::builtin::get_variant_field(self, "Modified",
                        "durable_head")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_summary(self) -> ListSummary {
                    ::builtin::get_variant_field(self, "Modified", "summary")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_addrs(self) -> Seq<u64> {
                    ::builtin::get_variant_field(self, "Modified", "addrs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_elements(self) -> Seq<L> {
                    ::builtin::get_variant_field(self, "Modified", "elements")
                }
            }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ListTableEntry<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                Durable {
                    summary: ListSummary,
                },
                Modified {
                    which_modification: usize,
                    durable_head: Ghost<u64>,
                    summary: ListSummary,
                    addrs: Vec<u64>,
                    elements: Vec<L>,
                },
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntry<L> where L: PmCopy + LogicalRange + Sized +
                std::fmt::Debug {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_which_modification(self) -> usize {
                    ::builtin::get_variant_field(self, "Modified",
                        "which_modification")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_durable_head(self) -> Ghost<u64> {
                    ::builtin::get_variant_field(self, "Modified",
                        "durable_head")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_addrs(self) -> Vec<u64> {
                    ::builtin::get_variant_field(self, "Modified", "addrs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_elements(self) -> Vec<L> {
                    ::builtin::get_variant_field(self, "Modified", "elements")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_summary(self) -> ListSummary {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Durable_summary(self) -> ListSummary {
                    ::builtin::get_variant_field(self, "Durable", "summary")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_which_modification(self)
                    -> usize {
                    ::builtin::get_variant_field(self, "Modified",
                        "which_modification")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_durable_head(self)
                    -> Ghost<u64> {
                    ::builtin::get_variant_field(self, "Modified",
                        "durable_head")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_summary(self) -> ListSummary {
                    ::builtin::get_variant_field(self, "Modified", "summary")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_addrs(self) -> Vec<u64> {
                    ::builtin::get_variant_field(self, "Modified", "addrs")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_Modified_elements(self) -> Vec<L> {
                    ::builtin::get_variant_field(self, "Modified", "elements")
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntry<L> where L: PmCopy + LogicalRange + Sized +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn view(self) -> ListTableEntryView<L> {
                    match self {
                        ListTableEntry::Durable { summary } =>
                            ListTableEntryView::Durable { summary },
                        ListTableEntry::Modified {
                            which_modification, durable_head, summary, addrs, elements }
                            =>
                            ListTableEntryView::Modified {
                                which_modification: ::builtin::spec_cast_integer::<_,
                                        nat>(which_modification),
                                durable_head: (durable_head.view()),
                                summary,
                                addrs: (addrs.view()),
                                elements: (elements.view()),
                            },
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntryView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn commit(self) -> Self {
                    match self {
                        ListTableEntryView::Durable { summary } =>
                            ListTableEntryView::Durable { summary },
                        ListTableEntryView::Modified { summary, .. } =>
                            ListTableEntryView::Durable { summary },
                    }
                }
            }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) enum ListRowDisposition {
                NowhereFree,
                InFreeList {
                    pos: nat,
                },
                InPendingDeallocationList {
                    pos: nat,
                },
                InPendingAllocationList {
                    pos: nat,
                },
                InBothPendingLists {
                    alloc_pos: nat,
                    dealloc_pos: nat,
                },
            }
            #[verus::internal(verus_macro)]
            impl ListRowDisposition {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                #[verus::internal(open)]
                pub(super) fn arrow_pos(self) -> nat {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_alloc_pos(self) -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "alloc_pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_dealloc_pos(self) -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "dealloc_pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InFreeList_pos(self) -> nat {
                    ::builtin::get_variant_field(self, "InFreeList", "pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InPendingDeallocationList_pos(self)
                    -> nat {
                    ::builtin::get_variant_field(self,
                        "InPendingDeallocationList", "pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InPendingAllocationList_pos(self) -> nat {
                    ::builtin::get_variant_field(self,
                        "InPendingAllocationList", "pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InBothPendingLists_alloc_pos(self)
                    -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "alloc_pos")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                #[verus::internal(open)]
                pub(super) fn arrow_InBothPendingLists_dealloc_pos(self)
                    -> nat {
                    ::builtin::get_variant_field(self, "InBothPendingLists",
                        "dealloc_pos")
                }
            }
            #[verus::internal(verus_macro)]
            impl ListTableStaticMetadata {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn corresponds_to_journal(self, jv: JournalView)
                    -> bool {
                    ((jv.constants.app_area_start).spec_le(self.start())) &&
                        ((self.end()).spec_le(jv.constants.app_area_end))
                }
            }
            #[verifier::ext_equal]
            #[verifier::reject_recursive_types(L)]
            #[verus::internal(verus_macro)]
            pub(super) struct ListTableInternalView<L> where L: PmCopy +
                LogicalRange + Sized + std::fmt::Debug {
                pub status: ListTableStatus,
                pub durable_mapping: ListRecoveryMapping<L>,
                pub tentative_mapping: ListRecoveryMapping<L>,
                pub row_info: Map<u64, ListRowDisposition>,
                pub m: Map<u64, ListTableEntryView<L>>,
                pub deletes_inverse: Map<u64, nat>,
                pub deletes: Seq<ListSummary>,
                pub modifications: Seq<Option<u64>>,
                pub free_list: Seq<u64>,
                pub pending_allocations: Seq<u64>,
                pub pending_deallocations: Seq<u64>,
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn valid(self, sm: ListTableStaticMetadata)
                    -> bool {
                    ((((((((((self.durable_mapping.internally_consistent(sm)) &&
                                                                                                (self.tentative_mapping.internally_consistent(sm))) &&
                                                                                        (self.durable_mapping_reflected_in_changes_or_m())) &&
                                                                                (self.modifications_reflected_in_m())) &&
                                                                        (::builtin::forall(|list_addr: u64|
                                                                                    ::builtin::imply(#[verus::internal(trigger)] self.tentative_mapping.list_info.contains_key(list_addr),
                                                                                        self.m.contains_key(list_addr))))) &&
                                                                (self.m_consistent_with_recovery_mappings())) &&
                                                        (self.deletes_arent_durable_in_m())) &&
                                                (self.deletes_consistent_with_durable_recovery_mapping()))
                                        && (self.deletes_inverse_is_inverse_of_deletes())) &&
                                (self.row_info_complete(sm))) &&
                        (self.per_row_info_consistent(sm))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn corresponds_to_journal(self, jv: JournalView,
                    sm: ListTableStaticMetadata) -> bool {
                    ((((self.valid(sm)) &&
                                                (self.corresponds_to_durable_state(jv.durable_state, sm)))
                                        && (self.corresponds_to_durable_state(jv.read_state, sm)))
                                &&
                                (self.corresponds_to_tentative_state(jv.commit_state, sm)))
                        &&
                        (self.consistent_with_journaled_addrs(jv.journaled_addrs,
                                sm))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn durable_mapping_reflected_in_changes_or_m(self)
                    -> bool {
                    ::builtin::forall(|list_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.durable_mapping.list_info.contains_key(list_addr),
                                {
                                    if self.deletes_inverse.contains_key(list_addr) {
                                            let which_delete =
                                                self.deletes_inverse.spec_index(list_addr);
                                            ((which_delete).spec_lt(self.deletes.len())) &&
                                                (::builtin::spec_eq(self.deletes.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(which_delete)).head, list_addr))
                                        } else {
                                           (self.m.contains_key(list_addr)) &&
                                               (::builtin::is_variant(self.m.spec_index(list_addr),
                                                       "Durable"))
                                       }
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn modifications_reflected_in_m(self) -> bool {
                    ::builtin::forall(|which_modification: int|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            which_modification), self.modifications.len())),
                                (((if let Some(tentative_list_addr) =
                                                        (#[verus::internal(trigger)] self.modifications.spec_index(which_modification))
                                                    {
                                                    {
                                                        (self.m.contains_key(tentative_list_addr)) &&
                                                            (match self.m.spec_index(tentative_list_addr) {
                                                                    ListTableEntryView::Modified { which_modification: wm, .. }
                                                                        => ::builtin::spec_eq(which_modification, wm),
                                                                    _ => false,
                                                                })
                                                    }
                                                } else { true })))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn m_consistent_with_recovery_mappings(self)
                    -> bool {
                    ::builtin::forall(|list_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.m.contains_key(list_addr),
                                match self.m.spec_index(list_addr) {
                                    ListTableEntryView::Durable { summary } => {
                                        let durable_addrs =
                                            self.durable_mapping.list_info.spec_index(list_addr);
                                        let durable_elements =
                                            self.durable_mapping.list_elements.spec_index(list_addr);
                                        let tentative_addrs =
                                            self.tentative_mapping.list_info.spec_index(list_addr);
                                        let tentative_elements =
                                            self.tentative_mapping.list_elements.spec_index(list_addr);
                                        (((((((((((::builtin::spec_eq(durable_addrs,
                                                                                                                                    tentative_addrs)) &&
                                                                                                                            (::builtin::spec_eq(durable_elements, tentative_elements)))
                                                                                                                    &&
                                                                                                                    ((::builtin::spec_literal_nat("0")).spec_lt(tentative_addrs.len())))
                                                                                                            && (self.durable_mapping.list_info.contains_key(list_addr)))
                                                                                                    &&
                                                                                                    (self.durable_mapping.row_info.contains_key(durable_addrs.last())))
                                                                                            &&
                                                                                            (self.tentative_mapping.list_info.contains_key(list_addr)))
                                                                                    &&
                                                                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_eq(::builtin::spec_chained_eq(::builtin::spec_chained_value(summary.head),
                                                                                                    list_addr),
                                                                                                tentative_addrs.spec_index(::builtin::spec_literal_integer("0"))))))
                                                                            &&
                                                                            (::builtin::spec_eq(summary.tail, tentative_addrs.last())))
                                                                    &&
                                                                    (::builtin::spec_eq(summary.length, tentative_addrs.len())))
                                                            &&
                                                            (::builtin::spec_eq(summary.end_of_logical_range,
                                                                    end_of_range(tentative_elements)))) &&
                                                    (::builtin::spec_eq(tentative_addrs.len(),
                                                            tentative_elements.len()))) &&
                                            ((tentative_addrs.len()).spec_le(usize::MAX))
                                    }
                                    ListTableEntryView::Modified {
                                        which_modification, durable_head, summary, addrs, elements }
                                        => {
                                        let tentative_addrs =
                                            self.tentative_mapping.list_info.spec_index(list_addr);
                                        let tentative_elements =
                                            self.tentative_mapping.list_elements.spec_index(list_addr);
                                        ((((((((((((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                                    which_modification), self.modifications.len()))) &&
                                                                                                                                    (::builtin::spec_eq(self.modifications.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                                                                        int>(which_modification)), Some(list_addr)))) &&
                                                                                                                            (self.tentative_mapping.list_info.contains_key(list_addr)))
                                                                                                                    && (::builtin::spec_eq(summary.head, list_addr))) &&
                                                                                                            ((::builtin::spec_literal_nat("0")).spec_lt(tentative_addrs.len())))
                                                                                                    &&
                                                                                                    (::builtin::spec_eq(summary.head,
                                                                                                            tentative_addrs.spec_index(::builtin::spec_literal_integer("0")))))
                                                                                            &&
                                                                                            (::builtin::spec_eq(summary.tail, tentative_addrs.last())))
                                                                                    &&
                                                                                    (::builtin::spec_eq(summary.length, tentative_addrs.len())))
                                                                            &&
                                                                            (::builtin::spec_eq(tentative_addrs.len(),
                                                                                    tentative_elements.len()))) &&
                                                                    ((tentative_addrs.len()).spec_le(usize::MAX))) &&
                                                            (::builtin::spec_eq(summary.end_of_logical_range,
                                                                    end_of_range(tentative_elements)))) &&
                                                    (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                            (if ::builtin::spec_eq(addrs.len(), summary.length) {
                                                        ((::builtin::spec_eq(durable_head,
                                                                            ::builtin::spec_literal_nat("0"))) &&
                                                                    (::builtin::spec_eq(tentative_addrs, addrs))) &&
                                                            (::builtin::spec_eq(tentative_elements, elements))
                                                    } else {
                                                       let durable_addrs =
                                                           self.durable_mapping.list_info.spec_index(durable_head);
                                                       let durable_elements =
                                                           self.durable_mapping.list_elements.spec_index(durable_head);
                                                       (((((((self.durable_mapping.list_info.contains_key(durable_head))
                                                                                                           &&
                                                                                                           ((::builtin::spec_literal_nat("0")).spec_lt(durable_addrs.len())))
                                                                                                   && ((addrs.len()).spec_lt(summary.length))) &&
                                                                                           (((summary.length).spec_sub(addrs.len())).spec_le(durable_addrs.len())))
                                                                                   &&
                                                                                   (::builtin::spec_eq(durable_addrs.len(),
                                                                                           durable_elements.len()))) &&
                                                                           (::builtin::spec_eq(tentative_addrs,
                                                                                   (durable_addrs.skip((durable_addrs.len()).spec_sub(((summary.length).spec_sub(addrs.len()))))).spec_add(addrs))))
                                                                   &&
                                                                   (::builtin::spec_eq(tentative_elements,
                                                                           (durable_elements.skip((durable_elements.len()).spec_sub(((summary.length).spec_sub(elements.len()))))).spec_add(elements))))
                                                           && (::builtin::spec_eq(addrs.len(), elements.len()))
                                                   })
                                    }
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn deletes_arent_durable_in_m(self) -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::with_triggers(((self.deletes.spec_index(i),),),
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), self.deletes.len())),
                                    {
                                        let summary = self.deletes.spec_index(i);
                                        let list_addr = summary.head;
                                        ::builtin::imply(self.m.contains_key(list_addr),
                                            !(::builtin::is_variant(self.m.spec_index(list_addr),
                                                        "Durable")))
                                    })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn deletes_consistent_with_durable_recovery_mapping(self)
                    -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::with_triggers(((self.deletes.spec_index(i),),),
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), self.deletes.len())),
                                    {
                                        let summary = self.deletes.spec_index(i);
                                        let list_addr = summary.head;
                                        let addrs =
                                            self.durable_mapping.list_info.spec_index(list_addr);
                                        let elements =
                                            self.durable_mapping.list_elements.spec_index(list_addr);
                                        ((((((((((::builtin::spec_eq(summary.head,
                                                                                                                            addrs.spec_index(::builtin::spec_literal_integer("0")))) &&
                                                                                                                    (::builtin::spec_eq(summary.tail, addrs.last()))) &&
                                                                                                            (::builtin::spec_eq(summary.length, addrs.len()))) &&
                                                                                                    (::builtin::spec_eq(summary.end_of_logical_range,
                                                                                                            end_of_range(elements)))) &&
                                                                                            (self.deletes_inverse.contains_key(list_addr))) &&
                                                                                    (::builtin::spec_eq(self.deletes_inverse.spec_index(list_addr),
                                                                                            i))) &&
                                                                            ((::builtin::spec_literal_nat("0")).spec_lt(addrs.len())))
                                                                    && (self.durable_mapping.list_info.contains_key(list_addr)))
                                                            &&
                                                            (self.durable_mapping.row_info.contains_key(addrs.last())))
                                                    && (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                            ((addrs.len()).spec_le(usize::MAX))
                                    })))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn deletes_inverse_is_inverse_of_deletes(self)
                    -> bool {
                    ::builtin::forall(|list_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.deletes_inverse.contains_key(list_addr),
                                {
                                    let which_delete =
                                        self.deletes_inverse.spec_index(list_addr);
                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        which_delete), self.deletes.len()))) &&
                                        (::builtin::spec_eq(self.deletes.spec_index(::builtin::spec_cast_integer::<_,
                                                                int>(which_delete)).head, list_addr))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn corresponds_to_durable_state(self, s: Seq<u8>,
                    sm: ListTableStaticMetadata) -> bool {
                    self.durable_mapping.corresponds(s,
                        self.durable_mapping.list_elements.dom(), sm)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn corresponds_to_tentative_state(self, s: Seq<u8>,
                    sm: ListTableStaticMetadata) -> bool {
                    self.tentative_mapping.corresponds(s,
                        self.tentative_mapping.list_elements.dom(), sm)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn consistent_with_journaled_addrs(self,
                    journaled_addrs: Set<int>, sm: ListTableStaticMetadata)
                    -> bool {
                    ::builtin::forall(|i: int, addr: int|
                            ::builtin::with_triggers(((self.free_list.spec_index(i),
                                        journaled_addrs.contains(addr)),),
                                ::builtin::imply({
                                        let row_addr = self.free_list.spec_index(i);
                                        (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), self.free_list.len()))) &&
                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                            addr), (row_addr).spec_add(sm.table.row_size))))
                                    }, !journaled_addrs.contains(addr))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn row_info_complete(self,
                    sm: ListTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] sm.table.validate_row_addr(row_addr),
                                self.row_info.contains_key(row_addr)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn row_info_consistent(self,
                    sm: ListTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                {
                                    (sm.table.validate_row_addr(row_addr)) &&
                                        (match self.row_info.spec_index(row_addr) {
                                                ListRowDisposition::NowhereFree => {
                                                    (self.durable_mapping.row_info.contains_key(row_addr)) &&
                                                        (self.tentative_mapping.row_info.contains_key(row_addr))
                                                }
                                                ListRowDisposition::InFreeList { pos } => {
                                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                        pos), self.free_list.len()))) &&
                                                                        (::builtin::spec_eq(self.free_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                                            int>(pos)), row_addr))) &&
                                                                (!self.durable_mapping.row_info.contains_key(row_addr))) &&
                                                        (!self.tentative_mapping.row_info.contains_key(row_addr))
                                                }
                                                ListRowDisposition::InPendingAllocationList { pos } => {
                                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                        pos), self.pending_allocations.len()))) &&
                                                                        (::builtin::spec_eq(self.pending_allocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                                            int>(pos)), row_addr))) &&
                                                                (!self.durable_mapping.row_info.contains_key(row_addr))) &&
                                                        (self.tentative_mapping.row_info.contains_key(row_addr))
                                                }
                                                ListRowDisposition::InPendingDeallocationList { pos } => {
                                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                        pos), self.pending_deallocations.len()))) &&
                                                                        (::builtin::spec_eq(self.pending_deallocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                                            int>(pos)), row_addr))) &&
                                                                (self.durable_mapping.row_info.contains_key(row_addr))) &&
                                                        (!self.tentative_mapping.row_info.contains_key(row_addr))
                                                }
                                                ListRowDisposition::InBothPendingLists {
                                                    alloc_pos, dealloc_pos } => {
                                                    (((((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                        alloc_pos), self.pending_allocations.len()))) &&
                                                                                        (::builtin::spec_eq(self.pending_allocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                            int>(alloc_pos)), row_addr))) &&
                                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                dealloc_pos), self.pending_deallocations.len())))) &&
                                                                        (::builtin::spec_eq(self.pending_deallocations.spec_index(::builtin::spec_cast_integer::<_,
                                                                                            int>(dealloc_pos)), row_addr))) &&
                                                                (!self.durable_mapping.row_info.contains_key(row_addr))) &&
                                                        (!self.tentative_mapping.row_info.contains_key(row_addr))
                                                }
                                            })
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn free_list_consistent(self,
                    sm: ListTableStaticMetadata) -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.free_list.len())),
                                {
                                    (self.row_info.contains_key(#[verus::internal(trigger)] self.free_list.spec_index(i)))
                                        &&
                                        (((if let ListRowDisposition::InFreeList { pos } =
                                                                (self.row_info.spec_index(self.free_list.spec_index(i))) {
                                                            ::builtin::spec_eq(pos, i)
                                                        } else { false })))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn pending_allocations_consistent(self,
                    sm: ListTableStaticMetadata) -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.pending_allocations.len())),
                                {
                                    (self.row_info.contains_key(#[verus::internal(trigger)] self.pending_allocations.spec_index(i)))
                                        &&
                                        (match self.row_info.spec_index(self.pending_allocations.spec_index(i))
                                                {
                                                ListRowDisposition::InPendingAllocationList { pos } =>
                                                    ::builtin::spec_eq(pos, i),
                                                ListRowDisposition::InBothPendingLists {
                                                    alloc_pos, dealloc_pos } =>
                                                    ::builtin::spec_eq(alloc_pos, i),
                                                _ => false,
                                            })
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn pending_deallocations_consistent(self,
                    sm: ListTableStaticMetadata) -> bool {
                    ::builtin::forall(|i: int|
                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), self.pending_deallocations.len())),
                                {
                                    (self.row_info.contains_key(#[verus::internal(trigger)] self.pending_deallocations.spec_index(i)))
                                        &&
                                        (match self.row_info.spec_index(self.pending_deallocations.spec_index(i))
                                                {
                                                ListRowDisposition::InPendingDeallocationList { pos } =>
                                                    ::builtin::spec_eq(pos, i),
                                                ListRowDisposition::InBothPendingLists {
                                                    alloc_pos, dealloc_pos } =>
                                                    ::builtin::spec_eq(dealloc_pos, i),
                                                _ => false,
                                            })
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn per_row_info_consistent(self,
                    sm: ListTableStaticMetadata) -> bool {
                    (((self.row_info_consistent(sm)) &&
                                        (self.free_list_consistent(sm))) &&
                                (self.pending_allocations_consistent(sm))) &&
                        (self.pending_deallocations_consistent(sm))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn add_entry(self, list_addr: u64,
                    entry: ListTableEntryView<L>) -> Self {
                    Self { m: self.m.insert(list_addr, entry), ..self }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn push_to_free_list(self, row_addr: u64) -> Self {
                    Self { free_list: self.free_list.push(row_addr), ..self }
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn inv(self, jv: JournalView) -> bool {
                    ((((self.sm.valid::<L>()) &&
                                                ((::builtin::spec_literal_nat("0")).spec_lt(self.sm.start())))
                                        && (self.sm.corresponds_to_journal(jv))) &&
                                (::builtin::spec_eq(self.space_needed_to_journal_next,
                                        ((spec_journal_entry_overhead()).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of()))))
                        &&
                        (::builtin::imply(::builtin::is_variant((self.status.view()),
                                    "Quiescent"),
                                self.internal_view().corresponds_to_journal(jv, self.sm)))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn internal_view(self)
                    -> ListTableInternalView<L> {
                    ListTableInternalView {
                        status: (self.status.view()),
                        durable_mapping: (self.durable_mapping.view()),
                        tentative_mapping: (self.tentative_mapping.view()),
                        row_info: (self.row_info.view()),
                        m: (self.m.view()).map_values(::builtin::closure_to_fn_spec(|e:
                                        ListTableEntry<L>| (e.view()))),
                        deletes_inverse: (self.deletes_inverse.view()),
                        deletes: (self.deletes.view()),
                        modifications: (self.modifications.view()),
                        free_list: (self.free_list.view()),
                        pending_allocations: (self.pending_allocations.view()),
                        pending_deallocations: (self.pending_deallocations.view()),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_valid_implications(self, jv: JournalView) {
                    ::builtin::requires([self.valid(jv)]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(jv.durable_state,
                                        (self.view()).durable.m.dom(), (self.view()).sm),
                                    Some((self.view()).durable)),
                                ::builtin::imply(::builtin::is_variant((self.view()).tentative,
                                        "Some"),
                                    ::builtin::spec_eq(Self::recover(jv.commit_state,
                                            (self.view()).tentative.unwrap().m.dom(), (self.view()).sm),
                                        (self.view()).tentative))]);
                    (self.durable_mapping.view()).lemma_corresponds_implies_equals_new(jv.durable_state,
                        (self.view()).durable.m.dom(), (self.view()).sm);
                    if !(self.must_abort.view()) {
                            (self.tentative_mapping.view()).lemma_corresponds_implies_equals_new(jv.commit_state,
                                (self.view()).tentative.unwrap().m.dom(), (self.view()).sm);
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_valid_depends_only_on_my_area(&self,
                    old_jv: JournalView, new_jv: JournalView) {
                    ::builtin::requires([self.valid(old_jv),
                                old_jv.matches_in_range(new_jv,
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.end())),
                                ::builtin::spec_eq(old_jv.constants, new_jv.constants)]);
                    ::builtin::ensures([self.valid(new_jv)]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(self.valid(new_jv));
                }
            }
        }
        pub mod read_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_elements_case_durable(&self, list_addr: u64,
                    summary: &ListSummary, journal: &Journal<PM>)
                    -> Result<Vec<L>, KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                    "Durable"),
                                ::builtin::spec_eq(summary,
                                    ((self.m.view()).spec_index(list_addr).arrow_Durable_summary()))]);
                    ::builtin::ensures(|result: Result<Vec<L>, KvError>|
                            [match result {
                                        Ok(elements) =>
                                            ::builtin::spec_eq((elements.view()),
                                                (self.tentative_mapping.view()).list_elements.spec_index(list_addr)),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    let mut current_addr = list_addr;
                    let mut result = Vec::<L>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = ::builtin::spec_literal_integer("0") };
                    #[verus::internal(spec)]
                    let mut current_pos;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_current_pos: int = verus_tmp;
                        current_pos = verus_tmp_current_pos;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_addrs = verus_tmp;
                        addrs = verus_tmp_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_elements.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut elements;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_elements = verus_tmp;
                        elements = verus_tmp_elements;
                    };
                    let pm = journal.get_pm_region_ref();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(elements.take(current_pos),
                                        Seq::<L>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    while current_addr != 0 {
                        ::builtin::invariant([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                current_pos), addrs.len())),
                                    (::builtin::spec_eq(current_pos, addrs.len())) ==
                                        (::builtin::spec_eq(current_addr,
                                                ::builtin::spec_literal_nat("0"))),
                                    ::builtin::spec_eq(addrs.len(), elements.len()),
                                    ::builtin::imply((current_pos).spec_lt(addrs.len()),
                                        ::builtin::spec_eq(current_addr,
                                            addrs.spec_index(current_pos))),
                                    ::builtin::spec_eq((result.view()),
                                        elements.take(current_pos)), self.valid((journal.view())),
                                    journal.valid(),
                                    (self.durable_mapping.view()).list_info.contains_key(list_addr),
                                    ::builtin::spec_eq(addrs,
                                        (self.durable_mapping.view()).list_info.spec_index(list_addr)),
                                    ::builtin::spec_eq(elements,
                                        (self.durable_mapping.view()).list_elements.spec_index(list_addr)),
                                    pm.inv(),
                                    ::builtin::spec_eq((pm.view()).read_state,
                                        (journal.view()).read_state),
                                    ::builtin::spec_eq(pm.constants(),
                                        (journal.view()).pm_constants)]);
                        ::builtin::decreases(((addrs.len()).spec_sub((result.view()).len()),));

                        #[verifier::proof_block]
                        {
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                        }

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal(elements.take(current_pos).push(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(current_pos))),
                                            elements.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                };
                        };
                        let element_addr = current_addr + self.sm.row_element_start;
                        let element_crc_addr =
                            current_addr + self.sm.row_element_crc_start;
                        let current_element =
                            match exec_recover_object::<PM,
                                        L>(pm, element_addr, element_crc_addr) {
                                Some(e) => e,
                                None => { return Err(KvError::CRCMismatch); }
                            };
                        result.push(current_element);
                        let next_addr = current_addr + self.sm.row_next_start;
                        let next_crc_addr = next_addr + size_of::<u64>() as u64;
                        current_addr =
                            match exec_recover_object::<PM,
                                        u64>(pm, next_addr, next_crc_addr) {
                                Some(n) => n,
                                None => { return Err(KvError::CRCMismatch); }
                            };

                        #[verifier::proof_block]
                        {
                            current_pos =
                                (current_pos).spec_add(::builtin::spec_literal_nat("1"));
                        }
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(elements.take(current_pos),
                                        elements))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((self.tentative_mapping.view()).list_elements.spec_index(list_addr),
                                        (self.durable_mapping.view()).list_elements.spec_index(list_addr)))
                            };
                    };
                    Ok(result)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_elements_case_modified(&self, list_addr: u64,
                    verus_tmp_durable_head: Ghost<u64>, summary: &ListSummary,
                    elements: &Vec<L>, journal: &Journal<PM>)
                    -> Result<Vec<L>, KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let durable_head;

                    #[verifier::proof_block]
                    { durable_head = verus_tmp_durable_head.view() };
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                    "Modified"),
                                ::builtin::spec_eq(durable_head,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_durable_head())),
                                ::builtin::spec_eq(summary,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_summary())),
                                ::builtin::spec_eq(elements,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_elements()))]);
                    ::builtin::ensures(|result: Result<Vec<L>, KvError>|
                            [match result {
                                        Ok(elements) =>
                                            ::builtin::spec_eq((elements.view()),
                                                (self.tentative_mapping.view()).list_elements.spec_index(list_addr)),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    if summary.length == elements.len() {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::spec_eq((elements.view()),
                                                (self.tentative_mapping.view()).list_elements.spec_index(list_addr)))
                                    };
                            };
                            return Ok(clone_pmcopy_vec(&elements));
                        }
                    let mut current_addr = list_addr;
                    let mut result = Vec::<L>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_info.spec_index(durable_head)
                    };
                    #[verus::internal(spec)]
                    let mut durable_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_addrs = verus_tmp;
                        durable_addrs = verus_tmp_durable_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_elements.spec_index(durable_head)
                    };
                    #[verus::internal(spec)]
                    let mut durable_elements;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_elements = verus_tmp;
                        durable_elements = verus_tmp_durable_elements;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.tentative_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut tentative_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_tentative_addrs = verus_tmp;
                        tentative_addrs = verus_tmp_tentative_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.tentative_mapping.view()).list_elements.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut tentative_elements;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_tentative_elements = verus_tmp;
                        tentative_elements = verus_tmp_tentative_elements;
                    };
                    let pm = journal.get_pm_region_ref();
                    let num_durable_addrs = summary.length - elements.len();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_elements.take(::builtin::spec_literal_integer("0")),
                                        Seq::<L>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                    int>(num_durable_addrs)),
                                        durable_addrs.skip((durable_addrs.len()).spec_sub(num_durable_addrs))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..num_durable_addrs)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..num_durable_addrs)),
                                                            true)),
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(num_durable_addrs,
                                                            (summary.length).spec_sub(elements.len()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::imply((current_pos).spec_lt(num_durable_addrs),
                                                            ::builtin::spec_eq(current_addr,
                                                                tentative_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(current_pos))))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((result.view()),
                                                            tentative_elements.take(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        self.valid((journal.view()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        journal.valid()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (self.durable_mapping.view()).list_info.contains_key(durable_head)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (self.tentative_mapping.view()).list_info.contains_key(list_addr)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (::builtin::spec_literal_nat("0")).spec_lt(durable_addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_addrs.len(),
                                                            durable_elements.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (elements.len()).spec_lt(summary.length)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ((summary.length).spec_sub(elements.len())).spec_le(durable_elements.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_addrs,
                                                            (self.durable_mapping.view()).list_info.spec_index(durable_head))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_elements,
                                                            (self.durable_mapping.view()).list_elements.spec_index(durable_head))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs,
                                                            (self.tentative_mapping.view()).list_info.spec_index(list_addr))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_elements,
                                                            (self.tentative_mapping.view()).list_elements.spec_index(list_addr))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                        int>(num_durable_addrs)),
                                                            durable_addrs.skip((durable_addrs.len()).spec_sub(num_durable_addrs)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_elements,
                                                            (durable_elements.skip((durable_elements.len()).spec_sub(((summary.length).spec_sub(elements.len()))))).spec_add((elements.view())))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        pm.inv()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((pm.view()).read_state,
                                                            (journal.view()).read_state)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(pm.constants(),
                                                            (journal.view()).pm_constants)
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let current_pos = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verifier::proof_block]
                                                    {
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                    }

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(tentative_elements.take(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos)).push(tentative_elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos))),
                                                                        tentative_elements.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                            };
                                                    };
                                                    #[verus::internal(spec)]
                                                    #[verus::internal(unwrapped_binding)]
                                                    let mut verus_tmp;

                                                    #[verifier::proof_block]
                                                    {
                                                        verus_tmp =
                                                            ((durable_addrs.len()).spec_sub(num_durable_addrs)).spec_add(current_pos)
                                                    };
                                                    #[verus::internal(spec)]
                                                    let mut which_durable_addr;

                                                    #[verifier::proof_block]
                                                    {
                                                        #[verus::internal(spec)]
                                                        let verus_tmp_which_durable_addr = verus_tmp;
                                                        which_durable_addr = verus_tmp_which_durable_addr;
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::spec_eq(durable_addrs.skip((durable_addrs.len()).spec_sub(num_durable_addrs)).spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(current_pos)),
                                                                        durable_addrs.spec_index(which_durable_addr)))
                                                            };
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::spec_eq(current_addr,
                                                                        durable_addrs.spec_index(which_durable_addr)))
                                                            };
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                which_durable_addr), durable_addrs.len())))
                                                            };
                                                    };
                                                    let element_addr = current_addr + self.sm.row_element_start;
                                                    let element_crc_addr =
                                                        current_addr + self.sm.row_element_crc_start;
                                                    let current_element =
                                                        match exec_recover_object::<PM,
                                                                    L>(pm, element_addr, element_crc_addr) {
                                                            Some(e) => e,
                                                            None => { return Err(KvError::CRCMismatch); }
                                                        };
                                                    result.push(current_element);
                                                    if current_pos + 1 < num_durable_addrs {

                                                            #[verifier::proof_block]
                                                            {

                                                                #[verus::internal(const_header_wrapper)]
                                                                ||
                                                                    {
                                                                        ::builtin::assert_(::builtin::ext_equal(durable_addrs.skip((durable_addrs.len()).spec_sub(num_durable_addrs)).spec_index((current_pos).spec_add(::builtin::spec_literal_nat("1"))),
                                                                                durable_addrs.spec_index((which_durable_addr).spec_add(::builtin::spec_literal_nat("1")))))
                                                                    };
                                                            };

                                                            #[verifier::proof_block]
                                                            {

                                                                #[verus::internal(const_header_wrapper)]
                                                                ||
                                                                    {
                                                                        ::builtin::assert_(::builtin::ext_equal(durable_addrs.spec_index((which_durable_addr).spec_add(::builtin::spec_literal_nat("1"))),
                                                                                tentative_addrs.spec_index((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                                    };
                                                            };
                                                            let next_addr = current_addr + self.sm.row_next_start;
                                                            let next_crc_addr = next_addr + size_of::<u64>() as u64;
                                                            current_addr =
                                                                match exec_recover_object::<PM,
                                                                            u64>(pm, next_addr, next_crc_addr) {
                                                                    Some(n) => n,
                                                                    None => { return Err(KvError::CRCMismatch); }
                                                                };
                                                        }
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(tentative_elements,
                                            ((result.view())).spec_add((elements.view()))),
                                        {
                                            ::builtin::assert_(::builtin::ext_equal(tentative_elements,
                                                    (tentative_elements.take((summary.length).spec_sub(elements.len()))).spec_add((elements.view()))));
                                        });
                                }
                            };
                    }
                    let mut elements_cloned = clone_pmcopy_vec(&elements);
                    result.append(&mut elements_cloned);
                    Ok(result)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn read(&self, list_addr: u64, journal: &Journal<PM>)
                    -> Result<Vec<L>, KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(),
                                ::builtin::is_variant((self.view()).tentative, "Some"),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr)]);
                    ::builtin::ensures(|result: Result<Vec<L>, KvError>|
                            [match result {
                                        Ok(lst) =>
                                            ::builtin::spec_eq((self.view()).tentative.unwrap().m.spec_index(list_addr),
                                                (lst.view())),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    match self.m.get(&list_addr) {
                        None => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            Err(KvError::InternalError)
                        }
                        Some(ListTableEntry::<L>::Durable { ref summary }) =>
                            self.get_elements_case_durable(list_addr, summary, journal),
                        Some(ListTableEntry::<L>::Modified {
                            ref durable_head, ref summary, ref elements, .. }) =>
                            self.get_elements_case_modified(list_addr,
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (durable_head.view())),
                                summary, elements, journal),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn get_list_length(&self, list_addr: u64,
                    journal: &Journal<PM>) -> Result<usize, KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(),
                                ::builtin::is_variant((self.view()).tentative, "Some"),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr)]);
                    ::builtin::ensures(|result: Result<usize, KvError>|
                            [match result {
                                        Ok(num_elements) =>
                                            ::builtin::spec_eq((self.view()).tentative.unwrap().m.spec_index(list_addr).len(),
                                                num_elements),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    match self.m.get(&list_addr) {
                        None => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            Err(KvError::InternalError)
                        }
                        Some(ListTableEntry::<L>::Durable { ref summary }) =>
                            Ok(summary.length),
                        Some(ListTableEntry::<L>::Modified { ref summary, .. }) =>
                            Ok(summary.length),
                    }
                }
            }
        }
        pub mod recover_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[verus::internal(verus_macro)]
            pub(super) struct ListRowRecoveryInfo<L> where L: PmCopy +
                LogicalRange + Sized + std::fmt::Debug {
                pub element: L,
                pub head: u64,
                pub next: u64,
                pub pos: int,
            }
            #[verifier::reject_recursive_types(L)]
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub(super) struct ListRecoveryMapping<L> where L: PmCopy +
                LogicalRange + Sized + std::fmt::Debug {
                pub row_info: Map<u64, ListRowRecoveryInfo<L>>,
                pub list_info: Map<u64, Seq<u64>>,
                pub list_elements: Map<u64, Seq<L>>,
            }
            #[verus::internal(verus_macro)]
            impl<L> ListRecoveryMapping<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn new(s: Seq<u8>, list_addrs: Set<u64>,
                    sm: ListTableStaticMetadata) -> Option<Self> {
                    if ::builtin::exists(|mapping: Self|
                                    mapping.corresponds(s, list_addrs, sm)) {
                            Some(::builtin::choose::<ListRecoveryMapping<L>,
                                        _>(|mapping: ListRecoveryMapping<L>|
                                        mapping.corresponds(s, list_addrs, sm)))
                        } else { None }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn new_empty(tm: TableMetadata) -> Self {
                    Self {
                        row_info: Map::<u64, ListRowRecoveryInfo<L>>::empty(),
                        list_info: Map::<u64, Seq<u64>>::empty(),
                        list_elements: Map::<u64, Seq<L>>::empty(),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn row_info_corresponds(self, s: Seq<u8>,
                    sm: ListTableStaticMetadata) -> bool {
                    ::builtin::forall(|row_addr: u64|
                            ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                {
                                    let row_info = self.row_info.spec_index(row_addr);
                                    (::builtin::spec_eq(recover_object::<u64>(s,
                                                    (row_addr).spec_add(sm.row_next_start),
                                                    ((row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                Some(row_info.next))) &&
                                        (::builtin::spec_eq(recover_object::<L>(s,
                                                    (row_addr).spec_add(sm.row_element_start),
                                                    (row_addr).spec_add(::builtin::spec_cast_integer::<_,
                                                                int>(sm.row_element_crc_start))), Some(row_info.element)))
                                }))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn internally_consistent(self,
                    sm: ListTableStaticMetadata) -> bool {
                    ((((::builtin::forall(|row_addr: u64|
                                                            ::builtin::imply(#[verus::internal(trigger)] self.row_info.contains_key(row_addr),
                                                                {
                                                                    let row_info = self.row_info.spec_index(row_addr);
                                                                    (((sm.table.validate_row_addr(row_addr)) &&
                                                                                        (self.list_info.contains_key(row_info.head))) &&
                                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                row_info.pos),
                                                                                            self.list_info.spec_index(row_info.head).len())))) &&
                                                                        (::builtin::spec_eq(self.list_info.spec_index(row_info.head).spec_index(::builtin::spec_cast_integer::<_,
                                                                                            int>(row_info.pos)), row_addr))
                                                                }))) &&
                                                (::builtin::forall(|head: u64|
                                                            ::builtin::imply(#[verus::internal(trigger)] self.list_info.contains_key(head),
                                                                {
                                                                    (((::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                        self.list_info.spec_index(head).len()), usize::MAX))) &&
                                                                                        (::builtin::spec_eq(self.list_info.spec_index(head).spec_index(::builtin::spec_literal_integer("0")),
                                                                                                head))) && (self.list_elements.contains_key(head))) &&
                                                                        (::builtin::spec_eq(self.list_elements.spec_index(head).len(),
                                                                                self.list_info.spec_index(head).len()))
                                                                })))) &&
                                        (::builtin::forall(|head: u64|
                                                    ::builtin::imply(#[verus::internal(trigger)] self.list_elements.contains_key(head),
                                                        self.list_info.contains_key(head))))) &&
                                (::builtin::forall(|head: u64, pos: int|
                                            ::builtin::with_triggers(((self.list_info.spec_index(head).spec_index(pos),),),
                                                ::builtin::imply({
                                                        (self.list_info.contains_key(head)) &&
                                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                            pos), self.list_info.spec_index(head).len())))
                                                    },
                                                    {
                                                        let info =
                                                            self.row_info.spec_index(self.list_info.spec_index(head).spec_index(pos));
                                                        ((((self.row_info.contains_key(self.list_info.spec_index(head).spec_index(pos)))
                                                                                    && (::builtin::spec_eq(info.head, head))) &&
                                                                            (::builtin::spec_eq(info.pos, pos))) &&
                                                                    ((::builtin::spec_eq(info.next,
                                                                                    ::builtin::spec_literal_nat("0"))) ==
                                                                            (::builtin::spec_eq(pos,
                                                                                    (self.list_info.spec_index(head).len()).spec_sub(::builtin::spec_literal_nat("1"))))))
                                                            &&
                                                            (::builtin::spec_eq(info.element,
                                                                    self.list_elements.spec_index(head).spec_index(pos)))
                                                    }))))) &&
                        (::builtin::forall(|head: u64, pos: int, successor: int|
                                    ::builtin::with_triggers(((self.list_info.spec_index(head).spec_index(pos),
                                                self.list_info.spec_index(head).spec_index(successor)),),
                                        ::builtin::imply({
                                                (((self.list_info.contains_key(head)) &&
                                                                    (::builtin::spec_eq(successor,
                                                                            (pos).spec_add(::builtin::spec_literal_nat("1"))))) &&
                                                            ((::builtin::spec_literal_nat("0")).spec_le(pos))) &&
                                                    ((successor).spec_lt(self.list_info.spec_index(head).len()))
                                            },
                                            ::builtin::spec_eq(self.row_info.spec_index(self.list_info.spec_index(head).spec_index(pos)).next,
                                                self.list_info.spec_index(head).spec_index(successor))))))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn corresponds(self, s: Seq<u8>,
                    list_addrs: Set<u64>, sm: ListTableStaticMetadata) -> bool {
                    ((self.internally_consistent(sm)) &&
                                (self.row_info_corresponds(s, sm))) &&
                        (::builtin::spec_eq(self.list_elements.dom(), list_addrs))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_uniqueness_element(self, other: Self,
                    s: Seq<u8>, list_addrs: Set<u64>,
                    sm: ListTableStaticMetadata, head: u64, pos: int) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.corresponds(s, list_addrs, sm),
                                other.corresponds(s, list_addrs, sm),
                                self.list_info.contains_key(head),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            pos), self.list_info.spec_index(head).len()))]);
                    ::builtin::ensures([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            pos), other.list_info.spec_index(head).len())),
                                (::builtin::spec_eq(pos,
                                            (self.list_info.spec_index(head).len()).spec_sub(::builtin::spec_literal_nat("1"))))
                                    ==
                                    (::builtin::spec_eq(pos,
                                            (other.list_info.spec_index(head).len()).spec_sub(::builtin::spec_literal_nat("1")))),
                                ::builtin::spec_eq(self.list_info.spec_index(head).spec_index(pos),
                                    other.list_info.spec_index(head).spec_index(pos)),
                                ::builtin::spec_eq(self.list_elements.spec_index(head).spec_index(pos),
                                    other.list_elements.spec_index(head).spec_index(pos))]);
                    ::builtin::decreases((pos,));
                    if (pos).spec_gt(::builtin::spec_literal_nat("0")) {
                            self.lemma_uniqueness_element(other, s, list_addrs, sm,
                                head, (pos).spec_sub(::builtin::spec_literal_nat("1")));
                            ::builtin::assert_(::builtin::ext_equal(self.row_info.spec_index(self.list_info.spec_index(head).spec_index(pos)),
                                    other.row_info.spec_index(other.list_info.spec_index(head).spec_index(pos))));
                        }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_uniqueness_length(self, other: Self,
                    s: Seq<u8>, list_addrs: Set<u64>,
                    sm: ListTableStaticMetadata, head: u64) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.corresponds(s, list_addrs, sm),
                                other.corresponds(s, list_addrs, sm),
                                self.list_info.contains_key(head)]);
                    ::builtin::ensures([::builtin::spec_eq(self.list_info.spec_index(head).len(),
                                    other.list_info.spec_index(head).len())]);
                    self.lemma_uniqueness_element(other, s, list_addrs, sm,
                        head,
                        (self.list_info.spec_index(head).len()).spec_sub(::builtin::spec_literal_nat("1")));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_uniqueness_list(self, other: Self,
                    s: Seq<u8>, list_addrs: Set<u64>,
                    sm: ListTableStaticMetadata, head: u64) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.corresponds(s, list_addrs, sm),
                                other.corresponds(s, list_addrs, sm),
                                self.list_info.contains_key(head)]);
                    ::builtin::ensures([other.list_info.contains_key(head),
                                ::builtin::spec_eq(other.list_info.spec_index(head),
                                    self.list_info.spec_index(head))]);
                    self.lemma_uniqueness_length(other, s, list_addrs, sm,
                        head);
                    {
                        ::builtin::assert_forall_by(|pos: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pos), self.list_info.spec_index(head).len())));
                                    ::builtin::ensures(::builtin::spec_eq(self.list_info.spec_index(head).spec_index(pos),
                                            other.list_info.spec_index(head).spec_index(pos)));
                                    self.lemma_uniqueness_element(other, s, list_addrs, sm,
                                        head, pos);
                                });
                    }
                    ::builtin::assert_(::builtin::ext_equal(other.list_info.spec_index(head),
                            self.list_info.spec_index(head)));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_uniqueness_elements(self, other: Self,
                    s: Seq<u8>, list_addrs: Set<u64>,
                    sm: ListTableStaticMetadata, head: u64) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.corresponds(s, list_addrs, sm),
                                other.corresponds(s, list_addrs, sm),
                                self.list_elements.contains_key(head)]);
                    ::builtin::ensures([other.list_elements.contains_key(head),
                                ::builtin::spec_eq(other.list_elements.spec_index(head),
                                    self.list_elements.spec_index(head))]);
                    self.lemma_uniqueness_length(other, s, list_addrs, sm,
                        head);
                    {
                        ::builtin::assert_forall_by(|pos: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pos), self.list_elements.spec_index(head).len())));
                                    ::builtin::ensures(::builtin::spec_eq(self.list_elements.spec_index(head).spec_index(pos),
                                            other.list_elements.spec_index(head).spec_index(pos)));
                                    self.lemma_uniqueness_element(other, s, list_addrs, sm,
                                        head, pos);
                                });
                    }
                    ::builtin::assert_(::builtin::ext_equal(other.list_elements.spec_index(head),
                            self.list_elements.spec_index(head)));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_uniqueness(self, other: Self, s: Seq<u8>,
                    list_addrs: Set<u64>, sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.corresponds(s, list_addrs, sm),
                                other.corresponds(s, list_addrs, sm)]);
                    ::builtin::ensures([::builtin::spec_eq(self, other)]);
                    {
                        ::builtin::assert_by(::builtin::ext_equal(self.list_info,
                                other.list_info),
                            {
                                {
                                    ::builtin::assert_forall_by(|head: u64|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] self.list_info.contains_key(head));
                                                ::builtin::ensures({
                                                        (other.list_info.contains_key(head)) &&
                                                            (::builtin::spec_eq(other.list_info.spec_index(head),
                                                                    self.list_info.spec_index(head)))
                                                    });
                                                self.lemma_uniqueness_list(other, s, list_addrs, sm, head);
                                            });
                                }
                            });
                    }
                    ::builtin::assert_(::builtin::ext_equal(self.row_info,
                            other.row_info));
                    {
                        ::builtin::assert_by(::builtin::ext_equal(self.list_elements,
                                other.list_elements),
                            {
                                {
                                    ::builtin::assert_forall_by(|head: u64|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] self.list_elements.contains_key(head));
                                                ::builtin::ensures({
                                                        (other.list_elements.contains_key(head)) &&
                                                            (::builtin::spec_eq(other.list_elements.spec_index(head),
                                                                    self.list_elements.spec_index(head)))
                                                    });
                                                self.lemma_uniqueness_elements(other, s, list_addrs, sm,
                                                    head);
                                            });
                                }
                            });
                    }
                    ::builtin::assert_(::builtin::ext_equal(self, other));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_corresponds_implies_equals_new(self,
                    s: Seq<u8>, list_addrs: Set<u64>,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.corresponds(s, list_addrs, sm)]);
                    ::builtin::ensures([::builtin::spec_eq(Self::new(s,
                                        list_addrs, sm), Some(self))]);
                    self.lemma_uniqueness(Self::new(s, list_addrs, sm).unwrap(),
                        s, list_addrs, sm);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn as_snapshot(self: ListRecoveryMapping<L>)
                    -> ListTableSnapshot<L> {
                    ListTableSnapshot::<L> { m: self.list_elements }
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_recover_depends_only_on_my_area_if_valid(s1:
                        Seq<u8>, s2: Seq<u8>, addrs: Set<u64>,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(),
                                (sm.end()).spec_le(s1.len()),
                                seqs_match_in_range(s1, s2,
                                    ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                    ::builtin::spec_cast_integer::<_, int>(sm.end())),
                                ::builtin::is_variant(Self::recover(s1, addrs, sm),
                                    "Some")]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(s1,
                                        addrs, sm), Self::recover(s2, addrs, sm))]);
                    let mapping1 =
                        ListRecoveryMapping::<L>::new(s1, addrs, sm).unwrap();
                    {
                        ::builtin::assert_by(mapping1.corresponds(s2, addrs, sm),
                            {
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                            });
                    }
                    mapping1.lemma_corresponds_implies_equals_new(s2, addrs,
                        sm);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub fn lemma_recover_depends_only_on_my_area(s1: Seq<u8>,
                    s2: Seq<u8>, addrs: Set<u64>, sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(),
                                (sm.end()).spec_le(s1.len()),
                                seqs_match_in_range(s1, s2,
                                    ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                    ::builtin::spec_cast_integer::<_, int>(sm.end()))]);
                    ::builtin::ensures([::builtin::spec_eq(Self::recover(s1,
                                        addrs, sm), Self::recover(s2, addrs, sm))]);
                    if ::builtin::is_variant(Self::recover(s1, addrs, sm),
                                "Some") {
                            Self::lemma_recover_depends_only_on_my_area_if_valid(s1, s2,
                                addrs, sm);
                        } else if ::builtin::is_variant(Self::recover(s2, addrs,
                                   sm), "Some") {
                           Self::lemma_recover_depends_only_on_my_area_if_valid(s2, s1,
                               addrs, sm);
                       }
                }
            }
        }
        pub mod setup_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::align_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::traits_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            use vstd::arithmetic::overflow::CheckedU64;
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn space_needed_for_setup(ps: &SetupParameters,
                    min_start: &CheckedU64) -> CheckedU64 {
                    ::builtin::requires([ps.valid()]);
                    ::builtin::ensures(|result: CheckedU64|
                            [::builtin::spec_eq((result.view()),
                                        Self::spec_space_needed_for_setup(*ps,
                                            (min_start.view())))]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    let row_next_crc_start =
                        CheckedU64::new(size_of::<u64>() as u64);
                    let row_element_start =
                        row_next_crc_start.add_value(size_of::<u64>() as u64);
                    let row_element_crc_start =
                        row_element_start.add_value(size_of::<L>() as u64);
                    let row_size =
                        row_element_crc_start.add_value(size_of::<u64>() as u64);
                    let num_rows = CheckedU64::new(ps.max_list_elements);
                    let table_size = num_rows.mul_checked(&row_size);
                    let initial_space =
                        if min_start.is_overflowed() {
                                0
                            } else {
                               get_space_needed_for_alignment_usize(min_start.unwrap(),
                                       size_of::<u64>()) as u64
                           };
                    CheckedU64::new(initial_space).add_checked(&table_size)
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn setup_given_metadata(pm: &mut PM,
                    sm: &ListTableStaticMetadata) {
                    ::builtin::requires([old(pm).inv(),
                                (old(pm).view()).valid(), sm.valid::<L>(),
                                (sm.table.end).spec_le((old(pm).view()).len())]);
                    ::builtin::ensures([pm.inv(),
                                ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                (pm.view()).valid(),
                                ::builtin::spec_eq((pm.view()).len(),
                                    (old(pm).view()).len()),
                                ::builtin::spec_eq(Self::recover((pm.view()).read_state,
                                        Set::<u64>::empty(), *sm),
                                    Some(ListTableSnapshot::<L>::init())),
                                seqs_match_except_in_range((old(pm).view()).read_state,
                                    (pm.view()).read_state,
                                    ::builtin::spec_cast_integer::<_, int>(sm.table.start),
                                    ::builtin::spec_cast_integer::<_, int>(sm.table.end))]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp = ListRecoveryMapping::<L>::new_empty(sm.table)
                    };
                    #[verus::internal(spec)]
                    let mut mapping;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_mapping = verus_tmp;
                        mapping = verus_tmp_mapping;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = Set::<u64>::empty() };
                    #[verus::internal(spec)]
                    let mut list_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_list_addrs = verus_tmp;
                        list_addrs = verus_tmp_list_addrs;
                    };

                    #[verifier::proof_block]
                    {
                        ::builtin::assert_(mapping.corresponds((pm.view()).read_state,
                                list_addrs, *sm));
                        ::builtin::assert_(::builtin::ext_equal(mapping.as_snapshot(),
                                ListTableSnapshot::<L>::init()));
                        mapping.lemma_corresponds_implies_equals_new((pm.view()).read_state,
                            list_addrs, *sm);
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(Self::recover((pm.view()).read_state,
                                            Set::<u64>::empty(), *sm),
                                        Some(ListTableSnapshot::<L>::init())))
                            };
                    };
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn setup(pm: &mut PM, ps: &SetupParameters,
                    min_start: u64, max_end: u64)
                    -> Result<ListTableStaticMetadata, KvError> {
                    ::builtin::requires([old(pm).inv(),
                                (old(pm).view()).valid(), ps.valid(),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                min_start), max_end), (old(pm).view()).len()))]);
                    ::builtin::ensures(|result:
                                Result<ListTableStaticMetadata, KvError>|
                            [pm.inv(),
                                    ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                    (pm.view()).valid(),
                                    ::builtin::spec_eq((pm.view()).len(),
                                        (old(pm).view()).len()),
                                    match result {
                                        Ok(sm) => {
                                            (((((::builtin::spec_eq(Self::recover((pm.view()).read_state,
                                                                                            Set::<u64>::empty(), sm),
                                                                                        Some(ListTableSnapshot::<L>::init()))) &&
                                                                                (seqs_match_except_in_range((old(pm).view()).read_state,
                                                                                        (pm.view()).read_state,
                                                                                        ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                                                                        ::builtin::spec_cast_integer::<_, int>(sm.end())))) &&
                                                                        (sm.valid::<L>())) &&
                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(min_start),
                                                                                    sm.start()), sm.end()), max_end)))) &&
                                                        (::builtin::spec_eq((sm.end()).spec_sub(min_start),
                                                                Self::spec_space_needed_for_setup(*ps,
                                                                    ::builtin::spec_cast_integer::<_, nat>(min_start))))) &&
                                                (::builtin::spec_eq(sm.num_rows(), ps.max_list_elements))
                                        }
                                        Err(KvError::OutOfSpace) =>
                                            ((max_end).spec_sub(min_start)).spec_lt(Self::spec_space_needed_for_setup(*ps,
                                                    ::builtin::spec_cast_integer::<_, nat>(min_start))),
                                        _ => false,
                                    }]);

                    #[verus::internal(proof_block)]
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    let element_size = size_of::<L>();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(::builtin::spec_eq(element_size,
                                            L::spec_size_of()),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    let start =
                        align_checked_u64_to_usize(&CheckedU64::new(min_start),
                            size_of::<u64>());
                    let row_next_crc_start =
                        CheckedU64::new(size_of::<u64>() as u64);
                    let row_element_start =
                        row_next_crc_start.add_value(size_of::<u64>() as u64);
                    let row_element_crc_start =
                        row_element_start.add_value(size_of::<L>() as u64);
                    let row_size =
                        row_element_crc_start.add_value(size_of::<u64>() as u64);
                    let num_rows = CheckedU64::new(ps.max_list_elements);
                    let table_size = num_rows.mul_checked(&row_size);
                    let end = start.add_checked(&table_size);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(((end.view())).spec_sub(min_start),
                                        Self::spec_space_needed_for_setup(*ps,
                                            ::builtin::spec_cast_integer::<_, nat>(min_start))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(((table_size.view())).spec_ge((row_size.view())),
                                        {
                                            vstd::arithmetic::mul::lemma_mul_ordering(::builtin::spec_cast_integer::<_,
                                                        int>(ps.max_list_elements),
                                                ::builtin::spec_cast_integer::<_, int>((row_size.view())));
                                        });
                                }
                            };
                    }
                    if end.is_overflowed() { return Err(KvError::OutOfSpace); }
                    if end.unwrap() > max_end {
                            return Err(KvError::OutOfSpace);
                        }
                    let table =
                        TableMetadata::new(start.unwrap(), end.unwrap(),
                            ps.max_list_elements, row_size.unwrap());
                    let sm =
                        ListTableStaticMetadata {
                            table,
                            element_size: element_size as u64,
                            row_next_start: 0,
                            row_element_start: row_element_start.unwrap(),
                            row_element_crc_start: row_element_crc_start.unwrap(),
                        };
                    Self::setup_given_metadata(pm, &sm);
                    Ok(sm)
                }
            }
        }
        pub mod slots_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::util_v::*;
            use crate::pmem::pmcopy_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::super::spec_t::*;
            use vstd::set_lib::*;
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_corresponds_implies_sum_lengths_equals_num_pos_tuples(self,
                    sm: ListTableStaticMetadata, pos: int) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.row_info_complete(sm),
                                self.per_row_info_consistent(sm),
                                self.durable_mapping.internally_consistent(sm),
                                ::builtin::spec_eq(self.pending_allocations,
                                    Seq::<u64>::empty()),
                                ::builtin::spec_eq(self.pending_deallocations,
                                    Seq::<u64>::empty()),
                                self.durable_mapping.as_snapshot().m.dom().finite(),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            pos),
                                        self.durable_mapping.as_snapshot().m.dom().to_seq().len()))]);
                    ::builtin::ensures([({
                                        let m = self.durable_mapping.as_snapshot().m;
                                        let s = m.dom().to_seq();
                                        let prefix = s.take(pos);
                                        let tups =
                                            Set::<(u64,
                                                    int)>::new(::builtin::closure_to_fn_spec(|tup: (u64, int)|
                                                        {
                                                            let (head, i) = tup;
                                                            (prefix.contains(head)) &&
                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                i), m.spec_index(head).len())))
                                                        }));
                                        (tups.finite()) &&
                                            (::builtin::spec_eq(prefix.fold_left(::builtin::spec_literal_integer("0"),
                                                        ::builtin::closure_to_fn_spec(|total: int, head: u64|
                                                                (total).spec_add(m.spec_index(head).len()))), tups.len()))
                                    })]);
                    ::builtin::decreases((pos,));
                    let m = self.durable_mapping.as_snapshot().m;
                    let s = m.dom().to_seq();
                    let prefix = s.take(pos);
                    let tups =
                        Set::<(u64,
                                int)>::new(::builtin::closure_to_fn_spec(|tup: (u64, int)|
                                    {
                                        let (head, i) = tup;
                                        (prefix.contains(head)) &&
                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), m.spec_index(head).len())))
                                    }));
                    let f =
                        ::builtin::closure_to_fn_spec(|total: int, head: u64|
                                (total).spec_add(m.spec_index(head).len()));
                    lemma_set_to_seq_has_same_length_with_no_duplicates(m.dom());
                    if (pos).spec_gt(::builtin::spec_literal_nat("0")) {
                            let tups_prev =
                                Set::<(u64,
                                        int)>::new(::builtin::closure_to_fn_spec(|tup: (u64, int)|
                                            {
                                                let (head, i) = tup;
                                                (s.take((pos).spec_sub(::builtin::spec_literal_nat("1"))).contains(head))
                                                    &&
                                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    i), m.spec_index(head).len())))
                                            }));
                            let tups_cur =
                                Set::<(u64,
                                        int)>::new(::builtin::closure_to_fn_spec(|tup: (u64, int)|
                                            {
                                                let (head, i) = tup;
                                                (::builtin::spec_eq(head,
                                                            s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))))
                                                    &&
                                                    (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    i), m.spec_index(head).len())))
                                            }));
                            {
                                ::builtin::assert_by(tups_cur.finite() &&
                                        ::builtin::spec_eq(tups_cur.len(),
                                            m.spec_index(s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))).len()),
                                    {
                                        lemma_int_range(::builtin::spec_literal_integer("0"),
                                            ::builtin::spec_cast_integer::<_,
                                                    int>(m.spec_index(s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))).len()));
                                        lemma_bijection_makes_sets_have_equal_size(set_int_range(::builtin::spec_literal_integer("0"),
                                                ::builtin::spec_cast_integer::<_,
                                                        int>(m.spec_index(s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))).len())),
                                            tups_cur,
                                            ::builtin::closure_to_fn_spec(|i: int|
                                                    (s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1"))),
                                                        i)),
                                            ::builtin::closure_to_fn_spec(|tup: (u64, int)| tup.1));
                                    });
                            }
                            self.lemma_corresponds_implies_sum_lengths_equals_num_pos_tuples(sm,
                                (pos).spec_sub(::builtin::spec_literal_nat("1")));
                            ::builtin::assert_(::builtin::spec_eq(prefix.drop_last(),
                                    s.take((pos).spec_sub(::builtin::spec_literal_nat("1")))));
                            ::builtin::assert_(::builtin::spec_eq(prefix.last(),
                                    s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))));
                            ::builtin::assert_(::builtin::spec_eq(prefix.drop_last().fold_left(::builtin::spec_literal_integer("0"),
                                        f), tups_prev.len()));
                            ::builtin::assert_(::builtin::spec_eq(prefix.fold_left(::builtin::spec_literal_integer("0"),
                                        f),
                                    (tups_prev.len()).spec_add(m.spec_index(s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))).len())));
                            ::builtin::assert_(::builtin::spec_eq(m.spec_index(s.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))).len(),
                                    tups_cur.len()));
                            {
                                ::builtin::assert_by(::builtin::ext_equal((tups_prev).spec_add(tups_cur),
                                        tups),
                                    {
                                        {
                                            ::builtin::assert_forall_by(|tup: (u64, int)|
                                                    {
                                                        ::builtin::requires(#[verus::internal(trigger)] tups.contains(tup));
                                                        ::builtin::ensures(((tups_prev).spec_add(tups_cur)).contains(tup));
                                                        let head = tup.0;
                                                        let j =
                                                            ::builtin::choose::<int,
                                                                    _>(|j: int|
                                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                    j), s.take(pos).len())) &&
                                                                        ::builtin::spec_eq(s.take(pos).spec_index(j), head));
                                                        if (j).spec_lt((pos).spec_sub(::builtin::spec_literal_nat("1")))
                                                                {
                                                                ::builtin::assert_(::builtin::spec_eq(s.spec_index(j),
                                                                        head));
                                                                ::builtin::assert_(::builtin::spec_eq(s.take((pos).spec_sub(::builtin::spec_literal_nat("1"))).spec_index(j),
                                                                        head));
                                                                ::builtin::assert_(s.take((pos).spec_sub(::builtin::spec_literal_nat("1"))).contains(head));
                                                            }
                                                    });
                                        }
                                    });
                            }
                            ::builtin::assert_(tups_prev.disjoint(tups_cur));
                            lemma_set_disjoint_lens(tups_prev, tups_cur);
                        } else {
                           ::builtin::assert_(::builtin::ext_equal(prefix,
                                   Seq::<u64>::empty()));
                           ::builtin::assert_(::builtin::ext_equal(tups,
                                   Set::<(u64, int)>::empty()));
                       }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_corresponds_implication_for_free_list_length(self,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(),
                                self.row_info_complete(sm),
                                self.per_row_info_consistent(sm),
                                self.durable_mapping.internally_consistent(sm),
                                ::builtin::spec_eq(self.pending_allocations,
                                    Seq::<u64>::empty()),
                                ::builtin::spec_eq(self.pending_deallocations,
                                    Seq::<u64>::empty())]);
                    ::builtin::ensures([({
                                        let m = self.durable_mapping.as_snapshot().m;
                                        (m.dom().finite()) &&
                                            (::builtin::spec_eq(m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                                                        ::builtin::closure_to_fn_spec(|total: int, head: u64|
                                                                (total).spec_add(m.spec_index(head).len()))),
                                                    (sm.table.num_rows).spec_sub(self.free_list.len())))
                                    })]);
                    let m = self.durable_mapping.as_snapshot().m;
                    let addr_to_len =
                        ::builtin::closure_to_fn_spec(|total: int, head: u64|
                                (total).spec_add(m.spec_index(head).len()));
                    {
                        ::builtin::assert_forall_by(|pos: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    pos), self.free_list.len())));
                                    ::builtin::ensures(self.row_info.contains_key(#[verus::internal(trigger)] self.free_list.spec_index(pos)));
                                    ::builtin::assert_(::builtin::is_variant(self.row_info.spec_index(self.free_list.spec_index(pos)),
                                            "InFreeList"));
                                    ::builtin::assert_(self.row_info.contains_key(self.free_list.spec_index(pos)));
                                });
                    }
                    let free_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.row_info.contains_key(row_addr) &&
                                        ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                            "InFreeList")));
                    let list_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.row_info.contains_key(row_addr) &&
                                        ::builtin::is_variant(self.row_info.spec_index(row_addr),
                                            "NowhereFree")));
                    let valid_row_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64| self.row_info.contains_key(row_addr)));
                    let list_head_addrs =
                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    self.durable_mapping.row_info.contains_key(row_addr) &&
                                        ::builtin::spec_eq(self.durable_mapping.row_info.spec_index(row_addr).pos,
                                            ::builtin::spec_literal_nat("0"))));
                    ::builtin::assert_(::builtin::spec_eq(m.dom(),
                            self.durable_mapping.list_elements.dom()));
                    let list_heads = m.dom().to_seq();
                    {
                        ::builtin::assert_by(valid_row_addrs.finite() &&
                                ::builtin::spec_eq(valid_row_addrs.len(),
                                    sm.table.num_rows),
                            {
                                ::builtin::assert_(::builtin::ext_equal(valid_row_addrs,
                                        Set::<u64>::new(::builtin::closure_to_fn_spec(|row_addr:
                                                        u64| sm.table.validate_row_addr(row_addr)))));
                                sm.table.lemma_valid_row_set_len();
                            });
                    }
                    {
                        ::builtin::assert_by(free_row_addrs.finite(),
                            {
                                vstd::set_lib::lemma_len_subset(free_row_addrs,
                                    valid_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(list_row_addrs.finite(),
                            {
                                vstd::set_lib::lemma_len_subset(list_row_addrs,
                                    valid_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(list_head_addrs.finite(),
                            {
                                vstd::set_lib::lemma_len_subset(list_head_addrs,
                                    valid_row_addrs);
                            });
                    }
                    ::builtin::assert_(::builtin::ext_equal(list_head_addrs,
                            m.dom()));
                    {
                        ::builtin::assert_by(::builtin::spec_eq(valid_row_addrs.len(),
                                (free_row_addrs.len()).spec_add(list_row_addrs.len())),
                            {
                                ::builtin::assert_(free_row_addrs.disjoint(list_row_addrs));
                                ::builtin::assert_(::builtin::ext_equal((free_row_addrs).spec_add(list_row_addrs),
                                        valid_row_addrs));
                                vstd::set_lib::lemma_set_disjoint_lens(free_row_addrs,
                                    list_row_addrs);
                            });
                    }
                    {
                        ::builtin::assert_by(::builtin::spec_eq(free_row_addrs.len(),
                                self.free_list.len()),
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.free_list.to_set(),
                                        free_row_addrs));
                                self.free_list.unique_seq_to_set();
                            });
                    }
                    let tups =
                        Set::<(u64,
                                int)>::new(::builtin::closure_to_fn_spec(|tup: (u64, int)|
                                    {
                                        let (head, i) = tup;
                                        (list_heads.contains(head)) &&
                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), m.spec_index(head).len())))
                                    }));
                    {
                        ::builtin::assert_by(tups.finite() &&
                                ::builtin::spec_eq(list_heads.fold_left(::builtin::spec_literal_integer("0"),
                                        addr_to_len), tups.len()),
                            {
                                self.lemma_corresponds_implies_sum_lengths_equals_num_pos_tuples(sm,
                                    ::builtin::spec_cast_integer::<_, int>(list_heads.len()));
                                ::builtin::assert_(::builtin::ext_equal(list_heads.take(::builtin::spec_cast_integer::<_,
                                                    int>(list_heads.len())), list_heads));
                            });
                    }
                    {
                        ::builtin::assert_by(::builtin::spec_eq(tups.len(),
                                list_row_addrs.len()),
                            {
                                let f =
                                    ::builtin::closure_to_fn_spec(|tup: (u64, int)|
                                            self.durable_mapping.list_info.spec_index(tup.0).spec_index(tup.1));
                                let g =
                                    ::builtin::closure_to_fn_spec(|row_addr: u64|
                                            (self.durable_mapping.row_info.spec_index(row_addr).head,
                                                self.durable_mapping.row_info.spec_index(row_addr).pos));
                                {
                                    ::builtin::assert_forall_by(|tup: (u64, int)|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] tups.contains(tup));
                                                ::builtin::ensures(list_row_addrs.contains(f(tup)) &&
                                                        ::builtin::spec_eq(g(f(tup)), tup));
                                                let (head, i) = tup;
                                                ::builtin::assert_(list_heads.contains(head));
                                                lemma_set_to_seq_contains_iff_set_contains(m.dom(), head);
                                                ::builtin::assert_(m.dom().contains(head));
                                                ::builtin::assert_(self.durable_mapping.list_info.contains_key(head));
                                                ::builtin::assert_(self.row_info.contains_key(self.durable_mapping.list_info.spec_index(head).spec_index(i)));
                                            });
                                }
                                {
                                    ::builtin::assert_forall_by(|row_addr: u64|
                                            {
                                                ::builtin::requires(#[verus::internal(trigger)] list_row_addrs.contains(row_addr));
                                                ::builtin::ensures(tups.contains(g(row_addr)) &&
                                                        ::builtin::spec_eq(f(g(row_addr)), row_addr));
                                                ::builtin::assert_(self.durable_mapping.row_info.contains_key(row_addr));
                                                let (head, i) = g(row_addr);
                                                ::builtin::assert_(self.durable_mapping.list_info.contains_key(head));
                                                ::builtin::assert_(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                i),
                                                            self.durable_mapping.list_info.spec_index(head).len())));
                                                ::builtin::assert_(::builtin::spec_eq(self.durable_mapping.list_info.spec_index(head).spec_index(i),
                                                        row_addr));
                                                lemma_set_to_seq_contains_iff_set_contains(m.dom(), head);
                                                ::builtin::assert_(list_heads.contains(head));
                                            });
                                }
                                lemma_bijection_makes_sets_have_equal_size(tups,
                                    list_row_addrs, f, g);
                            });
                    }
                }
            }
        }
        pub mod spec_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use super::impl_v::*;
            use super::super::spec_t::*;
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct ListTableSnapshot<L> {
                pub m: Map<u64, Seq<L>>,
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableSnapshot<L> {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn init() -> Self {
                    Self { m: Map::<u64, Seq<L>>::empty() }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn delete(&self, list_addr: u64) -> Self {
                    Self { m: self.m.remove(list_addr) }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn append(&self, old_list_addr: u64, new_list_addr: u64,
                    new_element: L) -> Self {
                    let new_list =
                        self.m.spec_index(old_list_addr).push(new_element);
                    Self {
                        m: self.m.remove(old_list_addr).insert(new_list_addr,
                            new_list),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn create_singleton(&self, new_list_addr: u64,
                    new_element: L) -> Self {
                    Self {
                        m: self.m.insert(new_list_addr,
                            ::vstd::vstd::seq::Seq::empty().push(new_element)),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn update_element_at_index(&self, old_list_addr: u64,
                    new_list_addr: u64, idx: usize, new_element: L) -> Self {
                    let new_list =
                        self.m.spec_index(old_list_addr).update(::builtin::spec_cast_integer::<_,
                                    int>(idx), new_element);
                    Self {
                        m: self.m.remove(old_list_addr).insert(new_list_addr,
                            new_list),
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub fn trim(&self, old_list_addr: u64, new_list_addr: u64,
                    trim_length: int) -> Self {
                    if ::builtin::spec_eq(new_list_addr,
                                ::builtin::spec_literal_nat("0")) {
                            Self { m: self.m.remove(old_list_addr) }
                        } else {
                           let new_list =
                               self.m.spec_index(old_list_addr).skip(trim_length);
                           Self {
                               m: self.m.remove(old_list_addr).insert(new_list_addr,
                                   new_list),
                           }
                       }
                }
            }
            #[verifier::ext_equal]
            #[verus::internal(verus_macro)]
            pub struct ListTableView<L> {
                pub sm: ListTableStaticMetadata,
                pub logical_range_gaps_policy: LogicalRangeGapsPolicy,
                pub used_slots: int,
                pub durable: ListTableSnapshot<L>,
                pub tentative: Option<ListTableSnapshot<L>>,
            }
        }
        pub mod start_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use std::collections::{HashMap, HashSet};
            use super::impl_v::*;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn read_list(journal: &Journal<PM>,
                    sm: &ListTableStaticMetadata,
                    verus_tmp_list_addrs: Ghost<Set<u64>>,
                    verus_tmp_mapping: Ghost<ListRecoveryMapping<L>>,
                    row_addrs_used: &mut HashSet<u64>, list_addr: u64)
                    -> Result<ListSummary, KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let list_addrs;

                    #[verifier::proof_block]
                    { list_addrs = verus_tmp_list_addrs.view() };
                    #[verus::internal(header_unwrap_parameter)]
                    let mapping;

                    #[verifier::proof_block]
                    { mapping = verus_tmp_mapping.view() };
                    ::builtin::requires([journal.valid(),
                                ((journal.view()).constants.app_area_start).spec_le(sm.start()),
                                (sm.end()).spec_le((journal.view()).constants.app_area_end),
                                sm.valid::<L>(),
                                mapping.corresponds((journal.view()).read_state, list_addrs,
                                    *sm), list_addrs.contains(list_addr),
                                mapping.list_info.contains_key(list_addr),
                                !::builtin::spec_eq(list_addr,
                                        ::builtin::spec_literal_nat("0"))]);
                    ::builtin::ensures(|result: Result<ListSummary, KvError>|
                            [match result {
                                        Ok(summary) => {
                                            let row_addrs = mapping.list_info.spec_index(list_addr);
                                            ((((((((::builtin::forall(|row_addr: u64|
                                                                                                                    ::builtin::imply(#[verus::internal(trigger)] (old(row_addrs_used).view()).contains(row_addr),
                                                                                                                        (row_addrs_used.view()).contains(row_addr)))) &&
                                                                                                        (::builtin::forall(|i: int|
                                                                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                                                    i), row_addrs.len())),
                                                                                                                        (row_addrs_used.view()).contains(#[verus::internal(trigger)] row_addrs.spec_index(i))))))
                                                                                                &&
                                                                                                (::builtin::forall(|row_addr: u64|
                                                                                                            ::builtin::imply(#[verus::internal(trigger)] (row_addrs_used.view()).contains(row_addr),
                                                                                                                {
                                                                                                                    ((old(row_addrs_used).view()).contains(row_addr)) ||
                                                                                                                        (row_addrs.contains(row_addr))
                                                                                                                })))) &&
                                                                                        ((::builtin::spec_literal_nat("0")).spec_lt(row_addrs.len())))
                                                                                &&
                                                                                (::builtin::spec_eq(summary.head,
                                                                                        row_addrs.spec_index(::builtin::spec_literal_integer("0")))))
                                                                        && (::builtin::spec_eq(summary.tail, row_addrs.last()))) &&
                                                                (::builtin::spec_eq(summary.length, row_addrs.len()))) &&
                                                        (mapping.row_info.contains_key(summary.tail))) &&
                                                (::builtin::spec_eq(summary.end_of_logical_range,
                                                        mapping.row_info.spec_index(summary.tail).element.end()))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        Err(_) => false,
                                    }]);

                    #[verifier::proof_block]
                    { journal.lemma_valid_implications(); }
                    let mut current_addr = list_addr;
                    let pm = journal.get_pm_region_ref();
                    let mut num_elements_processed: usize = 0;
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = mapping.list_info.spec_index(list_addr) };
                    #[verus::internal(spec)]
                    let mut row_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_row_addrs = verus_tmp;
                        row_addrs = verus_tmp_row_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = mapping.list_elements.spec_index(list_addr) };
                    #[verus::internal(spec)]
                    let mut elements;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_elements = verus_tmp;
                        elements = verus_tmp_elements;
                    };
                    loop {
                        ::builtin::invariant([sm.valid::<L>(),
                                    (sm.table.end).spec_le((pm.view()).len()),
                                    (sm.table.end).spec_le((journal.view()).constants.app_area_end),
                                    !::builtin::spec_eq(current_addr,
                                            ::builtin::spec_literal_nat("0")),
                                    (num_elements_processed).spec_lt(row_addrs.len()),
                                    (row_addrs.len()).spec_le(usize::MAX),
                                    ::builtin::spec_eq(current_addr,
                                        row_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(num_elements_processed))),
                                    mapping.corresponds((pm.view()).read_state, list_addrs,
                                        *sm), list_addrs.contains(list_addr),
                                    mapping.list_info.contains_key(list_addr),
                                    ::builtin::spec_eq(row_addrs,
                                        mapping.list_info.spec_index(list_addr)),
                                    ::builtin::spec_eq(elements,
                                        mapping.list_elements.spec_index(list_addr)), pm.inv(),
                                    ::builtin::spec_eq(pm.constants(),
                                        (journal.view()).pm_constants),
                                    ::builtin::forall(|row_addr: u64|
                                            ::builtin::imply(#[verus::internal(trigger)] (old(row_addrs_used).view()).contains(row_addr),
                                                (row_addrs_used.view()).contains(row_addr))),
                                    ::builtin::forall(|i: int|
                                            ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), num_elements_processed)),
                                                (row_addrs_used.view()).contains(#[verus::internal(trigger)] row_addrs.spec_index(i)))),
                                    ::builtin::forall(|row_addr: u64|
                                            ::builtin::imply(#[verus::internal(trigger)] (row_addrs_used.view()).contains(row_addr),
                                                {
                                                    ((old(row_addrs_used).view()).contains(row_addr)) ||
                                                        (row_addrs.contains(row_addr))
                                                }))]);
                        ::builtin::decreases(((row_addrs.len()).spec_sub(num_elements_processed),));

                        #[verus::internal(proof_block)]
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }

                        #[verus::internal(proof_block)]
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(sm.table.validate_row_addr(current_addr))
                                };
                        };

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(row_addrs.contains(current_addr)) };
                        };
                        row_addrs_used.insert(current_addr);
                        let next_addr =
                            match exec_recover_object::<PM,
                                        u64>(pm, current_addr + sm.row_next_start,
                                    current_addr + sm.row_next_start + size_of::<u64>() as u64)
                                {
                                Some(n) => n,
                                None => { return Err(KvError::CRCMismatch); }
                            };
                        if next_addr == 0 {
                                let element =
                                    match exec_recover_object::<PM,
                                                L>(pm, current_addr + sm.row_element_start,
                                            current_addr + sm.row_element_crc_start) {
                                        Some(e) => e,
                                        None => { return Err(KvError::CRCMismatch); }
                                    };
                                let summary =
                                    ListSummary {
                                        head: list_addr,
                                        tail: current_addr,
                                        length: num_elements_processed + 1,
                                        end_of_logical_range: element.end(),
                                    };
                                return Ok(summary);
                            }
                        current_addr = next_addr;
                        num_elements_processed = num_elements_processed + 1;
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn read_all_lists(journal: &Journal<PM>,
                    sm: &ListTableStaticMetadata, list_addrs: &Vec<u64>,
                    verus_tmp_mapping: Ghost<ListRecoveryMapping<L>>)
                    ->
                        Result<(HashSet<u64>, HashMap<u64, ListTableEntry<L>>),
                        KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let mapping;

                    #[verifier::proof_block]
                    { mapping = verus_tmp_mapping.view() };
                    ::builtin::requires([journal.valid(),
                                ((journal.view()).constants.app_area_start).spec_le(sm.start()),
                                (sm.end()).spec_le((journal.view()).constants.app_area_end),
                                sm.valid::<L>(),
                                mapping.corresponds((journal.view()).read_state,
                                    (list_addrs.view()).to_set(), *sm),
                                ::builtin::forall(|list_addr: u64|
                                        (#[verus::internal(trigger)] (list_addrs.view()).contains(list_addr))
                                            == (mapping.list_info.contains_key(list_addr))),
                                !(list_addrs.view()).contains(::builtin::spec_literal_integer("0"))]);
                    ::builtin::ensures(|result:
                                Result<(HashSet<u64>, HashMap<u64, ListTableEntry<L>>),
                                KvError>|
                            [match result {
                                        Ok((row_addrs_used, m)) => {
                                            ((::builtin::forall(|row_addr: u64|
                                                                    (mapping.row_info.contains_key(row_addr)) ==
                                                                        (#[verus::internal(trigger)] (row_addrs_used.view()).contains(row_addr))))
                                                        &&
                                                        (::builtin::forall(|list_addr: u64|
                                                                    ::builtin::imply(#[verus::internal(trigger)] (m.view()).contains_key(list_addr),
                                                                        mapping.list_info.contains_key(list_addr))))) &&
                                                (::builtin::forall(|list_addr: u64|
                                                            ::builtin::imply(#[verus::internal(trigger)] mapping.list_info.contains_key(list_addr),
                                                                {
                                                                    let row_addrs = mapping.list_info.spec_index(list_addr);
                                                                    let summary =
                                                                        ((m.view()).spec_index(list_addr).arrow_Durable_summary());
                                                                    ((((((((::builtin::spec_literal_nat("0")).spec_lt(row_addrs.len()))
                                                                                                                        && ((m.view()).contains_key(list_addr))) &&
                                                                                                                (::builtin::is_variant((m.view()).spec_index(list_addr),
                                                                                                                        "Durable"))) &&
                                                                                                        (::builtin::spec_eq(summary.head,
                                                                                                                row_addrs.spec_index(::builtin::spec_literal_integer("0")))))
                                                                                                && (::builtin::spec_eq(summary.tail, row_addrs.last()))) &&
                                                                                        (::builtin::spec_eq(summary.length, row_addrs.len()))) &&
                                                                                (mapping.row_info.contains_key(summary.tail))) &&
                                                                        (::builtin::spec_eq(summary.end_of_logical_range,
                                                                                mapping.row_info.spec_index(summary.tail).element.end()))
                                                                })))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        Err(_) => false,
                                    }]);
                    let mut row_addrs_used = HashSet::<u64>::new();
                    let mut m = HashMap::<u64, ListTableEntry<L>>::new();
                    let num_lists = list_addrs.len();
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..num_lists)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..num_lists)),
                                                            true)),
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        journal.valid()
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ((journal.view()).constants.app_area_start).spec_le(sm.start())
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (sm.end()).spec_le((journal.view()).constants.app_area_end)
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        sm.valid::<L>()
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        !(list_addrs.view()).contains(::builtin::spec_literal_integer("0"))
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(num_lists, list_addrs.len())
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        mapping.corresponds((journal.view()).read_state,
                                                            (list_addrs.view()).to_set(), *sm)
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int, j: int|
                                                                ::builtin::with_triggers(((mapping.list_info.spec_index((list_addrs.view()).spec_index(i)).spec_index(j),),),
                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                    i), which_list)),
                                                                        {
                                                                            let row_addrs =
                                                                                mapping.list_info.spec_index((list_addrs.view()).spec_index(i));
                                                                            (mapping.list_info.contains_key((list_addrs.view()).spec_index(i)))
                                                                                &&
                                                                                (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                    j), row_addrs.len())),
                                                                                        (row_addrs_used.view()).contains(row_addrs.spec_index(j))))
                                                                        })))
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|row_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (row_addrs_used.view()).contains(row_addr),
                                                                    mapping.row_info.contains_key(row_addr)))
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|list_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] (m.view()).contains_key(list_addr),
                                                                    mapping.list_info.contains_key(list_addr)))
                                                    },
                                                    {
                                                        let which_list =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::with_triggers((((list_addrs.view()).spec_index(i),),),
                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                    i), which_list)),
                                                                        {
                                                                            let list_addr = (list_addrs.view()).spec_index(i);
                                                                            let row_addrs = mapping.list_info.spec_index(list_addr);
                                                                            let summary =
                                                                                ((m.view()).spec_index(list_addr).arrow_Durable_summary());
                                                                            ((((((((::builtin::spec_literal_nat("0")).spec_lt(row_addrs.len()))
                                                                                                                                && ((m.view()).contains_key(list_addr))) &&
                                                                                                                        (::builtin::is_variant((m.view()).spec_index(list_addr),
                                                                                                                                "Durable"))) &&
                                                                                                                (::builtin::spec_eq(summary.head,
                                                                                                                        row_addrs.spec_index(::builtin::spec_literal_integer("0")))))
                                                                                                        && (::builtin::spec_eq(summary.tail, row_addrs.last()))) &&
                                                                                                (::builtin::spec_eq(summary.length, row_addrs.len()))) &&
                                                                                        (mapping.row_info.contains_key(summary.tail))) &&
                                                                                (::builtin::spec_eq(summary.end_of_logical_range,
                                                                                        mapping.row_info.spec_index(summary.tail).element.end()))
                                                                        })))
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let which_list = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verus::internal(proof_block)]
                                                    {
                                                        ::builtin::reveal_hide_({
                                                                #[verus::internal(reveal_fn)]
                                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                                    ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                                                }

                                                                #[verus::internal(broadcast_use_reveal)]
                                                                __VERUS_REVEAL_INTERNAL__
                                                            }, 1);
                                                    }
                                                    #[verus::internal(spec)]
                                                    #[verus::internal(unwrapped_binding)]
                                                    let mut verus_tmp;

                                                    #[verifier::proof_block]
                                                    { verus_tmp = (m.view()) };
                                                    #[verus::internal(spec)]
                                                    let mut old_m;

                                                    #[verifier::proof_block]
                                                    {
                                                        #[verus::internal(spec)]
                                                        let verus_tmp_old_m = verus_tmp;
                                                        old_m = verus_tmp_old_m;
                                                    };
                                                    let list_addr = list_addrs[which_list];

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_((list_addrs.view()).to_set().contains(list_addr))
                                                            };
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(mapping.list_info.contains_key(list_addr))
                                                            };
                                                    };
                                                    match Self::read_list(journal, sm,
                                                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (list_addrs.view()).to_set()),
                                                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] mapping),
                                                            &mut row_addrs_used, list_addr) {
                                                        Ok(summary) => {
                                                            m.insert(list_addr, ListTableEntry::Durable { summary });
                                                        }
                                                        Err(e) => return Err(e),
                                                    };
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }
                    Ok((row_addrs_used, m))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn build_free_list(row_addrs_used: &HashSet<u64>,
                    sm: &ListTableStaticMetadata)
                    -> (Vec<u64>, Ghost<Map<u64, ListRowDisposition>>) {
                    ::builtin::requires([sm.valid::<L>()]);
                    ::builtin::ensures(|result:
                                (Vec<u64>, Ghost<Map<u64, ListRowDisposition>>)|
                            [({
                                            let (free_list, verus_tmp_row_info) = result;
                                            #[verus::internal(spec)]
                                            let row_info = verus_tmp_row_info.view();
                                            ((::builtin::forall(|row_addr: u64|
                                                                    ::builtin::imply(sm.table.validate_row_addr(row_addr),
                                                                        #[verus::internal(trigger)] row_info.contains_key(row_addr))))
                                                        &&
                                                        (::builtin::forall(|row_addr: u64|
                                                                    ::builtin::imply(#[verus::internal(trigger)] row_info.contains_key(row_addr),
                                                                        match row_info.spec_index(row_addr) {
                                                                            ListRowDisposition::InFreeList { pos } => {
                                                                                ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                            pos), (free_list.view()).len()))) &&
                                                                                            (::builtin::spec_eq((free_list.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                                                                int>(pos)), row_addr))) &&
                                                                                    (!(row_addrs_used.view()).contains(row_addr))
                                                                            }
                                                                            ListRowDisposition::NowhereFree =>
                                                                                (row_addrs_used.view()).contains(row_addr),
                                                                            _ => false,
                                                                        })))) &&
                                                (::builtin::forall(|i: int|
                                                            ::builtin::with_triggers((((free_list.view()).spec_index(i),),),
                                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                i), (free_list.view()).len())),
                                                                    {
                                                                        let row_addr = (free_list.view()).spec_index(i);
                                                                        ((sm.table.validate_row_addr(row_addr)) &&
                                                                                    (row_info.contains_key(row_addr))) &&
                                                                            (((if let ListRowDisposition::InFreeList { pos } =
                                                                                                    (row_info.spec_index(row_addr)) {
                                                                                                ::builtin::spec_eq(pos, i)
                                                                                            } else { false })))
                                                                    }))))
                                        })]);
                    let mut free_list = Vec::<u64>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = Map::<u64, ListRowDisposition>::empty() };
                    #[verus::internal(spec)]
                    let mut row_info;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_row_info = verus_tmp;
                        row_info = verus_tmp_row_info;
                    };
                    let mut row_addr = sm.table.start;

                    #[verifier::proof_block]
                    { sm.table.lemma_start_is_valid_row(); }
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..sm.table.num_rows)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..sm.table.num_rows)),
                                                            true)),
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        sm.valid::<L>()
                                                    },
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(sm.table.row_addr_to_index(row_addr),
                                                            ::builtin::spec_cast_integer::<_, int>(row_index))
                                                    },
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(sm.table.start),
                                                                    row_addr), sm.table.end))
                                                    },
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::imply((row_index).spec_lt(sm.table.num_rows),
                                                            sm.table.validate_row_addr(row_addr))
                                                    },
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|any_row_addr: u64|
                                                                ::builtin::imply({
                                                                        (sm.table.validate_row_addr(any_row_addr)) &&
                                                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                            sm.table.row_addr_to_index(any_row_addr)), row_index)))
                                                                    },
                                                                    #[verus::internal(trigger)] row_info.contains_key(any_row_addr)))
                                                    },
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::with_triggers((((free_list.view()).spec_index(i),),),
                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                    i), (free_list.view()).len())),
                                                                        {
                                                                            let row_addr = (free_list.view()).spec_index(i);
                                                                            ((sm.table.validate_row_addr(row_addr)) &&
                                                                                        (row_info.contains_key(row_addr))) &&
                                                                                (((if let ListRowDisposition::InFreeList { pos } =
                                                                                                        (row_info.spec_index(row_addr)) {
                                                                                                    ::builtin::spec_eq(pos, i)
                                                                                                } else { false })))
                                                                        })))
                                                    },
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|row_addr: u64|
                                                                ::builtin::imply(#[verus::internal(trigger)] row_info.contains_key(row_addr),
                                                                    match row_info.spec_index(row_addr) {
                                                                        ListRowDisposition::InFreeList { pos } => {
                                                                            ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                                        pos), (free_list.view()).len()))) &&
                                                                                        (::builtin::spec_eq((free_list.view()).spec_index(::builtin::spec_cast_integer::<_,
                                                                                                            int>(pos)), row_addr))) &&
                                                                                (!(row_addrs_used.view()).contains(row_addr))
                                                                        }
                                                                        ListRowDisposition::NowhereFree =>
                                                                            (row_addrs_used.view()).contains(row_addr),
                                                                        _ => false,
                                                                    }))
                                                    },
                                                    {
                                                        let row_index =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::forall(|i: int|
                                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                i), (free_list.view()).len())),
                                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                                sm.table.row_addr_to_index(#[verus::internal(trigger)] (free_list.view()).spec_index(i))),
                                                                            row_index))))
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let row_index = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verifier::proof_block]
                                                    {
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(vstd::std_specs::hash::group_hash_axioms)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                        sm.table.lemma_row_addr_successor_is_valid(row_addr);
                                                    }
                                                    #[verus::internal(spec)]
                                                    #[verus::internal(unwrapped_binding)]
                                                    let mut verus_tmp;

                                                    #[verifier::proof_block]
                                                    { verus_tmp = (free_list.view()) };
                                                    #[verus::internal(spec)]
                                                    let mut old_free_list;

                                                    #[verifier::proof_block]
                                                    {
                                                        #[verus::internal(spec)]
                                                        let verus_tmp_old_free_list = verus_tmp;
                                                        old_free_list = verus_tmp_old_free_list;
                                                    };
                                                    if row_addrs_used.contains(&row_addr) {

                                                            #[verifier::proof_block]
                                                            {
                                                                row_info =
                                                                    row_info.insert(row_addr, ListRowDisposition::NowhereFree);
                                                            }
                                                        } else {

                                                           #[verifier::proof_block]
                                                           {
                                                               #[verus::internal(spec)]
                                                               let pos = (free_list.view()).len();
                                                               row_info =
                                                                   row_info.insert(row_addr,
                                                                       ListRowDisposition::InFreeList { pos });
                                                           }
                                                           free_list.push(row_addr);
                                                       }
                                                    row_addr = row_addr + sm.table.row_size;
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_forall_by(|row_addr: u64|
                                            {
                                                ::builtin::requires(sm.table.validate_row_addr(row_addr));
                                                ::builtin::ensures(#[verus::internal(trigger)] row_info.contains_key(row_addr));
                                                let row_index = sm.table.row_addr_to_index(row_addr);
                                                {
                                                    ::builtin::reveal_hide_({
                                                            #[verus::internal(reveal_fn)]
                                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                            }

                                                            #[verus::internal(broadcast_use_reveal)]
                                                            __VERUS_REVEAL_INTERNAL__
                                                        }, 1);
                                                }
                                            });
                                }
                            };
                    }
                    (free_list,
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] row_info))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn start(journal: &Journal<PM>,
                    logical_range_gaps_policy: LogicalRangeGapsPolicy,
                    list_addrs: &Vec<u64>, sm: &ListTableStaticMetadata)
                    -> Result<Self, KvError> {
                    ::builtin::requires([journal.valid(),
                                journal.recover_idempotent(), (journal.view()).valid(),
                                ::builtin::spec_eq((journal.view()).journaled_addrs,
                                    Set::<int>::empty()),
                                ::builtin::spec_eq((journal.view()).durable_state,
                                    (journal.view()).read_state),
                                ::builtin::spec_eq((journal.view()).read_state,
                                    (journal.view()).commit_state),
                                ((journal.view()).constants.app_area_start).spec_le(sm.start()),
                                (sm.end()).spec_le((journal.view()).constants.app_area_end),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                ::builtin::is_variant(Self::recover((journal.view()).read_state,
                                        (list_addrs.view()).to_set(), *sm), "Some"),
                                sm.valid::<L>(),
                                !(list_addrs.view()).contains(::builtin::spec_literal_integer("0"))]);
                    ::builtin::ensures(|result: Result<Self, KvError>|
                            [match result {
                                        Ok(lists) => {
                                            let recovered_state =
                                                Self::recover((journal.view()).read_state,
                                                        (list_addrs.view()).to_set(), *sm).unwrap();
                                            let m = recovered_state.m;
                                            (((((((lists.valid((journal.view()))) &&
                                                                                                (::builtin::spec_eq((lists.view()).sm, *sm))) &&
                                                                                        (::builtin::spec_eq((lists.view()).logical_range_gaps_policy,
                                                                                                logical_range_gaps_policy))) && (m.dom().finite())) &&
                                                                        (::builtin::spec_eq((lists.view()).used_slots,
                                                                                m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                                                                                    ::builtin::closure_to_fn_spec(|total: int, row_addr: u64|
                                                                                            (total).spec_add(m.spec_index(row_addr).len())))))) &&
                                                                (::builtin::spec_eq((lists.view()).durable,
                                                                        recovered_state))) &&
                                                        (::builtin::spec_eq((lists.view()).tentative,
                                                                Some(recovered_state)))) &&
                                                (::builtin::spec_eq(recovered_state.m.dom(),
                                                        (list_addrs.view()).to_set()))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        Err(_) => false,
                                    }]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ListRecoveryMapping::<L>::new((journal.view()).read_state,
                                    (list_addrs.view()).to_set(), *sm).unwrap()
                    };
                    #[verus::internal(spec)]
                    let mut mapping;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_mapping = verus_tmp;
                        mapping = verus_tmp_mapping;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::forall(|list_addr: u64|
                                            (#[verus::internal(trigger)] (list_addrs.view()).contains(list_addr))
                                                == ((list_addrs.view()).to_set().contains(list_addr))))
                            };
                    };
                    let (row_addrs_used, m) =
                        match Self::read_all_lists(journal, sm, list_addrs,
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] mapping))
                            {
                            Ok(rm) => rm,
                            Err(e) => { return Err(e); }
                        };
                    let (free_list, verus_tmp_row_info) =
                        Self::build_free_list(&row_addrs_used, sm);
                    #[verus::internal(spec)]
                    let mut row_info;

                    #[verifier::proof_block]
                    { row_info = verus_tmp_row_info.view(); };
                    let journal_entry_overhead =
                        Journal::<PM>::journal_entry_overhead();
                    let sizeof_u64 = size_of::<u64>() as u64;
                    let space_needed_to_journal_next =
                        journal_entry_overhead + sizeof_u64 + sizeof_u64;
                    let lists =
                        Self {
                            status: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ListTableStatus::Quiescent),
                            sm: *sm,
                            must_abort: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] false),
                            logical_range_gaps_policy,
                            space_needed_to_journal_next,
                            durable_mapping: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] mapping),
                            tentative_mapping: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] mapping),
                            row_info: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] row_info),
                            m,
                            deletes_inverse: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] Map::<u64,
                                        nat>::empty()),
                            deletes: Vec::<ListSummary>::new(),
                            modifications: Vec::<Option<u64>>::new(),
                            free_list,
                            pending_allocations: Vec::<u64>::new(),
                            pending_deallocations: Vec::<u64>::new(),
                            phantom_pm: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] core::marker::PhantomData),
                        };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            Self::recover((journal.view()).read_state,
                                    (list_addrs.view()).to_set(), *sm).unwrap()
                    };
                    #[verus::internal(spec)]
                    let mut recovered_state;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_recovered_state = verus_tmp;
                        recovered_state = verus_tmp_recovered_state;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(recovered_state.m.dom(),
                                        (list_addrs.view()).to_set()))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        lists.internal_view().lemma_corresponds_implication_for_free_list_length(*sm);
                    }
                    Ok(lists)
                }
            }
        }
        pub mod trim_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<L> ListRecoveryMapping<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn trim(self, list_addr: u64, trim_length: int)
                    -> Self {
                    ::builtin::recommends([self.list_info.contains_key(list_addr),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            trim_length),
                                        self.list_info.spec_index(list_addr).len()))]);
                    let new_head =
                        self.list_info.spec_index(list_addr).spec_index(trim_length);
                    let new_addrs =
                        self.list_info.spec_index(list_addr).skip(trim_length);
                    let new_elements =
                        self.list_elements.spec_index(list_addr).skip(trim_length);
                    let new_row_info =
                        Map::<u64,
                                ListRowRecoveryInfo<L>>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    {
                                        (self.row_info.contains_key(row_addr)) &&
                                            (::builtin::imply(::builtin::spec_eq(self.row_info.spec_index(row_addr).head,
                                                        list_addr),
                                                    (self.row_info.spec_index(row_addr).pos).spec_ge(trim_length)))
                                    }),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    {
                                        let info = self.row_info.spec_index(row_addr);
                                        if ::builtin::spec_eq(info.head, list_addr) {
                                                ListRowRecoveryInfo::<L> {
                                                    head: new_head,
                                                    pos: (info.pos).spec_sub(trim_length),
                                                    ..info
                                                }
                                            } else { info }
                                    }));
                    Self {
                        row_info: new_row_info,
                        list_info: self.list_info.remove(list_addr).insert(new_head,
                            new_addrs),
                        list_elements: self.list_elements.remove(list_addr).insert(new_head,
                            new_elements),
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntryView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn summary(self) -> ListSummary {
                    match self {
                        ListTableEntryView::<L>::Durable { summary } => summary,
                        ListTableEntryView::<L>::Modified { summary, .. } =>
                            summary,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn length(self) -> usize { self.summary().length }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn valid(self) -> bool {
                    match self {
                        ListTableEntryView::Durable { summary } => true,
                        ListTableEntryView::Modified { summary, addrs, elements, ..
                            } => {
                            ((summary.length).spec_ge(addrs.len())) &&
                                (::builtin::spec_eq(addrs.len(), elements.len()))
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn trim(self, new_head: u64, trim_length: int,
                    num_modifications: nat) -> Self {
                    ::builtin::recommends([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            trim_length), self.length()))]);
                    match self {
                        ListTableEntryView::Durable { summary } =>
                            ListTableEntryView::Modified {
                                which_modification: num_modifications,
                                durable_head: summary.head,
                                summary: ListSummary {
                                    head: new_head,
                                    length: ::builtin::spec_cast_integer::<_,
                                            usize>(((summary.length).spec_sub(trim_length))),
                                    ..summary
                                },
                                addrs: Seq::<u64>::empty(),
                                elements: Seq::<L>::empty(),
                            },
                        ListTableEntryView::Modified {
                            which_modification, durable_head, summary, addrs, elements }
                            => {
                            let new_length = (summary.length).spec_sub(trim_length);
                            ListTableEntryView::Modified {
                                which_modification,
                                durable_head: if (new_length).spec_gt(addrs.len()) {
                                        durable_head
                                    } else { ::builtin::spec_literal_integer("0") },
                                summary: ListSummary {
                                    head: new_head,
                                    length: ::builtin::spec_cast_integer::<_,
                                            usize>(new_length),
                                    ..summary
                                },
                                addrs: if (new_length).spec_le(addrs.len()) {
                                        addrs.skip((addrs.len()).spec_sub(new_length))
                                    } else { addrs },
                                elements: if (new_length).spec_le(elements.len()) {
                                        elements.skip((elements.len()).spec_sub(new_length))
                                    } else { elements },
                            }
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntry<L> where L: PmCopy + LogicalRange + Sized +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn summary(self) -> ListSummary {
                    match self {
                        ListTableEntry::Durable { summary } => summary,
                        ListTableEntry::Modified { summary, .. } => summary,
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn length(self) -> usize { self.summary().length }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn trim(self, new_head: u64, trim_length: usize,
                    num_modifications: usize) -> (ListSummary, Self) {
                    ::builtin::requires([(self.view()).valid(),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            trim_length), self.length()))]);
                    ::builtin::ensures(|result: (ListSummary, Self)|
                            [({
                                            let (summary, new_self) = result;
                                            (::builtin::spec_eq((new_self.view()),
                                                        (self.view()).trim(new_head,
                                                            ::builtin::spec_cast_integer::<_, int>(trim_length),
                                                            ::builtin::spec_cast_integer::<_, nat>(num_modifications))))
                                                && (::builtin::spec_eq(summary, (self.view()).summary()))
                                        })]);
                    match self {
                        ListTableEntry::Durable { summary } => {
                            (summary,
                                ListTableEntry::Modified {
                                    which_modification: num_modifications,
                                    durable_head: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] summary.head),
                                    summary: ListSummary {
                                        head: new_head,
                                        length: (summary.length - trim_length) as usize,
                                        ..summary
                                    },
                                    addrs: Vec::<u64>::new(),
                                    elements: Vec::<L>::new(),
                                })
                        }
                        ListTableEntry::Modified {
                            which_modification,
                            durable_head,
                            summary,
                            mut addrs,
                            mut elements } => {
                            let new_length = summary.length - trim_length;
                            let addrs_len =
                                if new_length < addrs.len() {
                                        addrs.len() - new_length
                                    } else { 0 };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal((addrs.view()).skip(::builtin::spec_literal_integer("0")),
                                                (addrs.view())))
                                    };
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal((elements.view()).skip(::builtin::spec_literal_integer("0")),
                                                (elements.view())))
                                    };
                            };
                            (summary,
                                ListTableEntry::Modified {
                                    which_modification: which_modification,
                                    durable_head: if new_length > addrs.len() {
                                            durable_head
                                        } else {

                                           #[verifier::ghost_wrapper]
                                           ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0"))
                                       },
                                    summary: ListSummary {
                                        head: new_head,
                                        length: new_length as usize,
                                        ..summary
                                    },
                                    addrs: if new_length < addrs.len() {
                                            addrs.split_off(addrs_len)
                                        } else { addrs },
                                    elements: if new_length < elements.len() {
                                            elements.split_off(addrs_len)
                                        } else { elements },
                                })
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn trim(self, list_addr: u64, trim_length: int)
                    -> Self {
                    ::builtin::recommends([self.m.contains_key(list_addr),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            trim_length),
                                        self.tentative_mapping.list_info.spec_index(list_addr).len()))]);
                    let new_head =
                        self.tentative_mapping.list_info.spec_index(list_addr).spec_index(trim_length);
                    let new_row_info =
                        Map::<u64,
                                ListRowDisposition>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64| self.row_info.contains_key(row_addr)),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    if {
                                                ((self.tentative_mapping.row_info.contains_key(row_addr)) &&
                                                            (::builtin::spec_eq(self.tentative_mapping.row_info.spec_index(row_addr).head,
                                                                    list_addr))) &&
                                                    ((self.tentative_mapping.row_info.spec_index(row_addr).pos).spec_lt(trim_length))
                                            } {
                                            self.row_info.spec_index(row_addr).add_to_pending_deallocations((self.pending_deallocations.len()).spec_add(::builtin::spec_cast_integer::<_,
                                                            nat>(self.tentative_mapping.row_info.spec_index(row_addr).pos)))
                                        } else { self.row_info.spec_index(row_addr) }));
                    let new_deletes =
                        if let ListTableEntryView::Durable { summary } =
                                    self.m.spec_index(list_addr) {
                                self.deletes.push(summary)
                            } else { self.deletes };
                    let new_deletes_inverse =
                        if ::builtin::is_variant(self.m.spec_index(list_addr),
                                    "Durable") {
                                self.deletes_inverse.insert(list_addr, self.deletes.len())
                            } else { self.deletes_inverse };
                    let new_entry =
                        self.m.spec_index(list_addr).trim(new_head, trim_length,
                            self.modifications.len());
                    let new_modifications =
                        match self.m.spec_index(list_addr) {
                            ListTableEntryView::Durable { .. } =>
                                self.modifications.push(Some(new_head)),
                            ListTableEntryView::Modified { which_modification, .. } =>
                                self.modifications.update(::builtin::spec_cast_integer::<_,
                                            int>(which_modification), Some(new_head)),
                        };
                    Self {
                        tentative_mapping: self.tentative_mapping.trim(list_addr,
                            trim_length),
                        row_info: new_row_info,
                        m: self.m.remove(list_addr).insert(new_head, new_entry),
                        deletes_inverse: new_deletes_inverse,
                        deletes: new_deletes,
                        modifications: new_modifications,
                        pending_deallocations: (self.pending_deallocations).spec_add(self.tentative_mapping.list_info.spec_index(list_addr).take(trim_length)),
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_trim_works(self, list_addr: u64,
                    trim_length: int, sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(), self.valid(sm),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                self.durable_mapping.internally_consistent(sm),
                                self.tentative_mapping.internally_consistent(sm),
                                self.m.contains_key(list_addr),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            trim_length), self.m.spec_index(list_addr).length()))]);
                    ::builtin::ensures([self.trim(list_addr,
                                        trim_length).valid(sm),
                                ({
                                        let new_head =
                                            self.tentative_mapping.list_info.spec_index(list_addr).spec_index(trim_length);
                                        ::builtin::spec_eq(self.trim(list_addr,
                                                        trim_length).tentative_mapping.as_snapshot(),
                                            self.tentative_mapping.as_snapshot().trim(list_addr,
                                                new_head, trim_length))
                                    })]);
                    let new_head =
                        self.tentative_mapping.list_info.spec_index(list_addr).spec_index(trim_length);
                    let new_self = self.trim(list_addr, trim_length);
                    let old_snapshot = self.tentative_mapping.as_snapshot();
                    let new_snapshot = new_self.tentative_mapping.as_snapshot();
                    {
                        ::builtin::assert_by((new_head).spec_gt(::builtin::spec_literal_nat("0")),
                            {
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                            });
                    }
                    ::builtin::assert_(::builtin::ext_equal(new_snapshot,
                            old_snapshot.trim(list_addr, new_head, trim_length)));
                    ::builtin::assert_(::builtin::ext_equal(self.trim(list_addr,
                                        trim_length).tentative_mapping.as_snapshot(),
                            self.tentative_mapping.as_snapshot().trim(list_addr,
                                new_head, trim_length)));
                    if let ListTableEntryView::Modified {
                                durable_head, summary, addrs, elements, .. } =
                                new_self.m.spec_index(new_head) {
                            let tentative_addrs =
                                new_self.tentative_mapping.list_info.spec_index(new_head);
                            let tentative_elements =
                                new_self.tentative_mapping.list_elements.spec_index(new_head);
                            if ::builtin::spec_eq(addrs.len(), summary.length) {
                                    ::builtin::assert_(::builtin::ext_equal(tentative_addrs,
                                            addrs));
                                    ::builtin::assert_(::builtin::ext_equal(tentative_elements,
                                            elements));
                                } else {
                                   let durable_addrs =
                                       new_self.durable_mapping.list_info.spec_index(durable_head);
                                   let durable_elements =
                                       new_self.durable_mapping.list_elements.spec_index(durable_head);
                                   ::builtin::assert_(new_self.durable_mapping.list_info.contains_key(durable_head));
                                   ::builtin::assert_(::builtin::ext_equal(tentative_addrs,
                                           (durable_addrs.skip((durable_addrs.len()).spec_sub(((summary.length).spec_sub(addrs.len()))))).spec_add(addrs)));
                                   ::builtin::assert_(::builtin::ext_equal(tentative_elements,
                                           (durable_elements.skip((durable_elements.len()).spec_sub(((summary.length).spec_sub(elements.len()))))).spec_add(elements)));
                               }
                        }
                }
            }
            #[verus::internal(verus_macro)]
            enum TrimAction {
                Delete,
                Modify {
                    pending_deallocations: Vec<u64>,
                    new_head: u64,
                },
                Advance {
                    pending_deallocations: Vec<u64>,
                    new_head: u64,
                },
                Drain {
                    pending_deallocations: Vec<u64>,
                },
            }
            #[verus::internal(verus_macro)]
            impl TrimAction {
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                fn arrow_new_head(self) -> u64 {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verus::internal(get_field_many_variants)]
                #[verifier::external]
                fn arrow_pending_deallocations(self) -> Vec<u64> {
                    ::core::panicking::panic("not implemented")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                fn arrow_Modify_pending_deallocations(self) -> Vec<u64> {
                    ::builtin::get_variant_field(self, "Modify",
                        "pending_deallocations")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                fn arrow_Modify_new_head(self) -> u64 {
                    ::builtin::get_variant_field(self, "Modify", "new_head")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                fn arrow_Advance_pending_deallocations(self) -> Vec<u64> {
                    ::builtin::get_variant_field(self, "Advance",
                        "pending_deallocations")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                fn arrow_Advance_new_head(self) -> u64 {
                    ::builtin::get_variant_field(self, "Advance", "new_head")
                }
                #[cfg(verus_keep_ghost)]
                #[allow(non_snake_case)]
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                #[verifier::inline]
                fn arrow_Drain_pending_deallocations(self) -> Vec<u64> {
                    ::builtin::get_variant_field(self, "Drain",
                        "pending_deallocations")
                }
            }
            #[verus::internal(verus_macro)]
            impl TrimAction {
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                fn applicable<L>(self, iv: ListTableInternalView<L>,
                    list_addr: u64, trim_length: int) -> bool where L: PmCopy +
                    LogicalRange + Sized + std::fmt::Debug {
                    ::builtin::recommends([iv.tentative_mapping.list_info.contains_key(list_addr)]);
                    match self {
                        TrimAction::Delete =>
                            ::builtin::spec_eq(iv.tentative_mapping.list_info.spec_index(list_addr).len(),
                                trim_length),
                        TrimAction::Modify { pending_deallocations, new_head } => {
                            ((((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        trim_length),
                                                                    iv.tentative_mapping.list_info.spec_index(list_addr).len())))
                                                        && (iv.m.contains_key(list_addr))) &&
                                                (::builtin::is_variant(iv.m.spec_index(list_addr),
                                                        "Durable"))) &&
                                        (::builtin::spec_eq((pending_deallocations.view()),
                                                iv.tentative_mapping.list_info.spec_index(list_addr).take(trim_length))))
                                &&
                                (::builtin::spec_eq(new_head,
                                        iv.tentative_mapping.list_info.spec_index(list_addr).spec_index(trim_length)))
                        }
                        TrimAction::Advance { pending_deallocations, new_head } => {
                            ((((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        trim_length),
                                                                    iv.tentative_mapping.list_info.spec_index(list_addr).len())))
                                                        && (iv.m.contains_key(list_addr))) &&
                                                (::builtin::spec_eq(new_head,
                                                        iv.tentative_mapping.list_info.spec_index(list_addr).spec_index(trim_length))))
                                        &&
                                        (::builtin::spec_eq((pending_deallocations.view()),
                                                iv.tentative_mapping.list_info.spec_index(list_addr).take(trim_length))))
                                &&
                                (match iv.m.spec_index(list_addr) {
                                        ListTableEntryView::Modified { summary, addrs, .. } =>
                                            ((summary.length).spec_sub(trim_length)).spec_gt(addrs.len()),
                                        _ => false,
                                    })
                        }
                        TrimAction::Drain { pending_deallocations } => {
                            ((::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_lt(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        trim_length),
                                                    iv.tentative_mapping.list_info.spec_index(list_addr).len())))
                                        && (iv.m.contains_key(list_addr))) &&
                                (match iv.m.spec_index(list_addr) {
                                        ListTableEntryView::Modified { summary, addrs, .. } => {
                                            (((summary.length).spec_sub(trim_length)).spec_le(addrs.len()))
                                                &&
                                                (::builtin::spec_eq((pending_deallocations.view()),
                                                        iv.tentative_mapping.list_info.spec_index(list_addr).take((summary.length).spec_sub(addrs.len()))))
                                        }
                                        _ => false,
                                    })
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(spec)]
                fn apply<L>(self, iv: ListTableInternalView<L>,
                    list_addr: u64, trim_length: int)
                    -> ListTableInternalView<L> where L: PmCopy + LogicalRange +
                    Sized + std::fmt::Debug {
                    ::builtin::recommends([iv.tentative_mapping.list_info.contains_key(list_addr)]);
                    let new_iv = iv.trim(list_addr, trim_length);
                    match self {
                        TrimAction::Delete => iv,
                        TrimAction::Modify { pending_deallocations, new_head } => {
                            let old_summary =
                                (iv.m.spec_index(list_addr).arrow_Durable_summary());
                            let new_entry =
                                iv.m.spec_index(list_addr).trim(new_head, trim_length,
                                    iv.modifications.len());
                            ListTableInternalView::<L> {
                                m: iv.m.remove(list_addr).insert(new_head, new_entry),
                                deletes: iv.deletes.push(old_summary),
                                modifications: iv.modifications.push(Some(new_head)),
                                pending_deallocations: (iv.pending_deallocations).spec_add((pending_deallocations.view())),
                                ..new_iv
                            }
                        }
                        TrimAction::Advance { pending_deallocations, new_head } => {
                            let which_modification =
                                (iv.m.spec_index(list_addr).arrow_Modified_which_modification());
                            let new_entry =
                                iv.m.spec_index(list_addr).trim(new_head, trim_length,
                                    iv.modifications.len());
                            ListTableInternalView::<L> {
                                m: iv.m.remove(list_addr).insert(new_head, new_entry),
                                modifications: iv.modifications.update(::builtin::spec_cast_integer::<_,
                                            int>(which_modification), Some(new_head)),
                                pending_deallocations: (iv.pending_deallocations).spec_add((pending_deallocations.view())),
                                ..new_iv
                            }
                        }
                        TrimAction::Drain { pending_deallocations } => {
                            let which_modification =
                                (iv.m.spec_index(list_addr).arrow_Modified_which_modification());
                            let old_summary =
                                (iv.m.spec_index(list_addr).arrow_Modified_summary());
                            let addrs =
                                (iv.m.spec_index(list_addr).arrow_Modified_addrs());
                            let num_addrs_to_drain =
                                (addrs.len()).spec_sub(((old_summary.length).spec_sub(trim_length)));
                            let new_head = addrs.spec_index(num_addrs_to_drain);
                            let new_entry =
                                iv.m.spec_index(list_addr).trim(new_head, trim_length,
                                    iv.modifications.len());
                            ListTableInternalView::<L> {
                                m: iv.m.remove(list_addr).insert(new_head, new_entry),
                                modifications: iv.modifications.update(::builtin::spec_cast_integer::<_,
                                            int>(which_modification), Some(new_head)),
                                pending_deallocations: ((iv.pending_deallocations).spec_add((pending_deallocations.view()))).spec_add((iv.m.spec_index(list_addr).arrow_Modified_addrs()).take(num_addrs_to_drain)),
                                ..new_iv
                            }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_action_works<L>(self, iv: ListTableInternalView<L>,
                    list_addr: u64, trim_length: int,
                    sm: ListTableStaticMetadata) where L: PmCopy +
                    LogicalRange + Sized + std::fmt::Debug {
                    ::builtin::requires([iv.tentative_mapping.list_info.contains_key(list_addr),
                                iv.valid(sm), iv.durable_mapping.internally_consistent(sm),
                                iv.tentative_mapping.internally_consistent(sm),
                                self.applicable::<L>(iv, list_addr, trim_length),
                                !(::builtin::is_variant(self, "Delete"))]);
                    ::builtin::ensures([::builtin::spec_eq(self.apply(iv,
                                        list_addr, trim_length), iv.trim(list_addr, trim_length))]);
                    ::builtin::assert_(::builtin::ext_equal(self.apply(iv,
                                list_addr, trim_length), iv.trim(list_addr, trim_length)));
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_addresses_to_trim_case_durable(&self, list_addr: u64,
                    trim_length: usize, summary: &ListSummary,
                    journal: &Journal<PM>) -> Result<(Vec<u64>, u64), KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                    "Durable"),
                                ::builtin::spec_eq(summary,
                                    ((self.m.view()).spec_index(list_addr).arrow_Durable_summary())),
                                (trim_length).spec_lt(summary.length)]);
                    ::builtin::ensures(|result:
                                Result<(Vec<u64>, u64), KvError>|
                            [match result {
                                        Ok((addrs, new_head)) => {
                                            (::builtin::spec_eq((addrs.view()),
                                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr).take(::builtin::spec_cast_integer::<_,
                                                                    int>(trim_length)))) &&
                                                (::builtin::spec_eq(new_head,
                                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr).spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(trim_length))))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    let mut current_addr = list_addr;
                    let mut result = Vec::<u64>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_addrs = verus_tmp;
                        addrs = verus_tmp_addrs;
                    };
                    let pm = journal.get_pm_region_ref();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(addrs.take(::builtin::spec_literal_integer("0")),
                                        Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..trim_length)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..trim_length)),
                                                            true)),
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (trim_length).spec_lt(addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(current_addr,
                                                            addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        !::builtin::spec_eq(current_addr,
                                                                ::builtin::spec_literal_nat("0"))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((result.view()),
                                                            addrs.take(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        self.valid((journal.view()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        journal.valid()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (self.durable_mapping.view()).list_info.contains_key(list_addr)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(addrs,
                                                            (self.durable_mapping.view()).list_info.spec_index(list_addr))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        pm.inv()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((pm.view()).read_state,
                                                            (journal.view()).read_state)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(pm.constants(),
                                                            (journal.view()).pm_constants)
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        ::builtin::decreases(((addrs.len()).spec_sub((result.view()).len()),));
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let current_pos = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verifier::proof_block]
                                                    {
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                    }

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(addrs.take(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos)).push(current_addr),
                                                                        addrs.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                            };
                                                    };
                                                    result.push(current_addr);
                                                    let next_addr = current_addr + self.sm.row_next_start;
                                                    let next_crc_addr = next_addr + size_of::<u64>() as u64;
                                                    current_addr =
                                                        match exec_recover_object::<PM,
                                                                    u64>(pm, next_addr, next_crc_addr) {
                                                            Some(n) => n,
                                                            None => { return Err(KvError::CRCMismatch); }
                                                        };
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((self.tentative_mapping.view()).list_info.spec_index(list_addr),
                                        (self.durable_mapping.view()).list_info.spec_index(list_addr)))
                            };
                    };
                    Ok((result, current_addr))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_addresses_to_trim_case_advance(&self, list_addr: u64,
                    trim_length: usize, verus_tmp_durable_head: Ghost<u64>,
                    summary: &ListSummary, addrs: &Vec<u64>,
                    journal: &Journal<PM>) -> Result<(Vec<u64>, u64), KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let durable_head;

                    #[verifier::proof_block]
                    { durable_head = verus_tmp_durable_head.view() };
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                    "Modified"),
                                ::builtin::spec_eq(durable_head,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_durable_head())),
                                ::builtin::spec_eq(summary,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_summary())),
                                ::builtin::spec_eq(addrs,
                                    ((self.m.view()).spec_index(list_addr).arrow_Modified_addrs())),
                                (trim_length).spec_lt((summary.length).spec_sub(addrs.len()))]);
                    ::builtin::ensures(|result:
                                Result<(Vec<u64>, u64), KvError>|
                            [match result {
                                        Ok((addrs, new_head)) => {
                                            (::builtin::spec_eq((addrs.view()),
                                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr).take(::builtin::spec_cast_integer::<_,
                                                                    int>(trim_length)))) &&
                                                (::builtin::spec_eq(new_head,
                                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr).spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(trim_length))))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    let mut current_addr = list_addr;
                    let mut result = Vec::<u64>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_info.spec_index(durable_head)
                    };
                    #[verus::internal(spec)]
                    let mut durable_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_addrs = verus_tmp;
                        durable_addrs = verus_tmp_durable_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.tentative_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut tentative_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_tentative_addrs = verus_tmp;
                        tentative_addrs = verus_tmp_tentative_addrs;
                    };
                    let pm = journal.get_pm_region_ref();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_literal_integer("0")),
                                        Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..trim_length)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..trim_length)),
                                                            true)),
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (trim_length).spec_lt((summary.length).spec_sub(addrs.len()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(current_addr,
                                                            tentative_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        !::builtin::spec_eq(current_addr,
                                                                ::builtin::spec_literal_nat("0"))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((result.view()),
                                                            tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        self.valid((journal.view()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        journal.valid()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (self.durable_mapping.view()).list_info.contains_key(durable_head)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (self.tentative_mapping.view()).list_info.contains_key(list_addr)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (::builtin::spec_literal_nat("0")).spec_lt(durable_addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (addrs.len()).spec_lt(summary.length)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ((summary.length).spec_sub(addrs.len())).spec_le(durable_addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_addrs,
                                                            (self.durable_mapping.view()).list_info.spec_index(durable_head))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs,
                                                            (self.tentative_mapping.view()).list_info.spec_index(list_addr))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs,
                                                            (durable_addrs.skip((durable_addrs.len()).spec_sub(((summary.length).spec_sub(addrs.len()))))).spec_add((addrs.view())))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        pm.inv()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((pm.view()).read_state,
                                                            (journal.view()).read_state)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(pm.constants(),
                                                            (journal.view()).pm_constants)
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let current_pos = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verifier::proof_block]
                                                    {
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                    }

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos)).push(current_addr),
                                                                        tentative_addrs.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                            };
                                                    };
                                                    result.push(current_addr);
                                                    let next_addr = current_addr + self.sm.row_next_start;
                                                    let next_crc_addr = next_addr + size_of::<u64>() as u64;
                                                    current_addr =
                                                        match exec_recover_object::<PM,
                                                                    u64>(pm, next_addr, next_crc_addr) {
                                                            Some(n) => n,
                                                            None => { return Err(KvError::CRCMismatch); }
                                                        };
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }
                    Ok((result, current_addr))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_addresses_to_trim_case_drain(&self, list_addr: u64,
                    num_durable_addrs: usize, journal: &Journal<PM>)
                    -> Result<Vec<u64>, KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(), (self.view()).tentative.is_some(),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((self.m.view()).spec_index(list_addr),
                                    "Modified"),
                                ::builtin::spec_eq(num_durable_addrs,
                                    (((self.m.view()).spec_index(list_addr).arrow_Modified_summary()).length).spec_sub(((self.m.view()).spec_index(list_addr).arrow_Modified_addrs()).len()))]);
                    ::builtin::ensures(|result: Result<Vec<u64>, KvError>|
                            [match result {
                                        Ok(addrs) =>
                                            ::builtin::spec_eq((addrs.view()),
                                                (self.tentative_mapping.view()).list_info.spec_index(list_addr).take(::builtin::spec_cast_integer::<_,
                                                            int>(num_durable_addrs))),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    let mut result = Vec::<u64>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.tentative_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut tentative_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_tentative_addrs = verus_tmp;
                        tentative_addrs = verus_tmp_tentative_addrs;
                    };
                    if num_durable_addrs == 0 {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_literal_integer("0")),
                                                Seq::<u64>::empty()))
                                    };
                            };
                            return Ok(result);
                        }
                    let mut current_addr = list_addr;
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (((self.m.view()).spec_index(list_addr).arrow_Modified_durable_head()).view())
                    };
                    #[verus::internal(spec)]
                    let mut durable_head;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_head = verus_tmp;
                        durable_head = verus_tmp_durable_head;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ((self.m.view()).spec_index(list_addr).arrow_Modified_summary())
                    };
                    #[verus::internal(spec)]
                    let mut summary;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_summary = verus_tmp;
                        summary = verus_tmp_summary;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            ((self.m.view()).spec_index(list_addr).arrow_Modified_addrs())
                    };
                    #[verus::internal(spec)]
                    let mut addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_addrs = verus_tmp;
                        addrs = verus_tmp_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (self.durable_mapping.view()).list_info.spec_index(durable_head)
                    };
                    #[verus::internal(spec)]
                    let mut durable_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_addrs = verus_tmp;
                        durable_addrs = verus_tmp_durable_addrs;
                    };
                    let pm = journal.get_pm_region_ref();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_literal_integer("0")),
                                        Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..num_durable_addrs)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..num_durable_addrs)),
                                                            true)),
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(num_durable_addrs,
                                                            (summary.length).spec_sub(addrs.len()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::imply((current_pos).spec_lt(num_durable_addrs),
                                                            ::builtin::spec_eq(current_addr,
                                                                tentative_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(current_pos))))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::imply((current_pos).spec_lt(num_durable_addrs),
                                                            !::builtin::spec_eq(current_addr,
                                                                    ::builtin::spec_literal_nat("0")))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((result.view()),
                                                            tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        self.valid((journal.view()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        journal.valid()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (self.durable_mapping.view()).list_info.contains_key(durable_head)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (self.tentative_mapping.view()).list_info.contains_key(list_addr)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (::builtin::spec_literal_nat("0")).spec_lt(durable_addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (addrs.len()).spec_lt(summary.length)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ((summary.length).spec_sub(addrs.len())).spec_le(durable_addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_addrs,
                                                            (self.durable_mapping.view()).list_info.spec_index(durable_head))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs,
                                                            (self.tentative_mapping.view()).list_info.spec_index(list_addr))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs,
                                                            (durable_addrs.skip((durable_addrs.len()).spec_sub(((summary.length).spec_sub(addrs.len()))))).spec_add((addrs.view())))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        pm.inv()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((pm.view()).read_state,
                                                            (journal.view()).read_state)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(pm.constants(),
                                                            (journal.view()).pm_constants)
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let current_pos = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verifier::proof_block]
                                                    {
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                    }

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos)).push(current_addr),
                                                                        tentative_addrs.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                            };
                                                    };
                                                    result.push(current_addr);
                                                    if current_pos < num_durable_addrs {
                                                            let next_addr = current_addr + self.sm.row_next_start;
                                                            let next_crc_addr = next_addr + size_of::<u64>() as u64;
                                                            current_addr =
                                                                match exec_recover_object::<PM,
                                                                            u64>(pm, next_addr, next_crc_addr) {
                                                                    Some(n) => n,
                                                                    None => { return Err(KvError::CRCMismatch); }
                                                                };
                                                        }
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }
                    Ok(result)
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn determine_action(&self, list_addr: u64, trim_length: usize,
                    journal: &Journal<PM>) -> Result<TrimAction, KvError> {
                    ::builtin::requires([self.valid((journal.view())),
                                journal.valid(),
                                ::builtin::is_variant((self.view()).tentative, "Some"),
                                (self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (::builtin::spec_literal_nat("0")).spec_lt(trim_length)]);
                    ::builtin::ensures(|result: Result<TrimAction, KvError>|
                            [match result {
                                        Ok(action) =>
                                            action.applicable(self.internal_view(), list_addr,
                                                ::builtin::spec_cast_integer::<_, int>(trim_length)),
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        Err(KvError::IndexOutOfRange { upper_bound }) => {
                                            (::builtin::spec_eq(upper_bound,
                                                        (self.view()).tentative.unwrap().m.spec_index(list_addr).len()))
                                                && ((upper_bound).spec_lt(trim_length))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        self.lemma_valid_implications((journal.view()));
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    match self.m.get(&list_addr) {
                        None => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            Err(KvError::InternalError)
                        }
                        Some(ListTableEntry::<L>::Durable { ref summary }) => {
                            if summary.length < trim_length {
                                    Err(KvError::IndexOutOfRange {
                                            upper_bound: summary.length,
                                        })
                                } else if summary.length == trim_length {
                                   Ok(TrimAction::Delete)
                               } else {
                                   match self.get_addresses_to_trim_case_durable(list_addr,
                                           trim_length, summary, journal) {
                                       Ok((pending_deallocations, new_head)) =>
                                           Ok(TrimAction::Modify { pending_deallocations, new_head }),
                                       Err(KvError::CRCMismatch) => Err(KvError::CRCMismatch),
                                       _ => {

                                           #[verifier::proof_block]
                                           {

                                               #[verus::internal(const_header_wrapper)]
                                               || { ::builtin::assert_(false) };
                                           };
                                           Err(KvError::InternalError)
                                       }
                                   }
                               }
                        }
                        Some(ListTableEntry::<L>::Modified {
                            ref durable_head, ref summary, ref addrs, .. }) => {
                            if summary.length < trim_length {
                                    Err(KvError::IndexOutOfRange {
                                            upper_bound: summary.length,
                                        })
                                } else if summary.length == trim_length {
                                   Ok(TrimAction::Delete)
                               } else if trim_length < summary.length - addrs.len() {
                                   match self.get_addresses_to_trim_case_advance(list_addr,
                                           trim_length,
                                           #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (durable_head.view())),
                                           summary, addrs, journal) {
                                       Ok((pending_deallocations, new_head)) =>
                                           Ok(TrimAction::Advance { pending_deallocations, new_head }),
                                       Err(KvError::CRCMismatch) => Err(KvError::CRCMismatch),
                                       _ => {

                                           #[verifier::proof_block]
                                           {

                                               #[verus::internal(const_header_wrapper)]
                                               || { ::builtin::assert_(false) };
                                           };
                                           Err(KvError::InternalError)
                                       }
                                   }
                               } else {
                                   match self.get_addresses_to_trim_case_drain(list_addr,
                                           summary.length - addrs.len(), journal) {
                                       Ok(pending_deallocations) =>
                                           Ok(TrimAction::Drain { pending_deallocations }),
                                       Err(KvError::CRCMismatch) => Err(KvError::CRCMismatch),
                                       _ => {

                                           #[verifier::proof_block]
                                           {

                                               #[verus::internal(const_header_wrapper)]
                                               || { ::builtin::assert_(false) };
                                           };
                                           Err(KvError::InternalError)
                                       }
                                   }
                               }
                        }
                    }
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn trim_case_modify(&mut self, list_addr: u64,
                    trim_length: usize, pending_deallocations: Vec<u64>,
                    new_head: u64, journal: &Journal<PM>) -> u64 {
                    ::builtin::requires([old(self).valid((journal.view())),
                                journal.valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().m.contains_key(list_addr),
                                (::builtin::spec_literal_nat("0")).spec_lt(trim_length),
                                (TrimAction::Modify {
                                            pending_deallocations,
                                            new_head,
                                        }).applicable(old(self).internal_view(), list_addr,
                                    ::builtin::spec_cast_integer::<_, int>(trim_length))]);
                    ::builtin::ensures(|new_list_addr: u64|
                            [self.valid((journal.view())),
                                    !::builtin::spec_eq(new_list_addr,
                                            ::builtin::spec_literal_nat("0")),
                                    self.validate_list_addr(new_list_addr),
                                    ({
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            ((({
                                                                        ((::builtin::spec_eq(new_list_addr,
                                                                                            ::builtin::spec_literal_nat("0"))) ||
                                                                                    (::builtin::spec_eq(new_list_addr, list_addr))) ||
                                                                            (!(old(self).view()).tentative.unwrap().m.contains_key(new_list_addr))
                                                                    }) && ((trim_length).spec_le(old_list.len()))) &&
                                                        (::builtin::imply(::builtin::spec_eq(new_list_addr,
                                                                    ::builtin::spec_literal_nat("0")),
                                                                ::builtin::spec_eq(old_list.skip(::builtin::spec_cast_integer::<_,
                                                                                int>(trim_length)), Seq::<L>::empty())))) &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView {
                                                                tentative: Some((old(self).view()).tentative.unwrap().trim(list_addr,
                                                                        new_list_addr,
                                                                        ::builtin::spec_cast_integer::<_, int>(trim_length))),
                                                                ..(old(self).view())
                                                            })))
                                        })]);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let mut pending_deallocations = pending_deallocations;
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            TrimAction::Modify { pending_deallocations, new_head }
                    };
                    #[verus::internal(spec)]
                    let mut action;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_action = verus_tmp;
                        action = verus_tmp_action;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = self.internal_view() };
                    #[verus::internal(spec)]
                    let mut old_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_old_iv = verus_tmp;
                        old_iv = verus_tmp_old_iv;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            old_iv.trim(list_addr,
                                ::builtin::spec_cast_integer::<_, int>(trim_length))
                    };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };
                    self.tentative_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.tentative_mapping);
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.row_info);
                    let old_entry =
                        match self.m.remove(&list_addr) {
                            Some(e) => e,
                            None => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return 0;
                            }
                        };
                    let (summary, new_entry) =
                        old_entry.trim(new_head, trim_length,
                            self.modifications.len());
                    self.m.insert(new_head, new_entry);
                    self.deletes_inverse =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.deletes_inverse);
                    self.deletes.push(summary);
                    self.modifications.push(Some(new_head));
                    self.pending_deallocations.append(&mut pending_deallocations);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        action.apply(old_iv, list_addr,
                                            ::builtin::spec_cast_integer::<_, int>(trim_length))))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        action.lemma_action_works(old_iv, list_addr,
                            ::builtin::spec_cast_integer::<_, int>(trim_length),
                            self.sm);
                        old_iv.lemma_trim_works(list_addr,
                            ::builtin::spec_cast_integer::<_, int>(trim_length),
                            old(self).sm);
                    }
                    new_head
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn trim_case_advance(&mut self, list_addr: u64,
                    trim_length: usize, pending_deallocations: Vec<u64>,
                    new_head: u64, journal: &Journal<PM>) -> u64 {
                    ::builtin::requires([old(self).valid((journal.view())),
                                journal.valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().m.contains_key(list_addr),
                                (::builtin::spec_literal_nat("0")).spec_lt(trim_length),
                                (TrimAction::Advance {
                                            pending_deallocations,
                                            new_head,
                                        }).applicable(old(self).internal_view(), list_addr,
                                    ::builtin::spec_cast_integer::<_, int>(trim_length))]);
                    ::builtin::ensures(|new_list_addr: u64|
                            [self.valid((journal.view())),
                                    !::builtin::spec_eq(new_list_addr,
                                            ::builtin::spec_literal_nat("0")),
                                    self.validate_list_addr(new_list_addr),
                                    ({
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            ((({
                                                                        ((::builtin::spec_eq(new_list_addr,
                                                                                            ::builtin::spec_literal_nat("0"))) ||
                                                                                    (::builtin::spec_eq(new_list_addr, list_addr))) ||
                                                                            (!(old(self).view()).tentative.unwrap().m.contains_key(new_list_addr))
                                                                    }) && ((trim_length).spec_le(old_list.len()))) &&
                                                        (::builtin::imply(::builtin::spec_eq(new_list_addr,
                                                                    ::builtin::spec_literal_nat("0")),
                                                                ::builtin::spec_eq(old_list.skip(::builtin::spec_cast_integer::<_,
                                                                                int>(trim_length)), Seq::<L>::empty())))) &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView {
                                                                tentative: Some((old(self).view()).tentative.unwrap().trim(list_addr,
                                                                        new_list_addr,
                                                                        ::builtin::spec_cast_integer::<_, int>(trim_length))),
                                                                ..(old(self).view())
                                                            })))
                                        })]);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let mut pending_deallocations = pending_deallocations;
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            TrimAction::Advance { pending_deallocations, new_head }
                    };
                    #[verus::internal(spec)]
                    let mut action;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_action = verus_tmp;
                        action = verus_tmp_action;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = self.internal_view() };
                    #[verus::internal(spec)]
                    let mut old_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_old_iv = verus_tmp;
                        old_iv = verus_tmp_old_iv;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            old_iv.trim(list_addr,
                                ::builtin::spec_cast_integer::<_, int>(trim_length))
                    };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };
                    self.tentative_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.tentative_mapping);
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.row_info);
                    let old_entry =
                        match self.m.remove(&list_addr) {
                            Some(e) => e,
                            None => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return 0;
                            }
                        };
                    let which_modification =
                        match old_entry {
                            ListTableEntry::Modified { which_modification, .. } =>
                                which_modification,
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return 0;
                            }
                        };
                    let (_summary, new_entry) =
                        old_entry.trim(new_head, trim_length,
                            self.modifications.len());
                    self.m.insert(new_head, new_entry);
                    self.modifications.set(which_modification, Some(new_head));
                    self.pending_deallocations.append(&mut pending_deallocations);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        action.apply(old_iv, list_addr,
                                            ::builtin::spec_cast_integer::<_, int>(trim_length))))
                            };
                    };

                    #[verifier::proof_block]
                    {
                        action.lemma_action_works(old_iv, list_addr,
                            ::builtin::spec_cast_integer::<_, int>(trim_length),
                            self.sm);
                        old_iv.lemma_trim_works(list_addr,
                            ::builtin::spec_cast_integer::<_, int>(trim_length),
                            old(self).sm);
                    }
                    new_head
                }
                #[inline]
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn trim_case_drain(&mut self, list_addr: u64,
                    trim_length: usize, pending_deallocations: Vec<u64>,
                    journal: &Journal<PM>) -> u64 {
                    ::builtin::requires([old(self).valid((journal.view())),
                                journal.valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().m.contains_key(list_addr),
                                (::builtin::spec_literal_nat("0")).spec_lt(trim_length),
                                (TrimAction::Drain {
                                            pending_deallocations,
                                        }).applicable(old(self).internal_view(), list_addr,
                                    ::builtin::spec_cast_integer::<_, int>(trim_length))]);
                    ::builtin::ensures(|new_list_addr: u64|
                            [self.valid((journal.view())),
                                    !::builtin::spec_eq(new_list_addr,
                                            ::builtin::spec_literal_nat("0")),
                                    self.validate_list_addr(new_list_addr),
                                    ::builtin::spec_eq(new_list_addr, list_addr) ||
                                        !(old(self).view()).tentative.unwrap().m.contains_key(new_list_addr),
                                    ({
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            ::builtin::spec_eq((self.view()),
                                                (ListTableView {
                                                        tentative: Some((old(self).view()).tentative.unwrap().trim(list_addr,
                                                                new_list_addr,
                                                                ::builtin::spec_cast_integer::<_, int>(trim_length))),
                                                        ..(old(self).view())
                                                    }))
                                        })]);

                    #[verifier::proof_block]
                    {
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let mut pending_deallocations = pending_deallocations;
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = TrimAction::Drain { pending_deallocations } };
                    #[verus::internal(spec)]
                    let mut action;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_action = verus_tmp;
                        action = verus_tmp_action;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = self.internal_view() };
                    #[verus::internal(spec)]
                    let mut old_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_old_iv = verus_tmp;
                        old_iv = verus_tmp_old_iv;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            old_iv.trim(list_addr,
                                ::builtin::spec_cast_integer::<_, int>(trim_length))
                    };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };
                    match self.m.remove(&list_addr) {
                        None => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            0
                        }
                        Some(ListTableEntry::Durable { .. }) => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            0
                        }
                        Some(ListTableEntry::Modified {
                            which_modification,
                            durable_head,
                            summary,
                            mut addrs,
                            mut elements }) => {
                            let new_length = summary.length - trim_length;
                            let num_further_pending_deallocations =
                                addrs.len() - new_length;
                            let new_addrs =
                                addrs.split_off(num_further_pending_deallocations);
                            let new_elements =
                                elements.split_off(num_further_pending_deallocations);
                            let new_head = new_addrs[0];
                            let new_entry =
                                ListTableEntry::Modified {
                                    which_modification,
                                    durable_head: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0")),
                                    summary: ListSummary {
                                        head: new_head,
                                        length: new_length,
                                        ..summary
                                    },
                                    addrs: new_addrs,
                                    elements: new_elements,
                                };
                            self.tentative_mapping =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.tentative_mapping);
                            self.row_info =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.row_info);
                            self.m.insert(new_head, new_entry);
                            self.modifications.set(which_modification, Some(new_head));
                            self.pending_deallocations.append(&mut pending_deallocations);
                            self.pending_deallocations.append(&mut addrs);

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal(self.internal_view().m.spec_index(new_head),
                                                action.apply(old_iv, list_addr,
                                                            ::builtin::spec_cast_integer::<_,
                                                                    int>(trim_length)).m.spec_index(new_head)))
                                    };
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                                action.apply(old_iv, list_addr,
                                                    ::builtin::spec_cast_integer::<_, int>(trim_length))))
                                    };
                            };

                            #[verifier::proof_block]
                            {
                                action.lemma_action_works(old_iv, list_addr,
                                    ::builtin::spec_cast_integer::<_, int>(trim_length),
                                    self.sm);
                                old_iv.lemma_trim_works(list_addr,
                                    ::builtin::spec_cast_integer::<_, int>(trim_length),
                                    old(self).sm);
                            }
                            new_head
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn trim<PermFactory>(&mut self, list_addr: u64,
                    trim_length: usize, journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<u64, KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().m.contains_key(list_addr),
                                (::builtin::spec_literal_nat("0")).spec_lt(trim_length),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    ::builtin::spec_eq((journal.view()).remaining_capacity,
                                        (old(journal).view()).remaining_capacity),
                                    match result {
                                        Ok(new_list_addr) => {
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            (((({
                                                                                ((::builtin::spec_eq(new_list_addr,
                                                                                                    ::builtin::spec_literal_nat("0"))) ||
                                                                                            (::builtin::spec_eq(new_list_addr, list_addr))) ||
                                                                                    (!(old(self).view()).tentative.unwrap().m.contains_key(new_list_addr))
                                                                            }) && ((trim_length).spec_le(old_list.len()))) &&
                                                                (::builtin::imply(::builtin::spec_eq(new_list_addr,
                                                                            ::builtin::spec_literal_nat("0")),
                                                                        ::builtin::spec_eq(old_list.skip(::builtin::spec_cast_integer::<_,
                                                                                        int>(trim_length)), Seq::<L>::empty())))) &&
                                                        (::builtin::spec_eq((self.view()),
                                                                (ListTableView {
                                                                        tentative: Some((old(self).view()).tentative.unwrap().trim(list_addr,
                                                                                new_list_addr,
                                                                                ::builtin::spec_cast_integer::<_, int>(trim_length))),
                                                                        ..(old(self).view())
                                                                    })))) &&
                                                (::builtin::imply(!::builtin::spec_eq(new_list_addr,
                                                                ::builtin::spec_literal_nat("0")),
                                                        self.validate_list_addr(new_list_addr)))
                                        }
                                        Err(KvError::IndexOutOfRange { upper_bound }) => {
                                            (((::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                                                ((trim_length).spec_gt(upper_bound))) &&
                                                        (::builtin::spec_eq(upper_bound,
                                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr).len())))
                                                &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::CRCMismatch) => {
                                            (!(journal.view()).pm_constants.impervious_to_corruption())
                                                &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        self.lemma_valid_implications((journal.view()));
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let action =
                        match self.determine_action(list_addr, trim_length, journal)
                            {
                            Ok(act) => act,
                            Err(KvError::CRCMismatch) => {
                                self.must_abort =
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                                return Err(KvError::CRCMismatch);
                            }
                            Err(KvError::IndexOutOfRange { upper_bound }) => {
                                return Err(KvError::IndexOutOfRange { upper_bound });
                            }
                            _ => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                        };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = self.internal_view() };
                    #[verus::internal(spec)]
                    let mut old_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_old_iv = verus_tmp;
                        old_iv = verus_tmp_old_iv;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            old_iv.trim(list_addr,
                                ::builtin::spec_cast_integer::<_, int>(trim_length))
                    };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };
                    match action {
                        TrimAction::Delete => {
                            match self.delete::<PermFactory>(list_addr, journal,
                                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory))
                                {
                                Ok(()) => {

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        ||
                                            {
                                                ::builtin::assert_(::builtin::spec_eq((old(self).view()).tentative.unwrap().m.spec_index(list_addr).len(),
                                                        trim_length))
                                            };
                                    };

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        ||
                                            {
                                                ::builtin::assert_(::builtin::ext_equal((old(self).view()).tentative.unwrap().m.spec_index(list_addr).skip(::builtin::spec_cast_integer::<_,
                                                                    int>(trim_length)), Seq::<L>::empty()))
                                            };
                                    };
                                    Ok(0u64)
                                }
                                Err(e) => Err(e),
                            }
                        }
                        TrimAction::Modify { pending_deallocations, new_head } =>
                            Ok(self.trim_case_modify(list_addr, trim_length,
                                    pending_deallocations, new_head, journal)),
                        TrimAction::Advance { pending_deallocations, new_head } =>
                            Ok(self.trim_case_advance(list_addr, trim_length,
                                    pending_deallocations, new_head, journal)),
                        TrimAction::Drain { pending_deallocations } =>
                            Ok(self.trim_case_drain(list_addr, trim_length,
                                    pending_deallocations, journal)),
                    }
                }
            }
        }
        pub mod update_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::common::util_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use crate::pmem::pmemutil_v::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::recover_v::*;
            use super::spec_v::*;
            use super::util_v::*;
            use super::super::spec_t::*;
            #[cfg(verus_keep_ghost)]
            use vstd::std_specs::hash::*;
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntry<L> where L: LogicalRange + PmCopy +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update(self, idx: usize, new_row_addr: u64, new_element: L)
                    -> Self {
                    ::builtin::requires([match self {
                                    ListTableEntry::Modified { summary, addrs, elements, .. } =>
                                        {
                                        ((::builtin::spec_eq(summary.length, addrs.len())) &&
                                                    (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                            ((idx).spec_lt(summary.length))
                                    }
                                    _ => false,
                                }]);
                    ::builtin::ensures(|result: Self|
                            [::builtin::spec_eq((result.view()),
                                        match (self.view()) {
                                            ListTableEntryView::Modified {
                                                which_modification, summary, durable_head, addrs, elements }
                                                =>
                                                ListTableEntryView::Modified {
                                                    which_modification,
                                                    summary: ListSummary {
                                                        head: if ::builtin::spec_eq(idx,
                                                                    ::builtin::spec_literal_nat("0")) {
                                                                new_row_addr
                                                            } else { summary.head },
                                                        tail: if ::builtin::spec_eq(idx,
                                                                    (addrs.len()).spec_sub(::builtin::spec_literal_nat("1"))) {
                                                                new_row_addr
                                                            } else { summary.tail },
                                                        ..summary
                                                    },
                                                    durable_head,
                                                    addrs: addrs.update(::builtin::spec_cast_integer::<_,
                                                                int>(idx), new_row_addr),
                                                    elements: elements.update(::builtin::spec_cast_integer::<_,
                                                                int>(idx), new_element),
                                                },
                                            _ => (self.view()),
                                        })]);
                    match self {
                        ListTableEntry::Durable { summary } =>
                            ListTableEntry::Durable { summary },
                        ListTableEntry::Modified {
                            which_modification,
                            mut summary,
                            durable_head,
                            mut addrs,
                            mut elements } => {
                            addrs.set(idx, new_row_addr);
                            elements.set(idx, new_element);
                            if idx == 0 { summary.head = new_row_addr; }
                            if idx == addrs.len() - 1 { summary.tail = new_row_addr; }
                            ListTableEntry::Modified {
                                which_modification,
                                summary,
                                durable_head,
                                addrs,
                                elements,
                            }
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableInternalView<L> where L: LogicalRange + PmCopy +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn complete_entry(self, list_addr: u64) -> Self {
                    ::builtin::recommends([self.m.contains_key(list_addr)]);
                    match self.m.spec_index(list_addr) {
                        ListTableEntryView::Durable { summary } => {
                            let addrs =
                                self.durable_mapping.list_info.spec_index(list_addr);
                            let elements =
                                self.durable_mapping.list_elements.spec_index(list_addr);
                            let which_delete = self.deletes.len();
                            let which_modification = self.modifications.len();
                            let new_entry =
                                ListTableEntryView::Modified {
                                    which_modification,
                                    durable_head: ::builtin::spec_literal_integer("0"),
                                    summary,
                                    addrs,
                                    elements,
                                };
                            let which_delete = self.deletes.len();
                            Self {
                                deletes_inverse: self.deletes_inverse.insert(list_addr,
                                    which_delete),
                                deletes: self.deletes.push(summary),
                                modifications: self.modifications.push(Some(list_addr)),
                                m: self.m.insert(list_addr, new_entry),
                                ..self
                            }
                        }
                        ListTableEntryView::Modified {
                            which_modification, durable_head, summary, addrs, elements }
                            => {
                            let tentative_addrs =
                                self.tentative_mapping.list_info.spec_index(list_addr);
                            let tentative_elements =
                                self.tentative_mapping.list_elements.spec_index(list_addr);
                            let new_entry =
                                ListTableEntryView::Modified {
                                    which_modification,
                                    durable_head: ::builtin::spec_literal_integer("0"),
                                    summary,
                                    addrs: tentative_addrs,
                                    elements: tentative_elements,
                                };
                            Self { m: self.m.insert(list_addr, new_entry), ..self }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_complete_entry_maintains_correspondence(self,
                    list_addr: u64, jv: JournalView,
                    sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                sm.corresponds_to_journal(jv),
                                self.corresponds_to_journal(jv, sm),
                                self.tentative_mapping.list_info.contains_key(list_addr)]);
                    ::builtin::ensures([self.complete_entry(list_addr).corresponds_to_journal(jv,
                                    sm)]);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(open)]
                #[verus::internal(spec)]
                pub(super) fn update(self, list_addr: u64, idx: usize,
                    new_element: L) -> Self {
                    let new_row_addr = self.free_list.last();
                    let old_addrs =
                        self.tentative_mapping.list_info.spec_index(list_addr);
                    let new_addrs =
                        old_addrs.update(::builtin::spec_cast_integer::<_,
                                    int>(idx), new_row_addr);
                    let new_head =
                        if ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0"))
                                {
                                new_row_addr
                            } else { list_addr };
                    let old_row_addr =
                        old_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                    int>(idx));
                    let old_elements =
                        self.tentative_mapping.list_elements.spec_index(list_addr);
                    let new_elements =
                        old_elements.update(::builtin::spec_cast_integer::<_,
                                    int>(idx), new_element);
                    let next_addr =
                        if ::builtin::spec_eq(idx,
                                    (old_addrs.len()).spec_sub(::builtin::spec_literal_nat("1")))
                                {
                                ::builtin::spec_literal_integer("0")
                            } else {
                               old_addrs.spec_index((idx).spec_add(::builtin::spec_literal_nat("1")))
                           };
                    let prev_addr =
                        if ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0"))
                                {
                                ::builtin::spec_literal_integer("0")
                            } else {
                               old_addrs.spec_index((idx).spec_sub(::builtin::spec_literal_nat("1")))
                           };
                    let new_row_info =
                        Map::<u64,
                                ListRowRecoveryInfo<L>>::new(::builtin::closure_to_fn_spec(|row_addr:
                                        u64|
                                    {
                                        (::builtin::spec_eq(row_addr, new_row_addr)) ||
                                            ({
                                                    (self.tentative_mapping.row_info.contains_key(row_addr)) &&
                                                        (!::builtin::spec_eq(row_addr, old_row_addr))
                                                })
                                    }),
                            ::builtin::closure_to_fn_spec(|row_addr: u64|
                                    {
                                        if ::builtin::spec_eq(row_addr, new_row_addr) {
                                                ListRowRecoveryInfo::<L> {
                                                    element: new_element,
                                                    head: new_head,
                                                    next: next_addr,
                                                    pos: ::builtin::spec_cast_integer::<_, int>(idx),
                                                }
                                            } else {
                                               let info =
                                                   self.tentative_mapping.row_info.spec_index(row_addr);
                                               if (idx).spec_gt(::builtin::spec_literal_nat("0")) &&
                                                           ::builtin::spec_eq(row_addr, prev_addr) {
                                                       ListRowRecoveryInfo::<L> {
                                                           head: new_head,
                                                           next: new_row_addr,
                                                           ..info
                                                       }
                                                   } else if ::builtin::spec_eq(info.head, list_addr) {
                                                      ListRowRecoveryInfo::<L> { head: new_head, ..info }
                                                  } else { info }
                                           }
                                    }));
                    let new_tentative_mapping =
                        ListRecoveryMapping::<L> {
                            row_info: new_row_info,
                            list_info: self.tentative_mapping.list_info.remove(list_addr).insert(new_head,
                                new_addrs),
                            list_elements: self.tentative_mapping.list_elements.remove(list_addr).insert(new_head,
                                new_elements),
                        };
                    let new_allocated_disposition =
                        ListRowDisposition::InPendingAllocationList {
                            pos: self.pending_allocations.len(),
                        };
                    let new_deallocated_disposition =
                        self.row_info.spec_index(old_row_addr).add_to_pending_deallocations(self.pending_deallocations.len());
                    let new_row_dispositions =
                        self.row_info.insert(new_row_addr,
                                new_allocated_disposition).insert(old_row_addr,
                            new_deallocated_disposition);
                    let new_modifications =
                        match self.m.spec_index(list_addr) {
                            ListTableEntryView::Durable { .. } => self.modifications,
                            ListTableEntryView::Modified { which_modification, .. } =>
                                self.modifications.update(::builtin::spec_cast_integer::<_,
                                            int>(which_modification), Some(new_head)),
                        };
                    let new_entry =
                        match self.m.spec_index(list_addr) {
                            ListTableEntryView::Durable { .. } =>
                                self.m.spec_index(list_addr),
                            ListTableEntryView::Modified {
                                which_modification, durable_head, summary, addrs, elements }
                                => {
                                let new_summary =
                                    ListSummary {
                                        head: new_head,
                                        tail: new_addrs.last(),
                                        length: summary.length,
                                        end_of_logical_range: new_elements.last().end(),
                                    };
                                ListTableEntryView::Modified {
                                    which_modification,
                                    durable_head,
                                    summary: new_summary,
                                    addrs: addrs.update(::builtin::spec_cast_integer::<_,
                                                int>(idx), new_row_addr),
                                    elements: elements.update(::builtin::spec_cast_integer::<_,
                                                int>(idx), new_element),
                                }
                            }
                        };
                    Self {
                        free_list: self.free_list.drop_last(),
                        tentative_mapping: new_tentative_mapping,
                        row_info: new_row_dispositions,
                        m: self.m.remove(list_addr).insert(new_head, new_entry),
                        pending_allocations: self.pending_allocations.push(new_row_addr),
                        pending_deallocations: self.pending_deallocations.push(old_row_addr),
                        modifications: new_modifications,
                        ..self
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_update_works(self, list_addr: u64,
                    idx: usize, new_element: L, sm: ListTableStaticMetadata) {
                    ::builtin::requires([sm.valid::<L>(), self.valid(sm),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                (::builtin::spec_literal_nat("0")).spec_lt(self.free_list.len()),
                                self.m.contains_key(list_addr),
                                match self.m.spec_index(list_addr) {
                                    ListTableEntryView::Modified { summary, addrs, elements, ..
                                        } => {
                                        ((((::builtin::spec_eq(summary.length, addrs.len())) &&
                                                                    (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                                            ((idx).spec_lt(addrs.len()))) &&
                                                    (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(idx)).start(), new_element.start()))) &&
                                            (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(idx)).end(), new_element.end()))
                                    }
                                    _ => false,
                                }]);
                    ::builtin::ensures([self.update(list_addr, idx,
                                        new_element).valid(sm),
                                ({
                                        let new_row_addr = self.free_list.last();
                                        let new_head =
                                            if ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0"))
                                                    {
                                                    new_row_addr
                                                } else { list_addr };
                                        ::builtin::spec_eq(self.update(list_addr, idx,
                                                        new_element).tentative_mapping.as_snapshot(),
                                            self.tentative_mapping.as_snapshot().update_element_at_index(list_addr,
                                                new_head, idx, new_element))
                                    })]);
                    let new_self = self.update(list_addr, idx, new_element);
                    let old_snapshot = self.tentative_mapping.as_snapshot();
                    let new_snapshot = new_self.tentative_mapping.as_snapshot();
                    let new_row_addr = self.free_list.last();
                    let new_head =
                        if ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0"))
                                {
                                new_row_addr
                            } else { list_addr };
                    ::builtin::assert_(::builtin::ext_equal(new_snapshot,
                            old_snapshot.update_element_at_index(list_addr, new_head,
                                idx, new_element)));
                    {
                        ::builtin::assert_by((new_row_addr).spec_gt(::builtin::spec_literal_nat("0")),
                            {
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                            });
                    }
                    match new_self.m.spec_index(new_head) {
                        ListTableEntryView::Modified {
                            durable_head, summary, addrs, elements, .. } => {
                            ::builtin::assert_(::builtin::spec_eq(durable_head,
                                    ::builtin::spec_literal_nat("0")));
                            ::builtin::assert_(::builtin::spec_eq(summary.length,
                                    addrs.len()));
                            ::builtin::assert_(::builtin::spec_eq(addrs.len(),
                                    elements.len()));
                        }
                        _ => { ::builtin::assert_(false); }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_addresses_and_elements_case_durable(&self,
                    list_addr: u64, summary: &ListSummary,
                    journal: &Journal<PM>, verus_tmp_prev_self: Ghost<Self>)
                    -> Result<(Vec<u64>, Vec<L>), KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_self;

                    #[verifier::proof_block]
                    { prev_self = verus_tmp_prev_self.view() };
                    ::builtin::requires([prev_self.valid((journal.view())),
                                journal.valid(), (prev_self.view()).tentative.is_some(),
                                (prev_self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (prev_self.m.view()).contains_key(list_addr),
                                ::builtin::is_variant((prev_self.m.view()).spec_index(list_addr),
                                    "Durable"),
                                ::builtin::spec_eq(summary,
                                    ((prev_self.m.view()).spec_index(list_addr).arrow_Durable_summary())),
                                ::builtin::spec_eq(self, (Self { m: self.m, ..prev_self })),
                                ::builtin::spec_eq((self.m.view()),
                                    (prev_self.m.view()).remove(list_addr))]);
                    ::builtin::ensures(|result:
                                Result<(Vec<u64>, Vec<L>), KvError>|
                            [match result {
                                        Ok((addrs, elements)) => {
                                            (::builtin::spec_eq((addrs.view()),
                                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr)))
                                                &&
                                                (::builtin::spec_eq((elements.view()),
                                                        (self.tentative_mapping.view()).list_elements.spec_index(list_addr)))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    let mut current_addr = list_addr;
                    let mut result_addrs = Vec::<u64>::new();
                    let mut result_elements = Vec::<L>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = ::builtin::spec_literal_integer("0") };
                    #[verus::internal(spec)]
                    let mut current_pos;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_current_pos: int = verus_tmp;
                        current_pos = verus_tmp_current_pos;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (prev_self.durable_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_addrs = verus_tmp;
                        addrs = verus_tmp_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (prev_self.durable_mapping.view()).list_elements.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut elements;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_elements = verus_tmp;
                        elements = verus_tmp_elements;
                    };
                    let pm = journal.get_pm_region_ref();

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(addrs.take(current_pos),
                                        Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(elements.take(current_pos),
                                        Seq::<L>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    while current_addr != 0 {
                        ::builtin::invariant([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                current_pos), addrs.len())),
                                    (::builtin::spec_eq(current_pos, addrs.len())) ==
                                        (::builtin::spec_eq(current_addr,
                                                ::builtin::spec_literal_nat("0"))),
                                    ::builtin::spec_eq(addrs.len(), elements.len()),
                                    ::builtin::imply((current_pos).spec_lt(addrs.len()),
                                        ::builtin::spec_eq(current_addr,
                                            addrs.spec_index(current_pos))),
                                    ::builtin::spec_eq((result_addrs.view()),
                                        addrs.take(current_pos)),
                                    ::builtin::spec_eq((result_elements.view()),
                                        elements.take(current_pos)),
                                    prev_self.valid((journal.view())), journal.valid(),
                                    (prev_self.durable_mapping.view()).list_info.contains_key(list_addr),
                                    ::builtin::spec_eq(addrs,
                                        (prev_self.durable_mapping.view()).list_info.spec_index(list_addr)),
                                    ::builtin::spec_eq(elements,
                                        (prev_self.durable_mapping.view()).list_elements.spec_index(list_addr)),
                                    pm.inv(),
                                    ::builtin::spec_eq((pm.view()).read_state,
                                        (journal.view()).read_state),
                                    ::builtin::spec_eq(pm.constants(),
                                        (journal.view()).pm_constants),
                                    ::builtin::spec_eq(self,
                                        (Self { m: self.m, ..prev_self }))]);
                        ::builtin::decreases(((addrs.len()).spec_sub((result_addrs.view()).len()),));

                        #[verifier::proof_block]
                        {
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                            {
                                ::builtin::reveal_hide_({
                                        #[verus::internal(reveal_fn)]
                                        fn __VERUS_REVEAL_INTERNAL__() {
                                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                        }

                                        #[verus::internal(broadcast_use_reveal)]
                                        __VERUS_REVEAL_INTERNAL__
                                    }, 1);
                            }
                        }

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal(addrs.take(current_pos).push(addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(current_pos))),
                                            addrs.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                };
                        };

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            ||
                                {
                                    ::builtin::assert_(::builtin::ext_equal(elements.take(current_pos).push(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                            int>(current_pos))),
                                            elements.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                };
                        };
                        let element_addr = current_addr + self.sm.row_element_start;
                        let element_crc_addr =
                            current_addr + self.sm.row_element_crc_start;
                        let current_element =
                            match exec_recover_object::<PM,
                                        L>(pm, element_addr, element_crc_addr) {
                                Some(e) => e,
                                None => { return Err(KvError::CRCMismatch); }
                            };
                        result_addrs.push(current_addr);
                        result_elements.push(current_element);
                        let next_addr = current_addr + self.sm.row_next_start;
                        let next_crc_addr = next_addr + size_of::<u64>() as u64;
                        current_addr =
                            match exec_recover_object::<PM,
                                        u64>(pm, next_addr, next_crc_addr) {
                                Some(n) => n,
                                None => { return Err(KvError::CRCMismatch); }
                            };

                        #[verifier::proof_block]
                        {
                            current_pos =
                                (current_pos).spec_add(::builtin::spec_literal_nat("1"));
                        }
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(addrs.take(current_pos),
                                        addrs))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(elements.take(current_pos),
                                        elements))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((prev_self.tentative_mapping.view()).list_info.spec_index(list_addr),
                                        (prev_self.durable_mapping.view()).list_info.spec_index(list_addr)))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq((prev_self.tentative_mapping.view()).list_elements.spec_index(list_addr),
                                        (prev_self.durable_mapping.view()).list_elements.spec_index(list_addr)))
                            };
                    };
                    Ok((result_addrs, result_elements))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn get_addresses_and_elements_case_modified(&self,
                    list_addr: u64, summary: &ListSummary,
                    journal: &Journal<PM>, num_addrs: usize,
                    verus_tmp_prev_self: Ghost<Self>)
                    -> Result<(Vec<u64>, Vec<L>), KvError> {
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_self;

                    #[verifier::proof_block]
                    { prev_self = verus_tmp_prev_self.view() };
                    ::builtin::requires([prev_self.valid((journal.view())),
                                journal.valid(), (prev_self.view()).tentative.is_some(),
                                (prev_self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (prev_self.m.view()).contains_key(list_addr),
                                (summary.length).spec_gt(num_addrs),
                                match (prev_self.m.view()).spec_index(list_addr) {
                                    ListTableEntry::Modified { summary: s, addrs, .. } => {
                                        (::builtin::spec_eq(summary, s)) &&
                                            (::builtin::spec_eq(addrs.len(), num_addrs))
                                    }
                                    _ => false,
                                },
                                ::builtin::spec_eq(self, (Self { m: self.m, ..prev_self })),
                                ::builtin::spec_eq((self.m.view()),
                                    (prev_self.m.view()).remove(list_addr))]);
                    ::builtin::ensures(|result:
                                Result<(Vec<u64>, Vec<L>), KvError>|
                            [match result {
                                        Ok((addrs, elements)) => {
                                            let num_durable_addrs =
                                                (summary.length).spec_sub(num_addrs);
                                            (::builtin::spec_eq((addrs.view()),
                                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr).take(num_durable_addrs)))
                                                &&
                                                (::builtin::spec_eq((elements.view()),
                                                        (self.tentative_mapping.view()).list_elements.spec_index(list_addr).take(num_durable_addrs)))
                                        }
                                        Err(KvError::CRCMismatch) =>
                                            !(journal.view()).pm_constants.impervious_to_corruption(),
                                        _ => false,
                                    }]);
                    let mut current_addr = list_addr;
                    let mut result_addrs = Vec::<u64>::new();
                    let mut result_elements = Vec::<L>::new();
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (((prev_self.m.view()).spec_index(list_addr).arrow_Modified_durable_head()).view())
                    };
                    #[verus::internal(spec)]
                    let mut durable_head;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_head = verus_tmp;
                        durable_head = verus_tmp_durable_head;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (prev_self.durable_mapping.view()).list_info.spec_index(durable_head)
                    };
                    #[verus::internal(spec)]
                    let mut durable_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_addrs = verus_tmp;
                        durable_addrs = verus_tmp_durable_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (prev_self.durable_mapping.view()).list_elements.spec_index(durable_head)
                    };
                    #[verus::internal(spec)]
                    let mut durable_elements;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_elements = verus_tmp;
                        durable_elements = verus_tmp_durable_elements;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (prev_self.tentative_mapping.view()).list_info.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut tentative_addrs;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_tentative_addrs = verus_tmp;
                        tentative_addrs = verus_tmp_tentative_addrs;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            (prev_self.tentative_mapping.view()).list_elements.spec_index(list_addr)
                    };
                    #[verus::internal(spec)]
                    let mut tentative_elements;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_tentative_elements = verus_tmp;
                        tentative_elements = verus_tmp_tentative_elements;
                    };
                    let pm = journal.get_pm_region_ref();
                    let num_durable_addrs = summary.length - num_addrs;

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_literal_integer("0")),
                                        Seq::<u64>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_elements.take(::builtin::spec_literal_integer("0")),
                                        Seq::<L>::empty()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                    int>(num_durable_addrs)),
                                        durable_addrs.skip((durable_addrs.len()).spec_sub(num_durable_addrs))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(tentative_elements.take(::builtin::spec_cast_integer::<_,
                                                    int>(num_durable_addrs)),
                                        durable_elements.skip((durable_elements.len()).spec_sub(num_durable_addrs))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    {
                        #[allow(non_snake_case)]
                        let VERUS_loop_result =
                            match ::core::iter::IntoIterator::into_iter(0..num_durable_addrs)
                                {
                                    #[allow(non_snake_case)]
                                    mut VERUS_exec_iter => {
                                    #[allow(non_snake_case)]
                                    #[verus::internal(spec)]
                                    let mut VERUS_ghost_iter;

                                    #[verifier::proof_block]
                                    {
                                        VERUS_ghost_iter =
                                            ::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&VERUS_exec_iter);
                                    }

                                    #[verus::internal(for_loop)]
                                    loop {
                                        ::builtin::invariant([#[verifier::custom_err("For-loop iterator invariant failed. This may indicate a bug in the definition of the ForLoopGhostIterator. You might try using a `loop` instead of a `for`.")] ::vstd::pervasive::ForLoopGhostIterator::exec_invariant(&VERUS_ghost_iter,
                                                        &VERUS_exec_iter),
                                                    #[verifier::custom_err("Automatically generated loop invariant failed. You can disable the automatic generation by adding #[verifier::no_auto_loop_invariant] to the loop. You might also try storing the loop expression in a variable outside the loop (e.g. `let e = 0..10; for x in e { ... }`).")] ::vstd::pervasive::ForLoopGhostIterator::ghost_invariant(&VERUS_ghost_iter,
                                                        builtin::infer_spec_for_loop_iter(&::vstd::pervasive::ForLoopGhostIteratorNew::ghost_iter(&::core::iter::IntoIterator::into_iter(0..num_durable_addrs)),
                                                            true)),
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(num_durable_addrs,
                                                            (summary.length).spec_sub(num_addrs))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    num_addrs), summary.length))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    current_pos), num_durable_addrs))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::imply((current_pos).spec_lt(num_durable_addrs),
                                                            ::builtin::spec_eq(current_addr,
                                                                tentative_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(current_pos))))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((result_addrs.view()),
                                                            tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((result_elements.view()),
                                                            tentative_elements.take(::builtin::spec_cast_integer::<_,
                                                                        int>(current_pos)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs.len(), summary.length)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_elements.len(), summary.length)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        prev_self.valid((journal.view()))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        journal.valid()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (prev_self.durable_mapping.view()).list_info.contains_key(durable_head)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (prev_self.tentative_mapping.view()).list_info.contains_key(list_addr)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (::builtin::spec_literal_nat("0")).spec_lt(durable_addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        (num_durable_addrs).spec_le(durable_addrs.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_addrs.len(),
                                                            durable_elements.len())
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_addrs,
                                                            (prev_self.durable_mapping.view()).list_info.spec_index(durable_head))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(durable_elements,
                                                            (prev_self.durable_mapping.view()).list_elements.spec_index(durable_head))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs,
                                                            (prev_self.tentative_mapping.view()).list_info.spec_index(list_addr))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_elements,
                                                            (prev_self.tentative_mapping.view()).list_elements.spec_index(list_addr))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                        int>(num_durable_addrs)),
                                                            durable_addrs.skip((durable_addrs.len()).spec_sub(num_durable_addrs)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(tentative_elements.take(::builtin::spec_cast_integer::<_,
                                                                        int>(num_durable_addrs)),
                                                            durable_elements.skip((durable_elements.len()).spec_sub(num_durable_addrs)))
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        pm.inv()
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq((pm.view()).read_state,
                                                            (journal.view()).read_state)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(pm.constants(),
                                                            (journal.view()).pm_constants)
                                                    },
                                                    {
                                                        let current_pos =
                                                            ::vstd::pervasive::ForLoopGhostIterator::ghost_peek_next(&VERUS_ghost_iter).unwrap_or(::vstd::pervasive::arbitrary());
                                                        ::builtin::spec_eq(self, (Self { m: self.m, ..prev_self }))
                                                    }]);
                                        ::builtin::ensures([::vstd::pervasive::ForLoopGhostIterator::ghost_ensures(&VERUS_ghost_iter)]);
                                        {
                                            #[allow(non_snake_case)]
                                            let mut VERUS_loop_next;
                                            match ::core::iter::Iterator::next(&mut VERUS_exec_iter) {
                                                ::core::option::Option::Some(VERUS_loop_val) => {
                                                    VERUS_loop_next = VERUS_loop_val;
                                                }
                                                ::core::option::Option::None => break,
                                            };
                                            let current_pos = VERUS_loop_next;
                                            let () =
                                                {

                                                    #[verifier::proof_block]
                                                    {
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                        {
                                                            ::builtin::reveal_hide_({
                                                                    #[verus::internal(reveal_fn)]
                                                                    fn __VERUS_REVEAL_INTERNAL__() {
                                                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                                                    }

                                                                    #[verus::internal(broadcast_use_reveal)]
                                                                    __VERUS_REVEAL_INTERNAL__
                                                                }, 1);
                                                        }
                                                    }

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(tentative_addrs.take(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos)).push(tentative_addrs.spec_index(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos))),
                                                                        tentative_addrs.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                            };
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(tentative_elements.take(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos)).push(tentative_elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                                        int>(current_pos))),
                                                                        tentative_elements.take((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                            };
                                                    };
                                                    #[verus::internal(spec)]
                                                    #[verus::internal(unwrapped_binding)]
                                                    let mut verus_tmp;

                                                    #[verifier::proof_block]
                                                    {
                                                        verus_tmp =
                                                            (durable_addrs.len()).spec_sub(num_durable_addrs)
                                                    };
                                                    #[verus::internal(spec)]
                                                    let mut num_skipped_durable;

                                                    #[verifier::proof_block]
                                                    {
                                                        #[verus::internal(spec)]
                                                        let verus_tmp_num_skipped_durable = verus_tmp;
                                                        num_skipped_durable = verus_tmp_num_skipped_durable;
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(durable_addrs.skip(num_skipped_durable).spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(current_pos)),
                                                                        durable_addrs.spec_index((num_skipped_durable).spec_add(current_pos))))
                                                            };
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::spec_eq(current_addr,
                                                                        durable_addrs.spec_index((num_skipped_durable).spec_add(current_pos))))
                                                            };
                                                    };
                                                    let element_addr = current_addr + self.sm.row_element_start;
                                                    let element_crc_addr =
                                                        current_addr + self.sm.row_element_crc_start;
                                                    let current_element =
                                                        match exec_recover_object::<PM,
                                                                    L>(pm, element_addr, element_crc_addr) {
                                                            Some(e) => e,
                                                            None => { return Err(KvError::CRCMismatch); }
                                                        };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::ext_equal(durable_elements.skip(num_skipped_durable).spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(current_pos)),
                                                                        durable_elements.spec_index((num_skipped_durable).spec_add(current_pos))))
                                                            };
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::spec_eq(current_element,
                                                                        durable_elements.spec_index((num_skipped_durable).spec_add(current_pos))))
                                                            };
                                                    };

                                                    #[verifier::proof_block]
                                                    {

                                                        #[verus::internal(const_header_wrapper)]
                                                        ||
                                                            {
                                                                ::builtin::assert_(::builtin::spec_eq(current_element,
                                                                        tentative_elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                                    int>(current_pos))))
                                                            };
                                                    };
                                                    result_addrs.push(current_addr);
                                                    result_elements.push(current_element);
                                                    if current_pos + 1 < num_durable_addrs {
                                                            let next_addr = current_addr + self.sm.row_next_start;
                                                            let next_crc_addr = next_addr + size_of::<u64>() as u64;
                                                            current_addr =
                                                                match exec_recover_object::<PM,
                                                                            u64>(pm, next_addr, next_crc_addr) {
                                                                    Some(n) => n,
                                                                    None => { return Err(KvError::CRCMismatch); }
                                                                };

                                                            #[verifier::proof_block]
                                                            {

                                                                #[verus::internal(const_header_wrapper)]
                                                                ||
                                                                    {
                                                                        ::builtin::assert_(::builtin::ext_equal(durable_addrs.skip(num_skipped_durable).spec_index((current_pos).spec_add(::builtin::spec_literal_nat("1"))),
                                                                                durable_addrs.spec_index(((num_skipped_durable).spec_add(current_pos)).spec_add(::builtin::spec_literal_nat("1")))))
                                                                    };
                                                            };

                                                            #[verifier::proof_block]
                                                            {

                                                                #[verus::internal(const_header_wrapper)]
                                                                ||
                                                                    {
                                                                        ::builtin::assert_(::builtin::spec_eq(current_addr,
                                                                                tentative_addrs.spec_index((current_pos).spec_add(::builtin::spec_literal_nat("1")))))
                                                                    };
                                                            };
                                                        }
                                                };
                                        }

                                        #[verifier::proof_block]
                                        {
                                            VERUS_ghost_iter =
                                                ::vstd::pervasive::ForLoopGhostIterator::ghost_advance(&VERUS_ghost_iter,
                                                    &VERUS_exec_iter);
                                        }
                                    }
                                }
                            };
                        VERUS_loop_result
                    }
                    Ok((result_addrs, result_elements))
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn complete_entry(&mut self, list_addr: u64,
                    entry: ListTableEntry<L>, journal: &Journal<PM>,
                    verus_tmp_prev_self: Ghost<Self>)
                    -> (bool, ListTableEntry<L>) {
                    #[verus::internal(header_unwrap_parameter)]
                    let prev_self;

                    #[verifier::proof_block]
                    { prev_self = verus_tmp_prev_self.view() };
                    ::builtin::requires([prev_self.valid((journal.view())),
                                journal.valid(),
                                ::builtin::spec_eq(old(self),
                                    (Self { m: old(self).m, ..prev_self })),
                                ::builtin::is_variant((prev_self.view()).tentative, "Some"),
                                (prev_self.view()).tentative.unwrap().m.contains_key(list_addr),
                                (prev_self.m.view()).contains_key(list_addr),
                                ::builtin::spec_eq(entry,
                                    (prev_self.m.view()).spec_index(list_addr)),
                                ::builtin::spec_eq((old(self).m.view()),
                                    (prev_self.m.view()).remove(list_addr))]);
                    ::builtin::ensures(|result: (bool, ListTableEntry<L>)|
                            [journal.valid(),
                                    ::builtin::spec_eq(self,
                                        (Self {
                                                m: self.m,
                                                deletes: self.deletes,
                                                deletes_inverse: self.deletes_inverse,
                                                modifications: self.modifications,
                                                ..*old(self)
                                            })),
                                    ({
                                            let (success, new_entry) = result;
                                            if success {
                                                    let next_iv =
                                                        self.internal_view().add_entry(list_addr,
                                                            (new_entry.view()));
                                                    (((::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                                                        (!(self.m.view()).contains_key(list_addr))) &&
                                                                (next_iv.corresponds_to_journal((journal.view()), self.sm)))
                                                        &&
                                                        (match new_entry {
                                                                ListTableEntry::Modified { summary, addrs, elements, .. } =>
                                                                    {
                                                                    (((::builtin::spec_eq(summary.length, addrs.len())) &&
                                                                                        (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                                                                (::builtin::spec_eq((addrs.view()),
                                                                                        (self.tentative_mapping.view()).list_info.spec_index(list_addr))))
                                                                        &&
                                                                        (::builtin::spec_eq((elements.view()),
                                                                                (self.tentative_mapping.view()).list_elements.spec_index(list_addr)))
                                                                }
                                                                _ => false,
                                                            })
                                                } else {
                                                   ((!(journal.view()).pm_constants.impervious_to_corruption())
                                                               && (::builtin::spec_eq(self, old(self)))) &&
                                                       (::builtin::spec_eq(new_entry, entry))
                                               }
                                        })]);
                    let already_complete =
                        match &entry {
                            ListTableEntry::Durable { .. } => false,
                            ListTableEntry::Modified { ref summary, ref addrs, .. } =>
                                addrs.len() == summary.length,
                        };
                    if already_complete {

                            #[verifier::proof_block]
                            {
                                let next_iv =
                                    self.internal_view().add_entry(list_addr, (entry.view()));
                                ::builtin::assert_(::builtin::ext_equal(next_iv,
                                        prev_self.internal_view().complete_entry(list_addr)));
                                prev_self.internal_view().lemma_complete_entry_maintains_correspondence(list_addr,
                                    (journal.view()), self.sm);
                            }
                            return (true, entry);
                        }
                    match entry {
                        ListTableEntry::Durable { summary } => {
                            match self.get_addresses_and_elements_case_durable(list_addr,
                                    &summary, journal,
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] prev_self))
                                {
                                Ok((addrs, elements)) => {
                                    let which_modification = self.modifications.len();

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        ||
                                            {
                                                ::builtin::assert_(::builtin::spec_eq((addrs.view()).skip(::builtin::spec_literal_integer("0")),
                                                        (addrs.view())))
                                            };
                                    };

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        ||
                                            {
                                                ::builtin::assert_(::builtin::spec_eq((elements.view()).skip(::builtin::spec_literal_integer("0")),
                                                        (elements.view())))
                                            };
                                    };
                                    let new_entry =
                                        ListTableEntry::Modified {
                                            which_modification,
                                            durable_head: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0")),
                                            summary,
                                            addrs,
                                            elements,
                                        };
                                    #[verus::internal(spec)]
                                    #[verus::internal(unwrapped_binding)]
                                    let mut verus_tmp;

                                    #[verifier::proof_block]
                                    {
                                        verus_tmp =
                                            ::builtin::spec_cast_integer::<_,
                                                    nat>((self.deletes.view()).len())
                                    };
                                    #[verus::internal(spec)]
                                    let mut which_delete;

                                    #[verifier::proof_block]
                                    {
                                        #[verus::internal(spec)]
                                        let verus_tmp_which_delete = verus_tmp;
                                        which_delete = verus_tmp_which_delete;
                                    };
                                    self.deletes.push(summary);
                                    self.deletes_inverse =
                                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] (self.deletes_inverse.view()).insert(list_addr,
                                                which_delete));
                                    self.modifications.push(Some(list_addr));

                                    #[verifier::proof_block]
                                    {
                                        let next_iv =
                                            self.internal_view().add_entry(list_addr,
                                                (new_entry.view()));
                                        ::builtin::assert_(::builtin::ext_equal(next_iv,
                                                prev_self.internal_view().complete_entry(list_addr)));
                                        prev_self.internal_view().lemma_complete_entry_maintains_correspondence(list_addr,
                                            (journal.view()), self.sm);
                                    }
                                    (true, new_entry)
                                }
                                Err(KvError::CRCMismatch) => { (false, entry) }
                                Err(e) => {

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        || { ::builtin::assert_(false) };
                                    };
                                    (false, entry)
                                }
                            }
                        }
                        ListTableEntry::Modified {
                            which_modification,
                            durable_head,
                            summary,
                            mut addrs,
                            mut elements } => {
                            let num_addrs = addrs.len();

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    { ::builtin::assert_((num_addrs).spec_lt(summary.length)) };
                            };
                            match self.get_addresses_and_elements_case_modified(list_addr,
                                    &summary, journal, num_addrs,
                                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] prev_self))
                                {
                                Ok((mut durable_addrs, mut durable_elements)) => {
                                    durable_addrs.append(&mut addrs);
                                    durable_elements.append(&mut elements);
                                    let new_entry =
                                        ListTableEntry::Modified {
                                            which_modification,
                                            durable_head: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0")),
                                            summary,
                                            addrs: durable_addrs,
                                            elements: durable_elements,
                                        };

                                    #[verifier::proof_block]
                                    {
                                        let next_iv =
                                            self.internal_view().add_entry(list_addr,
                                                (new_entry.view()));
                                        let g_durable_addrs =
                                            (self.durable_mapping.view()).list_info.spec_index((durable_head.view()));
                                        let g_durable_elements =
                                            (self.durable_mapping.view()).list_elements.spec_index((durable_head.view()));
                                        let num_durable_addrs =
                                            (summary.length).spec_sub(num_addrs);
                                        ::builtin::assert_(::builtin::spec_eq((self.tentative_mapping.view()).list_info.spec_index(list_addr).take(num_durable_addrs),
                                                g_durable_addrs.skip((g_durable_addrs.len()).spec_sub(((summary.length).spec_sub(num_addrs))))));
                                        ::builtin::assert_(::builtin::spec_eq((durable_addrs.view()),
                                                prev_self.internal_view().tentative_mapping.list_info.spec_index(list_addr)));
                                        ::builtin::assert_(::builtin::spec_eq((self.tentative_mapping.view()).list_elements.spec_index(list_addr).take(num_durable_addrs),
                                                g_durable_elements.skip((g_durable_elements.len()).spec_sub(((summary.length).spec_sub(num_addrs))))));
                                        ::builtin::assert_(::builtin::spec_eq((durable_elements.view()),
                                                prev_self.internal_view().tentative_mapping.list_elements.spec_index(list_addr)));
                                        ::builtin::assert_(::builtin::ext_equal(next_iv,
                                                prev_self.internal_view().complete_entry(list_addr)));
                                        prev_self.internal_view().lemma_complete_entry_maintains_correspondence(list_addr,
                                            (journal.view()), self.sm);
                                    }
                                    (true, new_entry)
                                }
                                Err(KvError::CRCMismatch) => {
                                    (false,
                                        ListTableEntry::Modified {
                                            which_modification,
                                            durable_head,
                                            summary,
                                            addrs,
                                            elements,
                                        })
                                }
                                Err(e) => {

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        || { ::builtin::assert_(false) };
                                    };
                                    (false,
                                        ListTableEntry::Modified {
                                            which_modification,
                                            durable_head,
                                            summary,
                                            addrs,
                                            elements,
                                        })
                                }
                            }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_normal_case_write_step<PermFactory>(&self,
                    list_addr: u64, idx: usize, new_element: L,
                    entry: &ListTableEntry<L>, new_row_addr: u64,
                    journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>) where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([self.inv((old(journal).view())),
                                ::builtin::is_variant((self.status.view()), "PoppedEntry"),
                                ::builtin::spec_eq(Self::recover((old(journal).view()).durable_state,
                                        (self.durable_mapping.view()).list_elements.dom(),
                                        (self.view()).sm), Some((self.view()).durable)),
                                self.internal_view().add_entry(list_addr,
                                            (entry.view())).push_to_free_list(new_row_addr).corresponds_to_journal((old(journal).view()),
                                    self.sm), old(journal).valid(),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                self.perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory),
                                ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0")) ||
                                    ((old(journal).view()).remaining_capacity).spec_ge(self.space_needed_to_journal_next),
                                match entry {
                                    ListTableEntry::Modified { summary, addrs, elements, .. } =>
                                        {
                                        ((((::builtin::spec_eq(summary.length, addrs.len())) &&
                                                                    (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                                            ((idx).spec_lt(addrs.len()))) &&
                                                    (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(idx)).start(), new_element.start()))) &&
                                            (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(idx)).end(), new_element.end()))
                                    }
                                    _ => false,
                                }]);
                    ::builtin::ensures([journal.valid(),
                                ::builtin::spec_eq((journal.view()).powerpm_id,
                                    (old(journal).view()).powerpm_id),
                                (journal.view()).matches_except_in_range((old(journal).view()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.start()),
                                    ::builtin::spec_cast_integer::<_,
                                            int>((self.view()).sm.end())),
                                ((journal.view()).remaining_capacity).spec_ge(((old(journal).view()).remaining_capacity).spec_sub(self.space_needed_to_journal_next)),
                                ({
                                        let old_iv =
                                            self.internal_view().add_entry(list_addr,
                                                    (entry.view())).push_to_free_list(new_row_addr);
                                        (old_iv.corresponds_to_durable_state((journal.view()).durable_state,
                                                    self.sm)) &&
                                            (old_iv.corresponds_to_durable_state((journal.view()).read_state,
                                                    self.sm))
                                    }),
                                ({
                                        let addrs = ((entry.arrow_Modified_addrs()).view());
                                        let next: u64 =
                                            if ::builtin::spec_eq(idx,
                                                        (addrs.len()).spec_sub(::builtin::spec_literal_nat("1"))) {
                                                    ::builtin::spec_literal_integer("0")
                                                } else {
                                                   addrs.spec_index((idx).spec_add(::builtin::spec_literal_nat("1")))
                                               };
                                        ((::builtin::spec_eq(recover_object::<L>((journal.view()).commit_state,
                                                                (new_row_addr).spec_add(self.sm.row_element_start),
                                                                (new_row_addr).spec_add(self.sm.row_element_crc_start)),
                                                            Some(new_element))) &&
                                                    (::builtin::spec_eq(recover_object::<u64>((journal.view()).commit_state,
                                                                (new_row_addr).spec_add(self.sm.row_next_start),
                                                                ((new_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                            Some(next)))) &&
                                            (::builtin::forall(|other_row_addr: u64|
                                                        ::builtin::imply({
                                                                (self.sm.table.validate_row_addr(other_row_addr)) &&
                                                                    (!::builtin::spec_eq(other_row_addr, new_row_addr))
                                                            },
                                                            {
                                                                ::builtin::spec_eq(recover_object::<L>((journal.view()).commit_state,
                                                                        (other_row_addr).spec_add(self.sm.row_element_start),
                                                                        (other_row_addr).spec_add(self.sm.row_element_crc_start)),
                                                                    recover_object::<L>((old(journal).view()).commit_state,
                                                                        (other_row_addr).spec_add(self.sm.row_element_start),
                                                                        (other_row_addr).spec_add(self.sm.row_element_crc_start)))
                                                            })))
                                    }),
                                if (idx).spec_gt(::builtin::spec_literal_nat("0")) {
                                        let addrs = ((entry.arrow_Modified_addrs()).view());
                                        let prev_row_addr: u64 =
                                            addrs.spec_index((idx).spec_sub(::builtin::spec_literal_nat("1")));
                                        ((::builtin::spec_eq(recover_object::<u64>((journal.view()).commit_state,
                                                                (prev_row_addr).spec_add(self.sm.row_next_start),
                                                                ((prev_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                            Some(new_row_addr))) &&
                                                    (::builtin::forall(|other_row_addr: u64|
                                                                ::builtin::imply({
                                                                        ((self.sm.table.validate_row_addr(other_row_addr)) &&
                                                                                    (!::builtin::spec_eq(other_row_addr, new_row_addr))) &&
                                                                            (!::builtin::spec_eq(other_row_addr, prev_row_addr))
                                                                    },
                                                                    {
                                                                        ::builtin::spec_eq(recover_object::<u64>((journal.view()).commit_state,
                                                                                (other_row_addr).spec_add(self.sm.row_next_start),
                                                                                ((other_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                                            recover_object::<u64>((old(journal).view()).commit_state,
                                                                                (other_row_addr).spec_add(self.sm.row_next_start),
                                                                                ((other_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())))
                                                                    })))) &&
                                            (::builtin::spec_eq((journal.view()).journaled_addrs,
                                                    ((old(journal).view()).journaled_addrs).spec_add(Set::<int>::new(::builtin::closure_to_fn_spec(|i:
                                                                        int|
                                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((prev_row_addr).spec_add(self.sm.row_next_start)),
                                                                                i),
                                                                            (((prev_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of()))))))))
                                    } else {
                                       (::builtin::forall(|other_row_addr: u64|
                                                       ::builtin::imply({
                                                               (self.sm.table.validate_row_addr(other_row_addr)) &&
                                                                   (!::builtin::spec_eq(other_row_addr, new_row_addr))
                                                           },
                                                           {
                                                               ::builtin::spec_eq(recover_object::<u64>((journal.view()).commit_state,
                                                                       (other_row_addr).spec_add(self.sm.row_next_start),
                                                                       ((other_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                                   recover_object::<u64>((old(journal).view()).commit_state,
                                                                       (other_row_addr).spec_add(self.sm.row_next_start),
                                                                       ((other_row_addr).spec_add(self.sm.row_next_start)).spec_add(u64::spec_size_of())))
                                                           }))) &&
                                           (::builtin::spec_eq((journal.view()).journaled_addrs,
                                                   (old(journal).view()).journaled_addrs))
                                   }]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            self.internal_view().add_entry(list_addr,
                                    (entry.view())).push_to_free_list(new_row_addr)
                    };
                    #[verus::internal(spec)]
                    let mut old_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_old_iv = verus_tmp;
                        old_iv = verus_tmp_old_iv;
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(old_iv.m.contains_key(list_addr)) };
                    };

                    #[verifier::proof_block]
                    {
                        journal.lemma_valid_implications();
                        ::builtin::assert_(::builtin::spec_eq(new_row_addr,
                                old_iv.free_list.last()));
                        Self::lemma_writing_to_free_slot_has_permission_later_forall(old_iv,
                            (journal.view()), self.sm,
                            ::builtin::spec_cast_integer::<_,
                                    int>((self.free_list.view()).len()), new_row_addr,
                            *perm_factory);
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_transitive)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    match entry {
                        ListTableEntry::Durable { .. } => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                        }
                        ListTableEntry::Modified { addrs, .. } => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::spec_eq(old_iv.m.spec_index(list_addr),
                                                (entry.view())))
                                    };
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::spec_eq((addrs.view()),
                                                old_iv.tentative_mapping.list_info.spec_index(list_addr)))
                                    };
                            };
                            let element_addr = new_row_addr + self.sm.row_element_start;
                            let element_crc_addr =
                                new_row_addr + self.sm.row_element_crc_start;
                            let element_crc = calculate_crc(&new_element);
                            journal.write_object::<L,
                                PermFactory::Perm>(element_addr, &new_element,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                            journal.write_object::<u64,
                                PermFactory::Perm>(element_crc_addr, &element_crc,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                            let next_addr = new_row_addr + self.sm.row_next_start;
                            let next_crc_addr = next_addr + size_of::<u64>() as u64;
                            let next: u64 =
                                if idx == addrs.len() - 1 { 0 } else { addrs[idx + 1] };
                            let next_crc = calculate_crc(&next);
                            journal.write_object::<u64,
                                PermFactory::Perm>(next_addr, &next,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                            journal.write_object::<u64,
                                PermFactory::Perm>(next_crc_addr, &next_crc,
                                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(old_iv.corresponds_to_durable_state((journal.view()).durable_state,
                                                self.sm))
                                    };
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(old_iv.corresponds_to_durable_state((journal.view()).read_state,
                                                self.sm))
                                    };
                            };

                            #[verifier::proof_block]
                            {
                                lemma_writing_element_and_next_effect_on_recovery::<L>((old(journal).view()).commit_state,
                                    (journal.view()).commit_state, new_row_addr, new_element,
                                    next, self.sm);
                            }

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::forall(|other_row_addr: u64|
                                                    ::builtin::imply({
                                                            (self.sm.table.validate_row_addr(other_row_addr)) &&
                                                                (!::builtin::spec_eq(other_row_addr, new_row_addr))
                                                        },
                                                        {
                                                            ::builtin::spec_eq(recover_object::<L>((journal.view()).commit_state,
                                                                    (other_row_addr).spec_add(self.sm.row_element_start),
                                                                    (other_row_addr).spec_add(self.sm.row_element_crc_start)),
                                                                recover_object::<L>((old(journal).view()).commit_state,
                                                                    (other_row_addr).spec_add(self.sm.row_element_start),
                                                                    (other_row_addr).spec_add(self.sm.row_element_crc_start)))
                                                        })))
                                    };
                            };
                            if idx > 0 {
                                    #[verus::internal(spec)]
                                    #[verus::internal(unwrapped_binding)]
                                    let mut verus_tmp;

                                    #[verifier::proof_block]
                                    { verus_tmp = (journal.view()) };
                                    #[verus::internal(spec)]
                                    let mut jv;

                                    #[verifier::proof_block]
                                    {
                                        #[verus::internal(spec)]
                                        let verus_tmp_jv = verus_tmp;
                                        jv = verus_tmp_jv;
                                    };
                                    let prev_row_addr = addrs[idx - 1];

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        ||
                                            {
                                                ::builtin::assert_(::builtin::spec_eq(prev_row_addr,
                                                        old_iv.tentative_mapping.list_info.spec_index(list_addr).spec_index((idx).spec_sub(::builtin::spec_literal_nat("1")))))
                                            };
                                    };

                                    #[verifier::proof_block]
                                    {

                                        #[verus::internal(const_header_wrapper)]
                                        ||
                                            {
                                                ::builtin::assert_(self.sm.table.validate_row_addr(prev_row_addr))
                                            };
                                    };
                                    let prev_next_addr = prev_row_addr + self.sm.row_next_start;
                                    let prev_next_crc = calculate_crc(&new_row_addr);
                                    let mut bytes_to_write = Vec::<u8>::new();
                                    extend_vec_u8_from_slice(&mut bytes_to_write,
                                        new_row_addr.as_byte_slice());
                                    extend_vec_u8_from_slice(&mut bytes_to_write,
                                        prev_next_crc.as_byte_slice());
                                    match journal.journal_write(prev_next_addr, bytes_to_write)
                                        {
                                        Ok(()) => {}
                                        _ => {

                                            #[verifier::proof_block]
                                            {

                                                #[verus::internal(const_header_wrapper)]
                                                || { ::builtin::assert_(false) };
                                            };
                                        }
                                    }

                                    #[verifier::proof_block]
                                    {
                                        lemma_writing_next_and_crc_together_effect_on_recovery::<L>(jv.commit_state,
                                            (journal.view()).commit_state, prev_row_addr, new_row_addr,
                                            self.sm);
                                    }
                                }
                        }
                    }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                fn lemma_update_normal_case(old_iv: ListTableInternalView<L>,
                    new_iv: ListTableInternalView<L>, list_addr: u64,
                    idx: usize, new_element: L, entry: ListTableEntry<L>,
                    old_jv: JournalView, new_jv: JournalView,
                    sm: ListTableStaticMetadata, new_row_addr: u64,
                    new_list_addr: u64) {
                    ::builtin::requires([sm.valid::<L>(),
                                (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                                sm.corresponds_to_journal(old_jv), old_jv.valid(),
                                old_iv.corresponds_to_journal(old_jv, sm),
                                old_iv.tentative_mapping.list_info.contains_key(list_addr),
                                (idx).spec_lt(old_iv.tentative_mapping.list_info.spec_index(list_addr).len()),
                                ::builtin::spec_eq(new_iv,
                                    old_iv.update(list_addr, idx, new_element)),
                                (::builtin::spec_literal_nat("0")).spec_lt(old_iv.free_list.len()),
                                ::builtin::spec_eq(new_row_addr, old_iv.free_list.last()),
                                ::builtin::spec_eq(new_list_addr,
                                    if ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0"))
                                            {
                                            new_row_addr
                                        } else { list_addr }), old_iv.m.contains_key(list_addr),
                                match old_iv.m.spec_index(list_addr) {
                                    ListTableEntryView::Modified { summary, addrs, elements, ..
                                        } => {
                                        ((((::builtin::spec_eq(summary.length, addrs.len())) &&
                                                                    (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                                            ((idx).spec_lt(addrs.len()))) &&
                                                    (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(idx)).start(), new_element.start()))) &&
                                            (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(idx)).end(), new_element.end()))
                                    }
                                    _ => false,
                                },
                                ({
                                        let addrs =
                                            old_iv.tentative_mapping.list_info.spec_index(list_addr);
                                        let next: u64 =
                                            if ::builtin::spec_eq(idx,
                                                        (addrs.len()).spec_sub(::builtin::spec_literal_nat("1"))) {
                                                    ::builtin::spec_literal_integer("0")
                                                } else {
                                                   addrs.spec_index((idx).spec_add(::builtin::spec_literal_nat("1")))
                                               };
                                        let prev_row_addr: u64 =
                                            if ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0"))
                                                    {
                                                    ::builtin::spec_literal_integer("0")
                                                } else {
                                                   addrs.spec_index((idx).spec_sub(::builtin::spec_literal_nat("1")))
                                               };
                                        ((::builtin::spec_eq(recover_object::<L>(new_jv.commit_state,
                                                                (new_row_addr).spec_add(sm.row_element_start),
                                                                (new_row_addr).spec_add(sm.row_element_crc_start)),
                                                            Some(new_element))) &&
                                                    (::builtin::spec_eq(recover_object::<u64>(new_jv.commit_state,
                                                                (new_row_addr).spec_add(sm.row_next_start),
                                                                ((new_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                            Some(next)))) &&
                                            (::builtin::forall(|other_row_addr: u64|
                                                        ::builtin::imply({
                                                                (sm.table.validate_row_addr(other_row_addr)) &&
                                                                    (!::builtin::spec_eq(other_row_addr, new_row_addr))
                                                            },
                                                            {
                                                                ::builtin::spec_eq(recover_object::<L>(new_jv.commit_state,
                                                                        (other_row_addr).spec_add(sm.row_element_start),
                                                                        (other_row_addr).spec_add(sm.row_element_crc_start)),
                                                                    recover_object::<L>(old_jv.commit_state,
                                                                        (other_row_addr).spec_add(sm.row_element_start),
                                                                        (other_row_addr).spec_add(sm.row_element_crc_start)))
                                                            })))
                                    }),
                                ({
                                        let elements =
                                            old_iv.tentative_mapping.list_elements.spec_index(list_addr);
                                        (((idx).spec_lt(elements.len())) &&
                                                    (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(idx)).start(), new_element.start()))) &&
                                            (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(idx)).end(), new_element.end()))
                                    }),
                                if (idx).spec_gt(::builtin::spec_literal_nat("0")) {
                                        let addrs =
                                            old_iv.tentative_mapping.list_info.spec_index(list_addr);
                                        let prev_row_addr: u64 =
                                            addrs.spec_index((idx).spec_sub(::builtin::spec_literal_nat("1")));
                                        ((::builtin::spec_eq(recover_object::<u64>(new_jv.commit_state,
                                                                (prev_row_addr).spec_add(sm.row_next_start),
                                                                ((prev_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                            Some(new_row_addr))) &&
                                                    (::builtin::forall(|other_row_addr: u64|
                                                                ::builtin::imply({
                                                                        ((sm.table.validate_row_addr(other_row_addr)) &&
                                                                                    (!::builtin::spec_eq(other_row_addr, new_row_addr))) &&
                                                                            (!::builtin::spec_eq(other_row_addr, prev_row_addr))
                                                                    },
                                                                    {
                                                                        ::builtin::spec_eq(recover_object::<u64>(new_jv.commit_state,
                                                                                (other_row_addr).spec_add(sm.row_next_start),
                                                                                ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                                            recover_object::<u64>(old_jv.commit_state,
                                                                                (other_row_addr).spec_add(sm.row_next_start),
                                                                                ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())))
                                                                    })))) &&
                                            (::builtin::spec_eq(new_jv.journaled_addrs,
                                                    (old_jv.journaled_addrs).spec_add(Set::<int>::new(::builtin::closure_to_fn_spec(|i:
                                                                        int|
                                                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value((prev_row_addr).spec_add(sm.row_next_start)),
                                                                                i),
                                                                            (((prev_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of()))))))))
                                    } else {
                                       (::builtin::forall(|other_row_addr: u64|
                                                       ::builtin::imply({
                                                               (sm.table.validate_row_addr(other_row_addr)) &&
                                                                   (!::builtin::spec_eq(other_row_addr, new_row_addr))
                                                           },
                                                           {
                                                               ::builtin::spec_eq(recover_object::<u64>(new_jv.commit_state,
                                                                       (other_row_addr).spec_add(sm.row_next_start),
                                                                       ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                                   recover_object::<u64>(old_jv.commit_state,
                                                                       (other_row_addr).spec_add(sm.row_next_start),
                                                                       ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())))
                                                           }))) &&
                                           (::builtin::spec_eq(new_jv.journaled_addrs,
                                                   old_jv.journaled_addrs))
                                   }]);
                    ::builtin::ensures([new_iv.valid(sm),
                                new_iv.corresponds_to_tentative_state(new_jv.commit_state,
                                    sm),
                                new_iv.consistent_with_journaled_addrs(new_jv.journaled_addrs,
                                    sm),
                                ::builtin::spec_eq(new_iv.tentative_mapping.as_snapshot(),
                                    old_iv.tentative_mapping.as_snapshot().update_element_at_index(list_addr,
                                        new_list_addr, idx, new_element)),
                                ({
                                        let old_list =
                                            old_iv.tentative_mapping.as_snapshot().m.spec_index(list_addr);
                                        (((idx).spec_lt(old_list.len())) &&
                                                    (::builtin::spec_eq(old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(idx)).start(), new_element.start()))) &&
                                            (::builtin::spec_eq(old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(idx)).end(), new_element.end()))
                                    })]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_update_bytes_effect)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    old_iv.lemma_update_works(list_addr, idx, new_element, sm);
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                fn update_normal_case<PermFactory>(&mut self, list_addr: u64,
                    idx: usize, new_element: L, entry: ListTableEntry<L>,
                    journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>) -> u64 where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).inv((old(journal).view())),
                                !(old(self).must_abort.view()),
                                ::builtin::is_variant((old(self).status.view()),
                                    "PoppedEntry"),
                                old(self).internal_view().add_entry(list_addr,
                                        (entry.view())).corresponds_to_journal((old(journal).view()),
                                    old(self).sm),
                                !(old(self).m.view()).contains_key(list_addr),
                                old(journal).valid(),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory),
                                ::builtin::spec_eq(idx, ::builtin::spec_literal_nat("0")) ||
                                    ((old(journal).view()).remaining_capacity).spec_ge(old(self).space_needed_to_journal_next),
                                (old(self).free_list.len()).spec_gt(::builtin::spec_literal_nat("0")),
                                !::builtin::spec_eq(list_addr,
                                        ::builtin::spec_literal_nat("0")),
                                match entry {
                                    ListTableEntry::Modified { summary, addrs, elements, .. } =>
                                        {
                                        ((((::builtin::spec_eq(summary.length, addrs.len())) &&
                                                                    (::builtin::spec_eq(addrs.len(), elements.len()))) &&
                                                            ((idx).spec_lt(addrs.len()))) &&
                                                    (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                            int>(idx)).start(), new_element.start()))) &&
                                            (::builtin::spec_eq(elements.spec_index(::builtin::spec_cast_integer::<_,
                                                                    int>(idx)).end(), new_element.end()))
                                    }
                                    _ => false,
                                }]);
                    ::builtin::ensures(|new_list_addr: u64|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    ((journal.view()).remaining_capacity).spec_ge(((old(journal).view()).remaining_capacity).spec_sub(self.space_needed_to_journal_next)),
                                    !::builtin::spec_eq(new_list_addr,
                                            ::builtin::spec_literal_nat("0")),
                                    ::builtin::spec_eq(new_list_addr, list_addr) ||
                                        ::builtin::spec_eq(new_list_addr,
                                            (old(self).free_list.view()).last()),
                                    ::builtin::spec_eq((self.view()),
                                        (ListTableView {
                                                tentative: Some((old(self).view()).tentative.unwrap().update_element_at_index(list_addr,
                                                        new_list_addr, idx, new_element)),
                                                used_slots: (self.view()).used_slots,
                                                ..(old(self).view())
                                            })),
                                    ((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1"))),
                                    self.validate_list_addr(new_list_addr),
                                    ({
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            (((idx).spec_lt(old_list.len())) &&
                                                        (::builtin::spec_eq(old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                                int>(idx)).start(), new_element.start()))) &&
                                                (::builtin::spec_eq(old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                        int>(idx)).end(), new_element.end()))
                                        })]);
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    {
                        verus_tmp =
                            self.internal_view().add_entry(list_addr, (entry.view()))
                    };
                    #[verus::internal(spec)]
                    let mut old_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_old_iv = verus_tmp;
                        old_iv = verus_tmp_old_iv;
                    };
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = old_iv.update(list_addr, idx, new_element) };
                    #[verus::internal(spec)]
                    let mut new_iv;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_new_iv = verus_tmp;
                        new_iv = verus_tmp_new_iv;
                    };

                    #[verifier::proof_block]
                    {
                        old_iv.durable_mapping.lemma_corresponds_implies_equals_new((journal.view()).durable_state,
                            old_iv.durable_mapping.list_elements.dom(), self.sm);
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    let new_row_addr =
                        match self.free_list.pop() {
                            Some(a) => a,
                            None => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                0
                            }
                        };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(new_row_addr,
                                        old_iv.free_list.last()))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(new_row_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    self.update_normal_case_write_step::<PermFactory>(list_addr,
                        idx, new_element, &entry, new_row_addr, journal,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory));
                    self.tentative_mapping =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.tentative_mapping);
                    self.row_info =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] new_iv.row_info);
                    self.pending_allocations.push(new_row_addr);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        || { ::builtin::assert_(old_iv.m.contains_key(list_addr)) };
                    };
                    let new_head =
                        if idx == 0 { new_row_addr } else { list_addr };
                    let (which_modification, old_row_addr) =
                        match &entry {
                            ListTableEntry::Durable { .. } => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                (0usize, 0u64)
                            }
                            ListTableEntry::Modified {
                                ref which_modification, ref addrs, .. } =>
                                (*which_modification, addrs[idx]),
                        };
                    self.pending_deallocations.push(old_row_addr);
                    if idx == 0 {
                            self.modifications.set(which_modification,
                                Some(new_row_addr));
                        } else {

                           #[verifier::proof_block]
                           {

                               #[verus::internal(const_header_wrapper)]
                               ||
                                   {
                                       ::builtin::assert_(::builtin::spec_eq(self.modifications.spec_index(::builtin::spec_cast_integer::<_,
                                                           int>(which_modification)), Some(list_addr)))
                                   };
                           };
                       }
                    let new_entry =
                        entry.update(idx, new_row_addr, new_element);
                    self.m.insert(new_head, new_entry);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(old(self).internal_view().m,
                                        old_iv.m.remove(list_addr)))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal((new_entry.view()),
                                        new_iv.m.spec_index(new_head)))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::spec_eq(self.internal_view().m,
                                        old_iv.m.remove(list_addr).insert(new_head,
                                            (new_entry.view()))))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view().m,
                                        new_iv.m))
                            };
                    };

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                        new_iv))
                            };
                    };
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ListTableStatus::Quiescent);

                    #[verifier::proof_block]
                    {
                        Self::lemma_update_normal_case(old_iv, new_iv, list_addr,
                            idx, new_element, entry, (old(journal).view()),
                            (journal.view()), self.sm, new_row_addr, new_head);
                    }
                    new_head
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub fn update<PermFactory>(&mut self, list_addr: u64,
                    idx: usize, new_element: L, journal: &mut Journal<PM>,
                    verus_tmp_perm_factory: Tracked<&PermFactory>)
                    -> Result<u64, KvError> where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    #[verus::internal(header_unwrap_parameter)]
                    let perm_factory;

                    #[verifier::proof_block]
                    { perm_factory = verus_tmp_perm_factory.get() };
                    ::builtin::requires([old(self).valid((old(journal).view())),
                                old(journal).valid(),
                                ::builtin::is_variant((old(self).view()).tentative, "Some"),
                                (old(self).view()).tentative.unwrap().m.contains_key(list_addr),
                                ::builtin::spec_eq(perm_factory.id(),
                                    (old(journal).view()).powerpm_id),
                                old(self).perm_factory_permits_states_equivalent_for_me((old(journal).view()),
                                    *perm_factory)]);
                    ::builtin::ensures(|result: Result<u64, KvError>|
                            [self.valid((journal.view())), journal.valid(),
                                    ::builtin::spec_eq((journal.view()).powerpm_id,
                                        (old(journal).view()).powerpm_id),
                                    (journal.view()).matches_except_in_range((old(journal).view()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.start()),
                                        ::builtin::spec_cast_integer::<_,
                                                int>((self.view()).sm.end())),
                                    match result {
                                        Ok(new_list_addr) => {
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            ((((((((!::builtin::spec_eq(new_list_addr,
                                                                                                                    ::builtin::spec_literal_nat("0"))) &&
                                                                                                        (::builtin::spec_eq(new_list_addr, list_addr) ||
                                                                                                                !(old(self).view()).tentative.unwrap().m.contains_key(new_list_addr)))
                                                                                                && ((idx).spec_lt(old_list.len()))) &&
                                                                                        (::builtin::spec_eq(old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                                int>(idx)).start(), new_element.start()))) &&
                                                                                (::builtin::spec_eq(old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                        int>(idx)).end(), new_element.end()))) &&
                                                                        (::builtin::spec_eq((self.view()),
                                                                                (ListTableView {
                                                                                        tentative: Some((old(self).view()).tentative.unwrap().update_element_at_index(list_addr,
                                                                                                new_list_addr, idx, new_element)),
                                                                                        used_slots: (self.view()).used_slots,
                                                                                        ..(old(self).view())
                                                                                    })))) &&
                                                                (((self.view()).used_slots).spec_le(((old(self).view()).used_slots).spec_add(::builtin::spec_literal_nat("1")))))
                                                        && (self.validate_list_addr(new_list_addr))) &&
                                                (((journal.view()).remaining_capacity).spec_ge(((((old(journal).view()).remaining_capacity).spec_sub(spec_journal_entry_overhead())).spec_sub(u64::spec_size_of())).spec_sub(u64::spec_size_of())))
                                        }
                                        Err(KvError::IndexOutOfRange { upper_bound }) => {
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            (((::builtin::spec_eq((self.view()), (old(self).view()))) &&
                                                                ((idx).spec_ge(old_list.len()))) &&
                                                        (::builtin::spec_eq(upper_bound, old_list.len()))) &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::LogicalRangeUpdateNotAllowed {
                                            old_start, old_end, new_start, new_end }) => {
                                            let old_list =
                                                (old(self).view()).tentative.unwrap().m.spec_index(list_addr);
                                            (((((((::builtin::spec_eq((self.view()),
                                                                                                        (old(self).view()))) && ((idx).spec_lt(old_list.len()))) &&
                                                                                        (::builtin::spec_eq(old_start,
                                                                                                old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                                int>(idx)).start()))) &&
                                                                                (::builtin::spec_eq(old_end,
                                                                                        old_list.spec_index(::builtin::spec_cast_integer::<_,
                                                                                                        int>(idx)).end()))) &&
                                                                        (::builtin::spec_eq(new_start, new_element.start()))) &&
                                                                (::builtin::spec_eq(new_end, new_element.end()))) &&
                                                        (!::builtin::spec_eq(old_start, new_start) ||
                                                                !::builtin::spec_eq(old_end, new_end))) &&
                                                (::builtin::spec_eq((journal.view()).remaining_capacity,
                                                        (old(journal).view()).remaining_capacity))
                                        }
                                        Err(KvError::OutOfSpace) => {
                                            (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                                &&
                                                ({
                                                        (((old(journal).view()).remaining_capacity).spec_lt(((spec_journal_entry_overhead()).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of())))
                                                            ||
                                                            (::builtin::spec_eq((self.view()).used_slots,
                                                                    (self.view()).sm.num_rows()))
                                                    })
                                        }
                                        Err(KvError::CRCMismatch) => {
                                            (!(journal.view()).pm_constants.impervious_to_corruption())
                                                &&
                                                (::builtin::spec_eq((self.view()),
                                                        (ListTableView { tentative: None, ..(old(self).view()) })))
                                        }
                                        _ => false,
                                    }]);

                    #[verifier::proof_block]
                    {
                        self.lemma_valid_implications((journal.view()));
                        journal.lemma_valid_implications();
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(group_hash_axioms)
                                    }

                                    #[verus::internal(broadcast_use_reveal)]
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1);
                        }
                    }
                    if self.free_list.len() == 0 {
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                    if idx != 0 &&
                                journal.remaining_capacity() <
                                    self.space_needed_to_journal_next {
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);
                            return Err(KvError::OutOfSpace);
                        }
                    let entry =
                        match self.m.remove(&list_addr) {
                            None => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                return Err(KvError::InternalError);
                            }
                            Some(e) => e,
                        };
                    let (success, new_entry) =
                        self.complete_entry(list_addr, entry, journal,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] *old(self)));
                    if !success {
                            self.m.insert(list_addr, new_entry);
                            self.must_abort =
                                #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true);

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal((self.m.view()),
                                                (old(self).m.view())))
                                    };
                            };
                            return Err(KvError::CRCMismatch);
                        }
                    let result: Result<(), KvError> =
                        match &new_entry {
                            ListTableEntry::Durable { .. } => {

                                #[verifier::proof_block]
                                {

                                    #[verus::internal(const_header_wrapper)]
                                    || { ::builtin::assert_(false) };
                                };
                                Err(KvError::InternalError)
                            }
                            ListTableEntry::Modified { ref addrs, ref elements, .. } =>
                                {
                                if addrs.len() <= idx {
                                        Err(KvError::IndexOutOfRange { upper_bound: addrs.len() })
                                    } else {
                                       let current_element = elements[idx];
                                       if current_element.start() != new_element.start() ||
                                                   current_element.end() != new_element.end() {
                                               Err(KvError::LogicalRangeUpdateNotAllowed {
                                                       old_start: current_element.start(),
                                                       old_end: current_element.end(),
                                                       new_start: new_element.start(),
                                                       new_end: new_element.end(),
                                                   })
                                           } else { Ok(()) }
                                   }
                            }
                        };
                    match result {
                        Ok(()) => {}
                        Err(e) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = self.internal_view() };
                            #[verus::internal(spec)]
                            let mut old_iv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_iv = verus_tmp;
                                old_iv = verus_tmp_old_iv;
                            };
                            self.m.insert(list_addr, new_entry);

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(::builtin::ext_equal(self.internal_view(),
                                                old_iv.add_entry(list_addr, (new_entry.view()))))
                                    };
                            };
                            return Err(e);
                        }
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_by(!::builtin::spec_eq(list_addr,
                                                ::builtin::spec_literal_nat("0")),
                                        {
                                            {
                                                ::builtin::reveal_hide_({
                                                        #[verus::internal(reveal_fn)]
                                                        fn __VERUS_REVEAL_INTERNAL__() {
                                                            ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                        }

                                                        #[verus::internal(broadcast_use_reveal)]
                                                        __VERUS_REVEAL_INTERNAL__
                                                    }, 1);
                                            }
                                        });
                                }
                            };
                    }
                    self.status =
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ListTableStatus::PoppedEntry);
                    Ok(self.update_normal_case::<PermFactory>(list_addr, idx,
                            new_element, new_entry, journal,
                            #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory)))
                }
            }
        }
        pub mod util_v {
            #![allow(unused_imports)]
            use builtin::*;
            use builtin_macros::*;
            use vstd::prelude::*;
            use crate::common::recover_v::*;
            use crate::common::subrange_v::*;
            use crate::common::table_v::*;
            use crate::journal::*;
            use crate::pmem::pmemspec_t::*;
            use crate::pmem::pmcopy_t::*;
            use crate::pmem::power_t::*;
            use super::impl_v::*;
            use super::inv_v::*;
            use super::super::spec_t::*;
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_writing_element_and_next_effect_on_recovery<L>(s1:
                    Seq<u8>, s5: Seq<u8>, row_addr: u64, element: L, next: u64,
                sm: ListTableStaticMetadata) where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                ::builtin::requires([sm.valid::<L>(),
                            (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                            (sm.end()).spec_le(s1.len()),
                            sm.table.validate_row_addr(row_addr),
                            ({
                                    let s2 =
                                        update_bytes(s1, (row_addr).spec_add(sm.row_element_start),
                                            element.spec_to_bytes());
                                    let s3 =
                                        update_bytes(s2,
                                            (row_addr).spec_add(sm.row_element_crc_start),
                                            spec_crc_bytes(element.spec_to_bytes()));
                                    let s4 =
                                        update_bytes(s3, (row_addr).spec_add(sm.row_next_start),
                                            next.spec_to_bytes());
                                    ::builtin::spec_eq(s5,
                                        update_bytes(s4,
                                            ((row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of()),
                                            spec_crc_bytes(next.spec_to_bytes())))
                                })]);
                ::builtin::ensures([::builtin::forall(|other_row_addr: u64|
                                    ::builtin::imply({
                                            (sm.table.validate_row_addr(other_row_addr)) &&
                                                (!::builtin::spec_eq(other_row_addr, row_addr))
                                        },
                                        {
                                            (::builtin::spec_eq(recover_object::<L>(s5,
                                                            (other_row_addr).spec_add(sm.row_element_start),
                                                            (other_row_addr).spec_add(sm.row_element_crc_start)),
                                                        recover_object::<L>(s1,
                                                            (other_row_addr).spec_add(sm.row_element_start),
                                                            (other_row_addr).spec_add(sm.row_element_crc_start)))) &&
                                                (::builtin::spec_eq(recover_object::<u64>(s5,
                                                            (other_row_addr).spec_add(sm.row_next_start),
                                                            ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                                        recover_object::<u64>(s1,
                                                            (other_row_addr).spec_add(sm.row_next_start),
                                                            ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of()))))
                                        })),
                            ::builtin::spec_eq(recover_object::<L>(s5,
                                    (row_addr).spec_add(sm.row_element_start),
                                    (row_addr).spec_add(sm.row_element_crc_start)),
                                Some(element)),
                            ::builtin::spec_eq(recover_object::<u64>(s5,
                                    (row_addr).spec_add(sm.row_next_start),
                                    ((row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                Some(next))]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_writing_next_and_crc_together_effect_on_recovery<L>(s1:
                    Seq<u8>, s2: Seq<u8>, row_addr: u64, next: u64,
                sm: ListTableStaticMetadata) where L: PmCopy + LogicalRange +
                Sized + std::fmt::Debug {
                ::builtin::requires([sm.valid::<L>(),
                            (::builtin::spec_literal_nat("0")).spec_lt(sm.start()),
                            (sm.end()).spec_le(s1.len()),
                            sm.table.validate_row_addr(row_addr),
                            ::builtin::spec_eq(s2,
                                update_bytes(s1, (row_addr).spec_add(sm.row_next_start),
                                    (next.spec_to_bytes()).spec_add(spec_crc_bytes(next.spec_to_bytes()))))]);
                ::builtin::ensures([::builtin::spec_eq(recover_object::<u64>(s2,
                                    (row_addr).spec_add(sm.row_next_start),
                                    ((row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                Some(next)),
                            ::builtin::forall(|other_row_addr: u64|
                                    ::builtin::imply({
                                            (sm.table.validate_row_addr(other_row_addr)) &&
                                                (!::builtin::spec_eq(other_row_addr, row_addr))
                                        },
                                        ::builtin::spec_eq(recover_object::<u64>(s2,
                                                (other_row_addr).spec_add(sm.row_next_start),
                                                ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of())),
                                            recover_object::<u64>(s1,
                                                (other_row_addr).spec_add(sm.row_next_start),
                                                ((other_row_addr).spec_add(sm.row_next_start)).spec_add(u64::spec_size_of()))))),
                            ::builtin::forall(|any_row_addr: u64|
                                    ::builtin::imply(sm.table.validate_row_addr(any_row_addr),
                                        ::builtin::spec_eq(recover_object::<L>(s2,
                                                (any_row_addr).spec_add(sm.row_element_start),
                                                (any_row_addr).spec_add(sm.row_element_crc_start)),
                                            recover_object::<L>(s1,
                                                (any_row_addr).spec_add(sm.row_element_start),
                                                (any_row_addr).spec_add(sm.row_element_crc_start)))))]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_update_bytes_effect)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                let next_addr = (row_addr).spec_add(sm.row_next_start);
                let bytes_written =
                    (next.spec_to_bytes()).spec_add(spec_crc_bytes(next.spec_to_bytes()));
                lemma_subrange_subrange(s2,
                    ::builtin::spec_cast_integer::<_, int>(next_addr),
                    ((next_addr).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of()),
                    ::builtin::spec_cast_integer::<_, int>(next_addr),
                    (next_addr).spec_add(u64::spec_size_of()));
                lemma_subrange_subrange(s2,
                    ::builtin::spec_cast_integer::<_, int>(next_addr),
                    ((next_addr).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of()),
                    (next_addr).spec_add(u64::spec_size_of()),
                    ((next_addr).spec_add(u64::spec_size_of())).spec_add(u64::spec_size_of()));
                ::builtin::assert_(::builtin::ext_equal(bytes_written.subrange(::builtin::spec_literal_integer("0"),
                            ::builtin::spec_cast_integer::<_,
                                    int>(u64::spec_size_of())), next.spec_to_bytes()));
                ::builtin::assert_(::builtin::ext_equal(bytes_written.subrange(::builtin::spec_cast_integer::<_,
                                    int>(u64::spec_size_of()),
                            ::builtin::spec_cast_integer::<_,
                                    int>(((u64::spec_size_of()).spec_add(u64::spec_size_of())))),
                        spec_crc_bytes(next.spec_to_bytes())));
                ::builtin::assert_(::builtin::ext_equal(recover_object::<u64>(s2,
                            next_addr, (next_addr).spec_add(u64::spec_size_of())),
                        Some(next)));
            }
            #[verus::internal(verus_macro)]
            impl<PM, L> ListTable<PM, L> where PM: PersistentMemoryRegion,
                L: PmCopy + LogicalRange + Sized + std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_writing_to_free_slot_doesnt_change_recovery(iv:
                        ListTableInternalView<L>, s1: Seq<u8>, s2: Seq<u8>,
                    sm: ListTableStaticMetadata, free_list_pos: int,
                    row_addr: u64, start: int, end: int) {
                    ::builtin::requires([sm.valid::<L>(), iv.valid(sm),
                                iv.corresponds_to_durable_state(s1, sm),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            free_list_pos), iv.free_list.len())),
                                ::builtin::spec_eq(iv.free_list.spec_index(free_list_pos),
                                    row_addr), sm.table.validate_row_addr(row_addr),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                start), end), (row_addr).spec_add(sm.table.row_size))),
                                seqs_match_except_in_range(s1, s2, start, end)]);
                    ::builtin::ensures([iv.corresponds_to_durable_state(s2, sm),
                                ::builtin::spec_eq(Self::recover(s2,
                                        iv.durable_mapping.list_elements.dom(), sm),
                                    Self::recover(s1, iv.durable_mapping.list_elements.dom(),
                                        sm))]);
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                    ::builtin::assert_(::builtin::is_variant(iv.row_info.spec_index(row_addr),
                            "InFreeList"));
                    ::builtin::assert_(iv.corresponds_to_durable_state(s2, sm));
                    let list_addrs = iv.durable_mapping.list_elements.dom();
                    iv.durable_mapping.lemma_corresponds_implies_equals_new(s1,
                        list_addrs, sm);
                    iv.durable_mapping.lemma_corresponds_implies_equals_new(s2,
                        list_addrs, sm);
                    ::builtin::assert_(::builtin::ext_equal(Self::recover(s2,
                                list_addrs, sm), Self::recover(s1, list_addrs, sm)));
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(proof)]
                pub(super) fn lemma_writing_to_free_slot_has_permission_later_forall<PermFactory>(iv:
                        ListTableInternalView<L>, initial_jv: JournalView,
                    sm: ListTableStaticMetadata, free_list_pos: int,
                    row_addr: u64, perm_factory: PermFactory) where
                    PermFactory: PermissionFactory<Seq<u8>> {
                    ::builtin::requires([sm.valid::<L>(), iv.valid(sm),
                                iv.corresponds_to_durable_state(initial_jv.durable_state,
                                    sm),
                                iv.corresponds_to_durable_state(initial_jv.read_state, sm),
                                Journal::<PM>::state_recovery_idempotent(initial_jv.durable_state,
                                    initial_jv.constants),
                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            free_list_pos), iv.free_list.len())),
                                ::builtin::spec_eq(iv.free_list.spec_index(free_list_pos),
                                    row_addr), sm.table.validate_row_addr(row_addr),
                                (sm.table.end).spec_le(initial_jv.durable_state.len()),
                                ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                        ::builtin::imply({
                                                (Self::state_equivalent_for_me(s1, initial_jv.durable_state,
                                                            iv.durable_mapping.list_elements.dom(),
                                                            initial_jv.constants, sm)) &&
                                                    (Self::state_equivalent_for_me(s2, initial_jv.durable_state,
                                                            iv.durable_mapping.list_elements.dom(),
                                                            initial_jv.constants, sm))
                                            },
                                            #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                s2)))]);
                    ::builtin::ensures([::builtin::forall(|current_durable_state:
                                            Seq<u8>, new_durable_state: Seq<u8>, start: int, end: int|
                                        ::builtin::with_triggers(((seqs_match_except_in_range(current_durable_state,
                                                        new_durable_state, start, end),),),
                                            ::builtin::imply({
                                                    ((((seqs_match_except_in_range(current_durable_state,
                                                                                        new_durable_state, start, end)) &&
                                                                                (Self::state_equivalent_for_me(current_durable_state,
                                                                                        initial_jv.durable_state,
                                                                                        iv.durable_mapping.list_elements.dom(),
                                                                                        initial_jv.constants, sm))) &&
                                                                        (iv.corresponds_to_durable_state(current_durable_state,
                                                                                sm))) &&
                                                                (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                                                    start), end), (row_addr).spec_add(sm.table.row_size))))) &&
                                                        (Journal::<PM>::state_recovery_idempotent(new_durable_state,
                                                                initial_jv.constants))
                                                },
                                                {
                                                    ((Self::state_equivalent_for_me(new_durable_state,
                                                                        initial_jv.durable_state,
                                                                        iv.durable_mapping.list_elements.dom(),
                                                                        initial_jv.constants, sm)) &&
                                                                (iv.corresponds_to_durable_state(new_durable_state, sm))) &&
                                                        (perm_factory.check_permission(current_durable_state,
                                                                new_durable_state))
                                                }))),
                                ::builtin::forall(|current_read_state: Seq<u8>, start: int,
                                        bytes: Seq<u8>|
                                        ::builtin::with_triggers(((update_bytes(current_read_state,
                                                        start, bytes),),),
                                            ::builtin::imply({
                                                    let new_read_state =
                                                        update_bytes(current_read_state, start, bytes);
                                                    (((seqs_match_except_in_range(initial_jv.read_state,
                                                                                current_read_state,
                                                                                ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                                                                ::builtin::spec_cast_integer::<_, int>(sm.end()))) &&
                                                                        (iv.corresponds_to_durable_state(current_read_state, sm)))
                                                                && ((row_addr).spec_le(start))) &&
                                                        (((start).spec_add(bytes.len())).spec_le((row_addr).spec_add(sm.table.row_size)))
                                                },
                                                {
                                                    let new_read_state =
                                                        update_bytes(current_read_state, start, bytes);
                                                    (iv.corresponds_to_durable_state(new_read_state, sm)) &&
                                                        (seqs_match_except_in_range(initial_jv.read_state,
                                                                new_read_state,
                                                                ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                                                ::builtin::spec_cast_integer::<_, int>(sm.end())))
                                                })))]);
                    {
                        ::builtin::assert_forall_by(|current_durable_state: Seq<u8>,
                                new_durable_state: Seq<u8>, start: int, end: int|
                                {
                                    ::builtin::requires(::builtin::with_triggers(((seqs_match_except_in_range(current_durable_state,
                                                        new_durable_state, start, end),),),
                                            {
                                                ((((seqs_match_except_in_range(current_durable_state,
                                                                                    new_durable_state, start, end)) &&
                                                                            (Self::state_equivalent_for_me(current_durable_state,
                                                                                    initial_jv.durable_state,
                                                                                    iv.durable_mapping.list_elements.dom(),
                                                                                    initial_jv.constants, sm))) &&
                                                                    (iv.corresponds_to_durable_state(current_durable_state,
                                                                            sm))) &&
                                                            (::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(row_addr),
                                                                                start), end), (row_addr).spec_add(sm.table.row_size))))) &&
                                                    (Journal::<PM>::state_recovery_idempotent(new_durable_state,
                                                            initial_jv.constants))
                                            }));
                                    ::builtin::ensures({
                                            ((Self::state_equivalent_for_me(new_durable_state,
                                                                initial_jv.durable_state,
                                                                iv.durable_mapping.list_elements.dom(),
                                                                initial_jv.constants, sm)) &&
                                                        (iv.corresponds_to_durable_state(new_durable_state, sm))) &&
                                                (perm_factory.check_permission(current_durable_state,
                                                        new_durable_state))
                                        });
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    Self::lemma_writing_to_free_slot_doesnt_change_recovery(iv,
                                        current_durable_state, new_durable_state, sm, free_list_pos,
                                        row_addr, start, end);
                                });
                    }
                    {
                        ::builtin::assert_forall_by(|current_read_state: Seq<u8>,
                                start: int, bytes: Seq<u8>|
                                {
                                    ::builtin::requires(::builtin::with_triggers(((update_bytes(current_read_state,
                                                        start, bytes),),),
                                            {
                                                let new_read_state =
                                                    update_bytes(current_read_state, start, bytes);
                                                (((seqs_match_except_in_range(initial_jv.read_state,
                                                                            current_read_state,
                                                                            ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                                                            ::builtin::spec_cast_integer::<_, int>(sm.end()))) &&
                                                                    (iv.corresponds_to_durable_state(current_read_state, sm)))
                                                            && ((row_addr).spec_le(start))) &&
                                                    (((start).spec_add(bytes.len())).spec_le((row_addr).spec_add(sm.table.row_size)))
                                            }));
                                    ::builtin::ensures({
                                            let new_read_state =
                                                update_bytes(current_read_state, start, bytes);
                                            (iv.corresponds_to_durable_state(new_read_state, sm)) &&
                                                (seqs_match_except_in_range(initial_jv.read_state,
                                                        new_read_state,
                                                        ::builtin::spec_cast_integer::<_, int>(sm.start()),
                                                        ::builtin::spec_cast_integer::<_, int>(sm.end())))
                                        });
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(group_validate_row_addr)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    {
                                        ::builtin::reveal_hide_({
                                                #[verus::internal(reveal_fn)]
                                                fn __VERUS_REVEAL_INTERNAL__() {
                                                    ::builtin::reveal_hide_internal_path_(broadcast_update_bytes_effect)
                                                }

                                                #[verus::internal(broadcast_use_reveal)]
                                                __VERUS_REVEAL_INTERNAL__
                                            }, 1);
                                    }
                                    let new_read_state =
                                        update_bytes(current_read_state, start, bytes);
                                    Self::lemma_writing_to_free_slot_doesnt_change_recovery(iv,
                                        current_read_state, new_read_state, sm, free_list_pos,
                                        row_addr, start, (start).spec_add(bytes.len()));
                                });
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl ListSummary {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub(super) fn default() -> Self {
                    Self {
                        head: 0,
                        tail: 0,
                        length: 0,
                        end_of_logical_range: 0,
                    }
                }
            }
            #[verus::internal(verus_macro)]
            impl<L> ListTableEntry<L> where L: PmCopy + LogicalRange + Sized +
                std::fmt::Debug {
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub(super) fn default() -> Self {
                    Self::Durable { summary: ListSummary::default() }
                }
                #[verus::internal(verus_macro)]
                #[verus::internal(exec)]
                pub(super) fn unwrap_durable(self) -> ListSummary {
                    ::builtin::requires([::builtin::is_variant(self,
                                    "Durable")]);
                    ::builtin::ensures(|result: ListSummary|
                            [::builtin::spec_eq(self,
                                        (Self::Durable { summary: result }))]);
                    match self {
                        ListTableEntry::Durable { summary } => summary,
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            ListSummary::default()
                        }
                    }
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_push_commutes_with_skip<T>(s: Seq<T>,
                skip_amount: int, pushed_element: T) {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        skip_amount), s.len()))]);
                ::builtin::ensures([::builtin::spec_eq(s.skip(skip_amount).push(pushed_element),
                                s.push(pushed_element).skip(skip_amount))]);
                ::builtin::assert_(::builtin::ext_equal(s.skip(skip_amount).push(pushed_element),
                        s.push(pushed_element).skip(skip_amount)));
            }
        }
        pub use impl_v::{ListTable, ListTableStaticMetadata};
        pub use spec_v::{ListTableSnapshot, ListTableView};
    }
    pub mod recover_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::recover_v::*;
        use crate::common::subrange_v::*;
        use crate::common::util_v::*;
        use crate::journal::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::traits_t::*;
        use crate::pmem::power_t::*;
        use deps_hack::PmCopy;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::items::*;
        use super::keys::*;
        use super::lists::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        pub const KVSTORE_PROGRAM_GUID: u128 =
            0x256e549674024fd4880381d8010e6f54;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        pub const KVSTORE_PROGRAM_VERSION_NUMBER: u64 = 1;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_encode_policies(logical_range_gaps_policy:
                LogicalRangeGapsPolicy) -> u64 {
            match logical_range_gaps_policy {
                LogicalRangeGapsPolicy::LogicalRangeGapsForbidden =>
                    ::builtin::spec_literal_integer("0"),
                LogicalRangeGapsPolicy::LogicalRangeGapsPermitted =>
                    ::builtin::spec_literal_integer("1"),
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_decode_policies(encoded_policy: u64)
            -> Option<LogicalRangeGapsPolicy> {
            if ::builtin::spec_eq(encoded_policy,
                        ::builtin::spec_literal_nat("0")) {
                    Some(LogicalRangeGapsPolicy::LogicalRangeGapsForbidden)
                } else if ::builtin::spec_eq(encoded_policy,
                       ::builtin::spec_literal_nat("1")) {
                   Some(LogicalRangeGapsPolicy::LogicalRangeGapsPermitted)
               } else { None }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn encode_policies(logical_range_gaps_policy:
                &LogicalRangeGapsPolicy) -> u64 {
            ::builtin::ensures(|result: u64|
                    [::builtin::spec_eq(result,
                                spec_encode_policies(*logical_range_gaps_policy))]);
            match logical_range_gaps_policy {
                LogicalRangeGapsPolicy::LogicalRangeGapsForbidden => 0,
                LogicalRangeGapsPolicy::LogicalRangeGapsPermitted => 1,
            }
        }
        #[verifier::when_used_as_spec(spec_decode_policies)]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn decode_policies(encoded_policy: u64)
            -> Option<LogicalRangeGapsPolicy> {
            ::builtin::ensures(|result: Option<LogicalRangeGapsPolicy>|
                    [::builtin::spec_eq(result,
                                spec_decode_policies(encoded_policy))]);
            if encoded_policy == 0 {
                    Some(LogicalRangeGapsPolicy::LogicalRangeGapsForbidden)
                } else if encoded_policy == 1 {
                   Some(LogicalRangeGapsPolicy::LogicalRangeGapsPermitted)
               } else { None }
        }
        #[repr(C)]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct KvStaticMetadata {
            pub id: u128,
            pub encoded_policies: u64,
            pub max_keys: u64,
            pub max_list_elements: u64,
            pub max_operations_per_transaction: u64,
            pub keys: KeyTableStaticMetadata,
            pub items: ItemTableStaticMetadata,
            pub lists: ListTableStaticMetadata,
        }
        unsafe impl pmcopy for KvStaticMetadata where u128: pmcopy,
            u64: pmcopy, u64: pmcopy, u64: pmcopy, u64: pmcopy,
            KeyTableStaticMetadata: pmcopy, ItemTableStaticMetadata: pmcopy,
            ListTableStaticMetadata: pmcopy {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for KvStaticMetadata {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                let offset: ::builtin::nat =
                    ::builtin::spec_literal_integer("0");
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u128>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <u64>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<KeyTableStaticMetadata>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <KeyTableStaticMetadata>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<ItemTableStaticMetadata>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <ItemTableStaticMetadata>::spec_align_of()));
                let offset: ::builtin::nat =
                    ((offset).spec_add(<ListTableStaticMetadata>::spec_size_of())).spec_add(spec_padding_needed(offset,
                            <ListTableStaticMetadata>::spec_align_of()));
                let offset: ::builtin::nat =
                    (offset).spec_add(spec_padding_needed(offset,
                            <KvStaticMetadata>::spec_align_of()));
                offset
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                let alignment_seq =
                    <_ as
                            ::vstd::vstd::view::View>::view(&[<u128>::spec_align_of(),
                                    <u64>::spec_align_of(), <u64>::spec_align_of(),
                                    <u64>::spec_align_of(), <u64>::spec_align_of(),
                                    <KeyTableStaticMetadata>::spec_align_of(),
                                    <ItemTableStaticMetadata>::spec_align_of(),
                                    <ListTableStaticMetadata>::spec_align_of()]);
                nat_seq_max(alignment_seq)
            }
        }
        unsafe impl PmSized for KvStaticMetadata {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for KvStaticMetadata {
            const SIZE: usize =
                {
                    let offset: usize = 0;
                    let offset: usize =
                        offset + <u128>::SIZE +
                            padding_needed(offset, <u128>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                    let offset: usize =
                        offset + <KeyTableStaticMetadata>::SIZE +
                            padding_needed(offset, <KeyTableStaticMetadata>::ALIGN);
                    let offset: usize =
                        offset + <ItemTableStaticMetadata>::SIZE +
                            padding_needed(offset, <ItemTableStaticMetadata>::ALIGN);
                    let offset: usize =
                        offset + <ListTableStaticMetadata>::SIZE +
                            padding_needed(offset, <ListTableStaticMetadata>::ALIGN);
                    let offset: usize =
                        offset + padding_needed(offset, <KvStaticMetadata>::ALIGN);
                    offset
                };
            const ALIGN: usize =
                {
                    let mut largest_alignment: usize = 0;
                    if largest_alignment <= <u128>::ALIGN {
                            largest_alignment = <u128>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <u64>::ALIGN {
                            largest_alignment = <u64>::ALIGN;
                        }
                    if largest_alignment <= <KeyTableStaticMetadata>::ALIGN {
                            largest_alignment = <KeyTableStaticMetadata>::ALIGN;
                        }
                    if largest_alignment <= <ItemTableStaticMetadata>::ALIGN {
                            largest_alignment = <ItemTableStaticMetadata>::ALIGN;
                        }
                    if largest_alignment <= <ListTableStaticMetadata>::ALIGN {
                            largest_alignment = <ListTableStaticMetadata>::ALIGN;
                        }
                    largest_alignment
                };
        }
        const SIZE_CHECK_KVSTATICMETADATA: usize =
            (core::mem::size_of::<KvStaticMetadata>() ==
                            <KvStaticMetadata>::SIZE) as usize - 1;
        const ALIGN_CHECK_KVSTATICMETADATA: usize =
            (core::mem::align_of::<KvStaticMetadata>() ==
                            <KvStaticMetadata>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for KvStaticMetadata {}
        impl Clone for KvStaticMetadata {
            fn clone(&self) -> Self {
                Self {
                    id: self.id.clone(),
                    encoded_policies: self.encoded_policies.clone(),
                    max_keys: self.max_keys.clone(),
                    max_list_elements: self.max_list_elements.clone(),
                    max_operations_per_transaction: self.max_operations_per_transaction.clone(),
                    keys: self.keys.clone(),
                    items: self.items.clone(),
                    lists: self.lists.clone(),
                }
            }
        }
        impl PartialEq for KvStaticMetadata {
            fn eq(&self, other: &Self) -> bool {
                self.id == other.id &&
                                            self.encoded_policies == other.encoded_policies &&
                                        self.max_keys == other.max_keys &&
                                    self.max_list_elements == other.max_list_elements &&
                                self.max_operations_per_transaction ==
                                    other.max_operations_per_transaction &&
                            self.keys == other.keys && self.items == other.items &&
                    self.lists == other.lists
            }
        }
        impl Eq for KvStaticMetadata {}
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_kvstaticmetadata_clone(b: &KvStaticMetadata)
            -> KvStaticMetadata {
            ::builtin::ensures(|res: KvStaticMetadata|
                    [::builtin::spec_eq(*b, res)]);
            b.clone()
        }
        #[verifier::external_fn_specification]
        #[verus::internal(verus_macro)]
        pub fn ex_kvstaticmetadata_eq(lhs: &KvStaticMetadata,
            rhs: &KvStaticMetadata) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
            lhs.eq(rhs)
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for KvStaticMetadata {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> KvStaticMetadata {
                ::builtin::ensures(|res: KvStaticMetadata|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for KvStaticMetadata {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self.eq(other)
            }
        }
        impl PmCopy for KvStaticMetadata {}
        #[automatically_derived]
        impl ::core::marker::Copy for KvStaticMetadata { }
        #[verus::internal(verus_macro)]
        impl KvStaticMetadata {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid<K, I, L>(self) -> bool where K: Hash + Eq + Clone +
                PmCopy + std::fmt::Debug, I: PmCopy + std::fmt::Debug,
                L: PmCopy + LogicalRange + std::fmt::Debug + Copy {
                ((((((((((((self.keys.valid::<K>()) &&
                                                                                                            (self.items.valid::<I>())) && (self.lists.valid::<L>())) &&
                                                                                            (::builtin::spec_eq(self.keys.num_rows(),
                                                                                                    self.items.num_rows()))) &&
                                                                                    ((self.keys.end()).spec_le(self.items.start()))) &&
                                                                            ((self.items.end()).spec_le(self.lists.start()))) &&
                                                                    ((self.keys.num_rows()).spec_ge(self.max_keys))) &&
                                                            ((self.items.num_rows()).spec_ge(self.max_keys))) &&
                                                    ((self.lists.num_rows()).spec_ge(self.max_list_elements)))
                                            &&
                                            (::builtin::is_variant(decode_policies(self.encoded_policies),
                                                    "Some"))) &&
                                    ((::builtin::spec_literal_nat("0")).spec_lt(self.max_keys)))
                            &&
                            ((::builtin::spec_literal_nat("0")).spec_lt(self.max_list_elements)))
                    &&
                    ((::builtin::spec_literal_nat("0")).spec_lt(self.max_operations_per_transaction))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn setup_parameters(self) -> Option<SetupParameters> {
                match decode_policies(self.encoded_policies) {
                    None => None,
                    Some(policy) =>
                        Some(SetupParameters {
                                kvstore_id: self.id,
                                logical_range_gaps_policy: policy,
                                max_keys: self.max_keys,
                                max_list_elements: self.max_list_elements,
                                max_operations_per_transaction: self.max_operations_per_transaction,
                            }),
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn validate_static_metadata<K, I,
            L>(sm: KvStaticMetadata, jc: JournalConstants) -> bool where
            K: Hash + Eq + Clone + PmCopy + std::fmt::Debug, I: PmCopy +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
            Copy {
            (((((((sm.valid::<K, I, L>()) &&
                                                                ((((jc.app_area_start).spec_add(KvStaticMetadata::spec_size_of())).spec_add(u64::spec_size_of())).spec_le(sm.keys.start())))
                                                        && ((sm.keys.start()).spec_le(sm.keys.end()))) &&
                                                ((sm.keys.end()).spec_le(sm.items.start()))) &&
                                        ((sm.items.start()).spec_le(sm.items.end()))) &&
                                ((sm.items.end()).spec_le(sm.lists.start()))) &&
                        ((sm.lists.start()).spec_le(sm.lists.end()))) &&
                ((sm.lists.end()).spec_le(jc.app_area_end))
        }
        #[verifier::opaque]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_static_metadata<K, I,
            L>(bytes: Seq<u8>, jc: JournalConstants)
            -> Option<KvStaticMetadata> where K: Hash + Eq + Clone + PmCopy +
            std::fmt::Debug, I: PmCopy + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            if (((jc.app_area_start).spec_add(KvStaticMetadata::spec_size_of())).spec_add(u64::spec_size_of())).spec_gt(jc.app_area_end)
                    {
                    None
                } else {
                   match recover_object::<KvStaticMetadata>(bytes,
                           ::builtin::spec_cast_integer::<_, int>(jc.app_area_start),
                           (jc.app_area_start).spec_add(KvStaticMetadata::spec_size_of()))
                       {
                       None => None,
                       Some(sm) =>
                           if validate_static_metadata::<K, I, L>(sm, jc) {
                                   Some(sm)
                               } else { None },
                   }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_kv_from_keys_items_and_lists<K, I,
            L>(sm: KvStaticMetadata, keys: Map<K, KeyTableRowMetadata>,
            items: Map<u64, I>, lists: Map<u64, Seq<L>>)
            -> Option<RecoveredKvStore<K, I, L>> where K: Hash + Eq + Clone +
            PmCopy + std::fmt::Debug, I: PmCopy + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            match sm.setup_parameters() {
                None => None,
                Some(ps) =>
                    Some(RecoveredKvStore::<K, I,
                            L> {
                            ps,
                            kv: AtomicKvStore::<K, I,
                                L> {
                                logical_range_gaps_policy: ps.logical_range_gaps_policy,
                                m: Map::<K,
                                        (I,
                                        Seq<L>)>::new(::builtin::closure_to_fn_spec(|k: K|
                                            keys.dom().contains(k)),
                                    ::builtin::closure_to_fn_spec(|k: K|
                                            (items.spec_index(keys.spec_index(k).item_addr),
                                                if ::builtin::spec_eq(keys.spec_index(k).list_addr,
                                                            ::builtin::spec_literal_nat("0")) {
                                                        Seq::<L>::empty()
                                                    } else { lists.spec_index(keys.spec_index(k).list_addr) }))),
                            },
                        }),
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_kv_from_static_metadata<PM, K, I,
            L>(bytes: Seq<u8>, sm: KvStaticMetadata)
            -> Option<RecoveredKvStore<K, I, L>> where
            PM: PersistentMemoryRegion, K: Hash + Eq + Clone + PmCopy +
            std::fmt::Debug, I: PmCopy + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            match KeyTable::<PM, K>::recover(bytes, sm.keys) {
                None => None,
                Some(keys) => {
                    match ItemTable::<PM,
                                I>::recover(bytes, keys.item_addrs(), sm.items) {
                        None => None,
                        Some(items) =>
                            match ListTable::<PM,
                                        L>::recover(bytes, keys.list_addrs(), sm.lists) {
                                None => None,
                                Some(lists) =>
                                    recover_kv_from_keys_items_and_lists::<K, I,
                                            L>(sm, keys.key_info, items.m, lists.m),
                            },
                    }
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_kv<PM, K, I,
            L>(bytes: Seq<u8>, jc: JournalConstants)
            -> Option<RecoveredKvStore<K, I, L>> where
            PM: PersistentMemoryRegion, K: Hash + Eq + Clone + PmCopy +
            std::fmt::Debug, I: PmCopy + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            if !::builtin::spec_eq(jc.app_program_guid, KVSTORE_PROGRAM_GUID)
                    {
                    None
                } else if !::builtin::spec_eq(jc.app_version_number,
                           KVSTORE_PROGRAM_VERSION_NUMBER) {
                   None
               } else {
                   match recover_static_metadata::<K, I, L>(bytes, jc) {
                       None => None,
                       Some(sm) =>
                           if (jc.journal_capacity).spec_lt((sm.max_operations_per_transaction).spec_mul(spec_space_needed_for_transaction_operation()))
                                   {
                                   None
                               } else if ::builtin::is_variant(sm.setup_parameters(),
                                      "None") {
                                  None
                              } else if !sm.setup_parameters().unwrap().valid() {
                                  None
                              } else {
                                  recover_kv_from_static_metadata::<PM, K, I, L>(bytes, sm)
                              },
                   }
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn recover_journal_then_kv<PM, K, I, L>(bytes: Seq<u8>)
            -> Option<RecoveredKvStore<K, I, L>> where
            PM: PersistentMemoryRegion, K: Hash + Eq + Clone + PmCopy +
            std::fmt::Debug, I: PmCopy + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            match Journal::<PM>::recover(bytes) {
                None => None,
                Some(RecoveredJournal { constants, state }) =>
                    recover_kv::<PM, K, I, L>(state, constants),
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn states_match_in_static_metadata_area(s1: Seq<u8>,
            s2: Seq<u8>, jc: JournalConstants) -> bool {
            seqs_match_in_range(s1, s2,
                ::builtin::spec_cast_integer::<_, int>(jc.app_area_start),
                ((jc.app_area_start).spec_add(KvStaticMetadata::spec_size_of())).spec_add(u64::spec_size_of()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub(super) fn lemma_recover_static_metadata_depends_only_on_its_area<K,
            I, L>(s1: Seq<u8>, s2: Seq<u8>, jc: JournalConstants) where
            K: Hash + Eq + Clone + PmCopy + std::fmt::Debug, I: PmCopy +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
            Copy {
            ::builtin::requires([states_match_in_static_metadata_area(s1, s2,
                            jc)]);
            ::builtin::ensures([::builtin::spec_eq(recover_static_metadata::<K,
                                    I, L>(s2, jc),
                            recover_static_metadata::<K, I, L>(s1, jc))]);
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            }
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(recover_static_metadata)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub(super) fn combine_component_snapshots<K, I,
            L>(logical_range_gaps_policy: LogicalRangeGapsPolicy,
            keys: KeyTableSnapshot<K>, items: ItemTableSnapshot<I>,
            lists: ListTableSnapshot<L>) -> AtomicKvStore<K, I, L> where
            K: Hash + Eq + Clone + PmCopy + std::fmt::Debug, I: PmCopy +
            std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
            Copy {
            AtomicKvStore::<K, I,
                L> {
                logical_range_gaps_policy,
                m: Map::<K,
                        (I,
                        Seq<L>)>::new(::builtin::closure_to_fn_spec(|k: K|
                            keys.key_info.dom().contains(k)),
                    ::builtin::closure_to_fn_spec(|k: K|
                            (items.m.spec_index(keys.key_info.spec_index(k).item_addr),
                                if ::builtin::spec_eq(keys.key_info.spec_index(k).list_addr,
                                            ::builtin::spec_literal_nat("0")) {
                                        Seq::<L>::empty()
                                    } else {
                                       lists.m.spec_index(keys.key_info.spec_index(k).list_addr)
                                   }))),
            }
        }
    }
    pub mod rwkv_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::concurrentspec_t::*;
        use super::impl_v::*;
        use super::spec_t::*;
        use vstd::pcm::frac::*;
        use vstd::rwlock::{RwLock, RwLockPredicate};
        #[verifier::reject_recursive_types(K)]
        #[verifier::reject_recursive_types(I)]
        #[verifier::reject_recursive_types(L)]
        #[verus::internal(verus_macro)]
        struct ConcurrentKvStoreInternal<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            invariant_resource: Tracked<GhostVarAuth<ConcurrentKvStoreView<K,
            I, L>>>,
            kv: UntrustedKvStoreImpl<PermFactory, PM, K, I, L>,
        }
        #[verus::internal(verus_macro)]
        struct ConcurrentKvStorePredicate {
            id: int,
            powerpm_id: int,
        }
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            RwLockPredicate<ConcurrentKvStoreInternal<PermFactory, PM, K, I,
            L>> for ConcurrentKvStorePredicate where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn inv(self,
                v: ConcurrentKvStoreInternal<PermFactory, PM, K, I, L>)
                -> bool {
                (((((((((v.kv.valid()) && ((v.kv.view()).ps.valid())) &&
                                                                            (::builtin::spec_eq((v.kv.view()).used_key_slots,
                                                                                    (v.kv.view()).durable.num_keys()))) &&
                                                                    (::builtin::spec_eq((v.kv.view()).used_list_element_slots,
                                                                            (v.kv.view()).durable.num_list_elements()))) &&
                                                            (::builtin::spec_eq((v.kv.view()).used_transaction_operation_slots,
                                                                    ::builtin::spec_literal_nat("0")))) &&
                                                    (::builtin::spec_eq((v.kv.view()).durable,
                                                            (v.kv.view()).tentative))) &&
                                            (::builtin::spec_eq((v.kv.view()).ps.logical_range_gaps_policy,
                                                    (v.kv.view()).durable.logical_range_gaps_policy))) &&
                                    (::builtin::spec_eq(self.id,
                                            (v.invariant_resource.view()).id()))) &&
                            (::builtin::spec_eq(self.powerpm_id,
                                    (v.kv.view()).powerpm_id))) &&
                    (::builtin::spec_eq(((v.invariant_resource.view()).view()),
                            ConcurrentKvStoreView::from_kvstore_view((v.kv.view()))))
            }
        }
        #[verifier::reject_recursive_types(K)]
        #[verifier::reject_recursive_types(I)]
        #[verifier::reject_recursive_types(L)]
        #[verus::internal(verus_macro)]
        pub struct ConcurrentKvStore<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            pm_constants: Ghost<PersistentMemoryConstants>,
            id: Ghost<int>,
            lock: RwLock<ConcurrentKvStoreInternal<PermFactory, PM, K, I, L>,
            ConcurrentKvStorePredicate>,
        }
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L> CanRecover<K, I, L> for
            ConcurrentKvStore<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn recover(s: Seq<u8>) -> Option<RecoveredKvStore<K, I, L>> {
                UntrustedKvStoreImpl::<PermFactory, PM, K, I, L>::recover(s)
            }
        }
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            ConcurrentKvStore<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                ::builtin::spec_eq((self.id.view()), self.lock.pred().id)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn id(self) -> int { (self.id.view()) }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn pm_constants(self) -> PersistentMemoryConstants {
                (self.pm_constants.view())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn powerpm_id(self) -> int { self.lock.pred().powerpm_id }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_space_needed_for_setup(ps: SetupParameters) -> nat {
                UntrustedKvStoreImpl::<PermFactory, PM, K, I,
                        L>::spec_space_needed_for_setup(ps)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn spec_space_needed_for_transaction_operation() -> nat {
                spec_space_needed_for_transaction_operation()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn space_needed_for_setup(ps: &SetupParameters)
                -> Result<u64, KvError> {
                ::builtin::ensures(|result: Result<u64, KvError>|
                        [match result {
                                    Ok(v) =>
                                        ::builtin::spec_eq(v,
                                            Self::spec_space_needed_for_setup(*ps)),
                                    Err(KvError::InvalidParameter) => !ps.valid(),
                                    Err(KvError::OutOfSpace) =>
                                        (Self::spec_space_needed_for_setup(*ps)).spec_gt(u64::MAX),
                                    Err(_) => false,
                                }]);
                UntrustedKvStoreImpl::<PermFactory, PM, K, I,
                        L>::space_needed_for_setup(ps)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn setup(pm: &mut PM, ps: &SetupParameters)
                -> Result<(), KvError> {
                ::builtin::requires([old(pm).inv()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [pm.inv(),
                                ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                match result {
                                    Ok(()) => {
                                        ((pm.view()).flush_predicted()) &&
                                            (::builtin::spec_eq(Self::recover((pm.view()).durable_state),
                                                    Some(RecoveredKvStore::<K, I, L>::init(*ps))))
                                    }
                                    Err(KvError::InvalidParameter) => !ps.valid(),
                                    Err(KvError::KeySizeTooSmall) =>
                                        ::builtin::spec_eq(K::spec_size_of(),
                                            ::builtin::spec_literal_nat("0")),
                                    Err(KvError::OutOfSpace) =>
                                        ((pm.view()).len()).spec_lt(Self::spec_space_needed_for_setup(*ps)),
                                    Err(_) => false,
                                }]);
                UntrustedKvStoreImpl::<PermFactory, PM, K, I,
                        L>::setup(pm, ps)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn start(powerpm: PoWERPersistentMemoryRegion<PM>,
                kvstore_id: u128,
                verus_tmp_state: Ghost<RecoveredKvStore<K, I, L>>,
                verus_tmp_perm_factory: Tracked<PermFactory>)
                ->
                    Result<(Self,
                    Tracked<GhostVar<ConcurrentKvStoreView<K, I, L>>>),
                    KvError> {
                #[verus::internal(header_unwrap_parameter)]
                let state;

                #[verifier::proof_block]
                { state = verus_tmp_state.view() };
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([powerpm.inv(),
                            ::builtin::spec_eq(Self::recover((powerpm.view()).durable_state),
                                Some(state)), vstd::std_specs::hash::obeys_key_model::<K>(),
                            ::builtin::spec_eq(perm_factory.id(), powerpm.id()),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(::builtin::spec_eq(Self::recover(s1),
                                            Self::recover(s2)),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures(|result:
                            Result<(Self,
                            Tracked<GhostVar<ConcurrentKvStoreView<K, I, L>>>),
                            KvError>|
                        [({
                                        match result {
                                            Ok((kv, r)) => {
                                                (((((((kv.valid()) &&
                                                                                                    (::builtin::spec_eq(kv.id(), (r.view()).id()))) &&
                                                                                            (::builtin::spec_eq(kv.pm_constants(),
                                                                                                    powerpm.constants()))) &&
                                                                                    (::builtin::spec_eq(kv.powerpm_id(), powerpm.id()))) &&
                                                                            (((r.view()).view()).valid())) &&
                                                                    (::builtin::spec_eq(((r.view()).view()).ps, state.ps))) &&
                                                            (::builtin::spec_eq(((r.view()).view()).pm_constants,
                                                                    powerpm.constants()))) &&
                                                    (::builtin::spec_eq(((r.view()).view()).kv, state.kv))
                                            }
                                            Err(KvError::CRCMismatch) =>
                                                !powerpm.constants().impervious_to_corruption(),
                                            Err(KvError::WrongKvStoreId { requested_id, actual_id }) =>
                                                {
                                                (::builtin::spec_eq(requested_id, kvstore_id)) &&
                                                    (::builtin::spec_eq(actual_id, state.ps.kvstore_id))
                                            }
                                            Err(KvError::KeySizeTooSmall) =>
                                                ::builtin::spec_eq(K::spec_size_of(),
                                                    ::builtin::spec_literal_nat("0")),
                                            Err(_) => false,
                                        }
                                    })]);
                let kv =
                    match UntrustedKvStoreImpl::<PermFactory, PM, K, I,
                                L>::start(powerpm, kvstore_id,
                            #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] state),
                            #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory))
                        {
                        Ok(kv) => kv,
                        Err(e) => { return Err(e); }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv.view()))
                };
                #[verus::internal(spec)]
                let mut ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_ckv = verus_tmp;
                    ckv = verus_tmp_ckv;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = powerpm.constants() };
                #[verus::internal(spec)]
                let mut pm_constants;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_pm_constants = verus_tmp;
                    pm_constants = verus_tmp_pm_constants;
                };
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        GhostVarAuth::<ConcurrentKvStoreView<K, I, L>>::new(ckv)
                };
                #[verus::internal(infer_mode)]
                let mut invariant_resource;
                #[verus::internal(infer_mode)]
                let mut application_resource;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let (verus_tmp_invariant_resource,
                            verus_tmp_application_resource) = verus_tmp;
                    invariant_resource = verus_tmp_invariant_resource;
                    application_resource = verus_tmp_application_resource;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = invariant_resource.id() };
                #[verus::internal(spec)]
                let mut id;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_id = verus_tmp;
                    id = verus_tmp_id;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStorePredicate {
                            id: id,
                            powerpm_id: (kv.view()).powerpm_id,
                        }
                };
                #[verus::internal(spec)]
                let mut pred;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_pred = verus_tmp;
                    pred = verus_tmp_pred;
                };
                let kv_internal =
                    ConcurrentKvStoreInternal::<PermFactory, PM, K, I,
                        L> {
                        invariant_resource: #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] invariant_resource),
                        kv,
                    };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    || { ::builtin::assert_(pred.inv(kv_internal)) };
                };
                let lock =
                    RwLock::<ConcurrentKvStoreInternal<PermFactory, PM, K, I,
                            L>,
                            ConcurrentKvStorePredicate>::new(kv_internal,
                        #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] pred));
                let selfish =
                    Self {
                        pm_constants: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] pm_constants),
                        id: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] id),
                        lock,
                    };
                Ok((selfish,
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] application_resource)))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_item<CB>(&self, key: &K, verus_tmp_cb: Tracked<CB>)
                -> (Result<I, KvError>, Tracked<CB::Completion>) where
                CB: ReadLinearizer<K, I, L, ReadItemOp<K>> {
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            cb.pre(self.id(), ReadItemOp { key: *key })]);
                ::builtin::ensures(|result:
                            (Result<I, KvError>, Tracked<CB::Completion>)|
                        [self.valid(),
                                cb.post((result.1.view()), self.id(),
                                    ReadItemOp { key: *key }, result.0)]);
                let read_handle = self.lock.acquire_read();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = ReadItemOp { key: *key } };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let kv_internal = read_handle.borrow();
                let result = kv_internal.kv.read_item(key);
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = kv_internal.invariant_resource.borrow() };
                #[verus::internal(infer_mode)]
                let mut invariant_resource;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_invariant_resource = verus_tmp;
                    invariant_resource = verus_tmp_invariant_resource;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                { completion = cb.apply(op, result, invariant_resource); }
                read_handle.release_read();
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_keys<CB: ReadLinearizer<K, I, L,
                GetKeysOp>>(&self, verus_tmp_cb: Tracked<CB>)
                -> (Result<Vec<K>, KvError>, Tracked<CB::Completion>) {
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            cb.pre(self.id(), GetKeysOp {})]);
                ::builtin::ensures(|result:
                            (Result<Vec<K>, KvError>, Tracked<CB::Completion>)|
                        [self.valid(),
                                cb.post((result.1.view()), self.id(), GetKeysOp {},
                                    result.0)]);
                let read_handle = self.lock.acquire_read();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = GetKeysOp {} };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let kv_internal = read_handle.borrow();
                let result = kv_internal.kv.get_keys();
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = kv_internal.invariant_resource.borrow() };
                #[verus::internal(infer_mode)]
                let mut invariant_resource;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_invariant_resource = verus_tmp;
                    invariant_resource = verus_tmp_invariant_resource;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                { completion = cb.apply(op, result, invariant_resource); }
                read_handle.release_read();
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_item_and_list<CB: ReadLinearizer<K, I, L,
                ReadItemAndListOp<K>>>(&self, key: &K,
                verus_tmp_cb: Tracked<CB>)
                -> (Result<(I, Vec<L>), KvError>, Tracked<CB::Completion>) {
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            cb.pre(self.id(), ReadItemAndListOp { key: *key })]);
                ::builtin::ensures(|result:
                            (Result<(I, Vec<L>), KvError>, Tracked<CB::Completion>)|
                        [self.valid(),
                                cb.post((result.1.view()), self.id(),
                                    ReadItemAndListOp { key: *key }, result.0)]);
                let read_handle = self.lock.acquire_read();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = ReadItemAndListOp { key: *key } };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let kv_internal = read_handle.borrow();
                let result = kv_internal.kv.read_item_and_list(key);
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = kv_internal.invariant_resource.borrow() };
                #[verus::internal(infer_mode)]
                let mut invariant_resource;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_invariant_resource = verus_tmp;
                    invariant_resource = verus_tmp_invariant_resource;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                { completion = cb.apply(op, result, invariant_resource); }
                read_handle.release_read();
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn read_list<CB: ReadLinearizer<K, I, L,
                ReadListOp<K>>>(&self, key: &K, verus_tmp_cb: Tracked<CB>)
                -> (Result<Vec<L>, KvError>, Tracked<CB::Completion>) {
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            cb.pre(self.id(), ReadListOp { key: *key })]);
                ::builtin::ensures(|result:
                            (Result<Vec<L>, KvError>, Tracked<CB::Completion>)|
                        [self.valid(),
                                cb.post((result.1.view()), self.id(),
                                    ReadListOp { key: *key }, result.0)]);
                let read_handle = self.lock.acquire_read();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = ReadListOp { key: *key } };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let kv_internal = read_handle.borrow();
                let result = kv_internal.kv.read_list(key);
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = kv_internal.invariant_resource.borrow() };
                #[verus::internal(infer_mode)]
                let mut invariant_resource;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_invariant_resource = verus_tmp;
                    invariant_resource = verus_tmp_invariant_resource;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                { completion = cb.apply(op, result, invariant_resource); }
                read_handle.release_read();
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_list_length<CB: ReadLinearizer<K, I, L,
                GetListLengthOp<K>>>(&self, key: &K,
                verus_tmp_cb: Tracked<CB>)
                -> (Result<usize, KvError>, Tracked<CB::Completion>) {
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            cb.pre(self.id(), GetListLengthOp { key: *key })]);
                ::builtin::ensures(|result:
                            (Result<usize, KvError>, Tracked<CB::Completion>)|
                        [self.valid(),
                                cb.post((result.1.view()), self.id(),
                                    GetListLengthOp { key: *key }, result.0)]);
                let read_handle = self.lock.acquire_read();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = GetListLengthOp { key: *key } };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let kv_internal = read_handle.borrow();
                let result = kv_internal.kv.get_list_length(key);
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = kv_internal.invariant_resource.borrow() };
                #[verus::internal(infer_mode)]
                let mut invariant_resource;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_invariant_resource = verus_tmp;
                    invariant_resource = verus_tmp_invariant_resource;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                { completion = cb.apply(op, result, invariant_resource); }
                read_handle.release_read();
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn create<Perm,
                CB>(&self, key: &K, item: &I, verus_tmp_perm: Tracked<Perm>,
                verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L, CreateOp<K, I>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(), CreateOp { key: *key, item: *item }),
                            grants_permission_to_mutate::<Perm, K, I, L, CreateOp<K, I>,
                                    Self>(perm, CreateOp { key: *key, item: *item },
                                self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    CreateOp { key: *key, item: *item }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = CreateOp::<K, I> { key: *key, item: *item } };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_create(key, item) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn update_item<Perm,
                CB>(&self, key: &K, item: &I, verus_tmp_perm: Tracked<Perm>,
                verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L, UpdateItemOp<K, I>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(), UpdateItemOp { key: *key, item: *item }),
                            grants_permission_to_mutate::<Perm, K, I, L,
                                    UpdateItemOp<K, I>,
                                    Self>(perm, UpdateItemOp { key: *key, item: *item },
                                self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    UpdateItemOp { key: *key, item: *item }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp = UpdateItemOp::<K, I> { key: *key, item: *item }
                };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_update_item(key, item) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn delete<Perm,
                CB>(&self, key: &K, verus_tmp_perm: Tracked<Perm>,
                verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L, DeleteOp<K>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(), DeleteOp { key: *key }),
                            grants_permission_to_mutate::<Perm, K, I, L, DeleteOp<K>,
                                    Self>(perm, DeleteOp { key: *key }, self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    DeleteOp { key: *key }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = DeleteOp::<K> { key: *key } };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_delete(key) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn append_to_list<Perm,
                CB>(&self, key: &K, new_list_element: L,
                verus_tmp_perm: Tracked<Perm>, verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L, AppendToListOp<K, L>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(),
                                AppendToListOp { key: *key, new_list_element }),
                            grants_permission_to_mutate::<Perm, K, I, L,
                                    AppendToListOp<K, L>,
                                    Self>(perm, AppendToListOp { key: *key, new_list_element },
                                self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    AppendToListOp { key: *key, new_list_element }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        AppendToListOp::<K, L> { key: *key, new_list_element }
                };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_append_to_list(key,
                            new_list_element) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn append_to_list_and_update_item<Perm,
                CB>(&self, key: &K, new_list_element: L, new_item: &I,
                verus_tmp_perm: Tracked<Perm>, verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L,
                AppendToListAndUpdateItemOp<K, I, L>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(),
                                AppendToListAndUpdateItemOp {
                                    key: *key,
                                    new_list_element,
                                    new_item: *new_item,
                                }),
                            grants_permission_to_mutate::<Perm, K, I, L,
                                    AppendToListAndUpdateItemOp<K, I, L>,
                                    Self>(perm,
                                AppendToListAndUpdateItemOp {
                                    key: *key,
                                    new_list_element,
                                    new_item: *new_item,
                                }, self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    AppendToListAndUpdateItemOp {
                                        key: *key,
                                        new_list_element,
                                        new_item: *new_item,
                                    }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        AppendToListAndUpdateItemOp::<K, I,
                            L> { key: *key, new_list_element, new_item: *new_item }
                };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_append_to_list_and_update_item(key,
                            new_list_element, new_item) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn update_list_element_at_index<Perm,
                CB>(&self, key: &K, idx: usize, new_list_element: L,
                verus_tmp_perm: Tracked<Perm>, verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L,
                UpdateListElementAtIndexOp<K, L>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(),
                                UpdateListElementAtIndexOp {
                                    key: *key,
                                    idx,
                                    new_list_element,
                                }),
                            grants_permission_to_mutate::<Perm, K, I, L,
                                    UpdateListElementAtIndexOp<K, L>,
                                    Self>(perm,
                                UpdateListElementAtIndexOp {
                                    key: *key,
                                    idx,
                                    new_list_element,
                                }, self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    UpdateListElementAtIndexOp {
                                        key: *key,
                                        idx,
                                        new_list_element,
                                    }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        UpdateListElementAtIndexOp::<K,
                            L> { key: *key, idx, new_list_element }
                };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_update_list_element_at_index(key,
                            idx, new_list_element) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn update_list_element_at_index_and_item<Perm,
                CB>(&self, key: &K, idx: usize, new_list_element: L,
                new_item: &I, verus_tmp_perm: Tracked<Perm>,
                verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L,
                UpdateListElementAtIndexAndItemOp<K, I, L>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(),
                                UpdateListElementAtIndexAndItemOp {
                                    key: *key,
                                    idx,
                                    new_list_element,
                                    new_item: *new_item,
                                }),
                            grants_permission_to_mutate::<Perm, K, I, L,
                                    UpdateListElementAtIndexAndItemOp<K, I, L>,
                                    Self>(perm,
                                UpdateListElementAtIndexAndItemOp {
                                    key: *key,
                                    idx,
                                    new_list_element,
                                    new_item: *new_item,
                                }, self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    UpdateListElementAtIndexAndItemOp {
                                        key: *key,
                                        idx,
                                        new_list_element,
                                        new_item: *new_item,
                                    }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        UpdateListElementAtIndexAndItemOp::<K, I,
                            L> { key: *key, idx, new_list_element, new_item: *new_item }
                };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_update_list_element_at_index_and_item(key,
                            idx, new_list_element, new_item) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn trim_list<Perm,
                CB>(&self, key: &K, trim_length: usize,
                verus_tmp_perm: Tracked<Perm>, verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L, TrimListOp<K>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(), TrimListOp { key: *key, trim_length }),
                            grants_permission_to_mutate::<Perm, K, I, L, TrimListOp<K>,
                                    Self>(perm, TrimListOp { key: *key, trim_length },
                                self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    TrimListOp { key: *key, trim_length }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = TrimListOp::<K> { key: *key, trim_length } };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_trim_list(key, trim_length)
                        {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn trim_list_and_update_item<Perm,
                CB>(&self, key: &K, trim_length: usize, new_item: &I,
                verus_tmp_perm: Tracked<Perm>, verus_tmp_cb: Tracked<CB>)
                -> (Result<(), KvError>, Tracked<CB::Completion>) where
                CB: MutatingLinearizer<K, I, L,
                TrimListAndUpdateItemOp<K, I>>,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                #[verus::internal(header_unwrap_parameter)]
                let cb;

                #[verifier::proof_block]
                { cb = verus_tmp_cb.get() };
                ::builtin::requires([self.valid(),
                            ::builtin::spec_eq(perm.id(), self.powerpm_id()),
                            cb.pre(self.id(),
                                TrimListAndUpdateItemOp {
                                    key: *key,
                                    trim_length,
                                    new_item: *new_item,
                                }),
                            grants_permission_to_mutate::<Perm, K, I, L,
                                    TrimListAndUpdateItemOp<K, I>,
                                    Self>(perm,
                                TrimListAndUpdateItemOp {
                                    key: *key,
                                    trim_length,
                                    new_item: *new_item,
                                }, self.pm_constants())]);
                ::builtin::ensures(|result:
                            (Result<(), KvError>, Tracked<CB::Completion>)|
                        [cb.post((result.1.view()), self.id(),
                                    TrimListAndUpdateItemOp {
                                        key: *key,
                                        trim_length,
                                        new_item: *new_item,
                                    }, result.0)]);
                let (mut kv_internal, write_handle) =
                    self.lock.acquire_write();
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        TrimListAndUpdateItemOp::<K,
                            I> { key: *key, trim_length, new_item: *new_item }
                };
                #[verus::internal(spec)]
                let mut op;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_op = verus_tmp;
                    op = verus_tmp_op;
                };
                let result =
                    match kv_internal.kv.tentatively_trim_list_and_update_item(key,
                            trim_length, new_item) {
                        Err(e) => Err(e),
                        Ok(()) => {
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).durable,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut old_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_old_rkv = verus_tmp;
                                old_rkv = verus_tmp_old_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            {
                                verus_tmp =
                                    RecoveredKvStore::<K, I,
                                        L> {
                                        ps: (kv_internal.kv.view()).ps,
                                        kv: (kv_internal.kv.view()).tentative,
                                    }
                            };
                            #[verus::internal(spec)]
                            let mut new_rkv;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_new_rkv = verus_tmp;
                                new_rkv = verus_tmp_new_rkv;
                            };
                            #[verus::internal(spec)]
                            #[verus::internal(unwrapped_binding)]
                            let mut verus_tmp;

                            #[verifier::proof_block]
                            { verus_tmp = (self.pm_constants.view()) };
                            #[verus::internal(spec)]
                            let mut pm_constants;

                            #[verifier::proof_block]
                            {
                                #[verus::internal(spec)]
                                let verus_tmp_pm_constants = verus_tmp;
                                pm_constants = verus_tmp_pm_constants;
                            };

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                ||
                                    {
                                        ::builtin::assert_(op.result_valid(ConcurrentKvStoreView::<K,
                                                    I, L> { ps: old_rkv.ps, pm_constants, kv: old_rkv.kv },
                                                ConcurrentKvStoreView::<K, I,
                                                    L> { ps: new_rkv.ps, pm_constants, kv: new_rkv.kv },
                                                Ok(())))
                                    };
                            };
                            kv_internal.kv.commit::<Perm>(#[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm))
                        }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ConcurrentKvStoreView::<K, I,
                                L>::from_kvstore_view((kv_internal.kv.view()))
                };
                #[verus::internal(spec)]
                let mut new_ckv;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_new_ckv = verus_tmp;
                    new_ckv = verus_tmp_new_ckv;
                };
                #[verus::internal(proof)]
                let mut completion;

                #[verifier::proof_block]
                {
                    completion =
                        cb.apply(op, new_ckv, result,
                            kv_internal.invariant_resource.borrow_mut());
                }
                write_handle.release_write(kv_internal);
                (result,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] completion))
            }
        }
    }
    pub mod setup_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::align_v::*;
        use crate::common::subrange_v::*;
        use crate::journal::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemutil_v::*;
        use crate::pmem::traits_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::keys::*;
        use super::impl_v::*;
        use super::items::*;
        use super::lists::*;
        use super::recover_v::*;
        use super::spec_t::*;
        use vstd::arithmetic::overflow::CheckedU64;
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        fn check_setup_parameters(ps: &SetupParameters) -> bool {
            ::builtin::ensures(|result: bool|
                    [::builtin::spec_eq(result, ps.valid())]);
            if ps.max_keys == 0 {
                    false
                } else if ps.max_list_elements == 0 {
                   false
               } else if ps.max_operations_per_transaction == 0 {
                   false
               } else { true }
        }
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + std::fmt::Debug,
            I: PmCopy + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn space_needed_for_journal_capacity(ps: &SetupParameters)
                -> CheckedU64 {
                ::builtin::ensures(|result: CheckedU64|
                        [::builtin::spec_eq((result.view()),
                                    (ps.max_operations_per_transaction).spec_mul(spec_space_needed_for_transaction_operation()))]);
                let overhead =
                    CheckedU64::new(Journal::<PM>::journal_entry_overhead());
                let rm_size = size_of::<KeyTableRowMetadata>() as u64;
                let u64_size = size_of::<u64>() as u64;
                let bytes_per_operation =
                    overhead.add_checked(&overhead).add_checked(&overhead).add_value(rm_size).add_value(u64_size).add_value(u64_size).add_value(u64_size);
                CheckedU64::new(ps.max_operations_per_transaction).mul_checked(&bytes_per_operation)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn space_needed_for_setup(ps: &SetupParameters)
                -> Result<u64, KvError> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + std::fmt::Debug, I: PmCopy +
                std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
                Copy {
                ::builtin::ensures(|result: Result<u64, KvError>|
                        [match result {
                                    Ok(v) =>
                                        ::builtin::spec_eq(v,
                                            Self::spec_space_needed_for_setup(*ps)),
                                    Err(KvError::InvalidParameter) => !ps.valid(),
                                    Err(KvError::OutOfSpace) =>
                                        (Self::spec_space_needed_for_setup(*ps)).spec_gt(u64::MAX),
                                    Err(_) => false,
                                }]);
                if !check_setup_parameters(ps) {
                        return Err(KvError::InvalidParameter);
                    }
                let journal_capacity =
                    Self::space_needed_for_journal_capacity(ps);
                let journal_end =
                    Journal::<PM>::space_needed_for_setup(&journal_capacity);
                let sm_start =
                    align_checked_u64_to_usize(&journal_end,
                        align_of::<KvStaticMetadata>());
                let sm_end =
                    sm_start.add_value(size_of::<KvStaticMetadata>() as u64);
                let sm_crc_end = sm_end.add_value(size_of::<u64>() as u64);
                let key_table_size =
                    KeyTable::<PM, K>::space_needed_for_setup(ps, &sm_crc_end);
                let key_table_end = sm_crc_end.add_checked(&key_table_size);
                let item_table_size =
                    ItemTable::<PM,
                            I>::space_needed_for_setup(ps, &key_table_end);
                let item_table_end =
                    key_table_end.add_checked(&item_table_size);
                let list_table_size =
                    ListTable::<PM,
                            L>::space_needed_for_setup(ps, &item_table_end);
                let list_table_end =
                    item_table_end.add_checked(&list_table_size);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq((list_table_end.view()),
                                    Self::spec_space_needed_for_setup(*ps)))
                        };
                };
                if list_table_end.is_overflowed() {
                        Err(KvError::OutOfSpace)
                    } else { Ok(list_table_end.unwrap()) }
            }
            #[inline]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn write_static_metadata(pm: &mut PM, sm: &KvStaticMetadata,
                jc: &JournalConstants) where PM: PersistentMemoryRegion {
                ::builtin::requires([old(pm).inv(), (old(pm).view()).valid(),
                            validate_static_metadata::<K, I, L>(*sm, *jc),
                            (((jc.app_area_start).spec_add(KvStaticMetadata::spec_size_of())).spec_add(u64::spec_size_of())).spec_le(jc.app_area_end),
                            (jc.app_area_end).spec_le((old(pm).view()).len())]);
                ::builtin::ensures([pm.inv(),
                            ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                            seqs_match_except_in_range((old(pm).view()).read_state,
                                (pm.view()).read_state,
                                ::builtin::spec_cast_integer::<_, int>(jc.app_area_start),
                                ((jc.app_area_start).spec_add(KvStaticMetadata::spec_size_of())).spec_add(u64::spec_size_of())),
                            ::builtin::spec_eq(recover_static_metadata::<K, I,
                                        L>((pm.view()).read_state, *jc), Some(*sm))]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_write_effect_on_read_state)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_can_result_from_write_effect_on_read_state_subranges)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(recover_static_metadata)
                                    }
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1)
                        };
                };
                let sm_addr = jc.app_area_start;
                let sm_crc_addr =
                    jc.app_area_start + size_of::<KvStaticMetadata>() as u64;
                let sm_crc = calculate_crc(sm);
                pm.serialize_and_write(sm_addr, sm);
                pm.serialize_and_write(sm_crc_addr, &sm_crc);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal(recover_static_metadata::<K,
                                            I, L>((pm.view()).read_state, *jc), Some(*sm)))
                        };
                };
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn setup(pm: &mut PM, ps: &SetupParameters)
                -> Result<(), KvError> where PM: PersistentMemoryRegion,
                K: Hash + PmCopy + std::fmt::Debug, I: PmCopy +
                std::fmt::Debug, L: PmCopy + LogicalRange + std::fmt::Debug +
                Copy {
                ::builtin::requires([old(pm).inv()]);
                ::builtin::ensures(|result: Result<(), KvError>|
                        [pm.inv(),
                                ::builtin::spec_eq(pm.constants(), old(pm).constants()),
                                match result {
                                    Ok(()) => {
                                        (((pm.view()).flush_predicted()) && (ps.valid())) &&
                                            (::builtin::spec_eq(Self::recover((pm.view()).durable_state),
                                                    Some(RecoveredKvStore::<K, I, L>::init(*ps))))
                                    }
                                    Err(KvError::InvalidParameter) => !ps.valid(),
                                    Err(KvError::KeySizeTooSmall) =>
                                        ::builtin::spec_eq(K::spec_size_of(),
                                            ::builtin::spec_literal_nat("0")),
                                    Err(KvError::OutOfSpace) =>
                                        ((pm.view()).len()).spec_lt(Self::spec_space_needed_for_setup(*ps)),
                                    Err(_) => false,
                                }]);
                if !check_setup_parameters(ps) {
                        return Err(KvError::InvalidParameter);
                    }

                #[verifier::proof_block]
                { pm.lemma_inv_implies_view_valid(); }
                let pm_size = pm.get_region_size();
                let journal_capacity =
                    Self::space_needed_for_journal_capacity(ps);
                let journal_end =
                    Journal::<PM>::space_needed_for_setup(&journal_capacity);
                let sm_start =
                    align_checked_u64_to_usize(&journal_end,
                        align_of::<KvStaticMetadata>());
                let sm_end =
                    sm_start.add_value(size_of::<KvStaticMetadata>() as u64);
                let sm_crc_end = sm_end.add_value(size_of::<u64>() as u64);
                if sm_crc_end.is_overflowed() {
                        return Err(KvError::OutOfSpace);
                    }
                if sm_crc_end.unwrap() > pm_size {
                        return Err(KvError::OutOfSpace);
                    }

                #[verifier::proof_block]
                {
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                }
                let key_sm =
                    match KeyTable::<PM,
                                K>::setup(pm, ps, sm_crc_end.unwrap(), pm_size) {
                        Ok(key_sm) => key_sm,
                        Err(e) => { return Err(e); }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (pm.view()).read_state };
                #[verus::internal(spec)]
                let mut state_after_key_init;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_state_after_key_init = verus_tmp;
                    state_after_key_init = verus_tmp_state_after_key_init;
                };
                let item_sm =
                    match ItemTable::<PM,
                                I>::setup(pm, ps, key_sm.end(), pm_size) {
                        Ok(item_sm) => item_sm,
                        Err(e) => { return Err(e); }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (pm.view()).read_state };
                #[verus::internal(spec)]
                let mut state_after_item_init;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_state_after_item_init = verus_tmp;
                    state_after_item_init = verus_tmp_state_after_item_init;
                };
                let list_sm =
                    match ListTable::<PM,
                                L>::setup(pm, ps, item_sm.end(), pm_size) {
                        Ok(list_sm) => list_sm,
                        Err(e) => { return Err(e); }
                    };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (pm.view()).read_state };
                #[verus::internal(spec)]
                let mut state_after_list_init;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_state_after_list_init = verus_tmp;
                    state_after_list_init = verus_tmp_state_after_list_init;
                };
                let kv_sm =
                    KvStaticMetadata {
                        id: ps.kvstore_id,
                        encoded_policies: encode_policies(&ps.logical_range_gaps_policy),
                        max_keys: ps.max_keys,
                        max_list_elements: ps.max_list_elements,
                        max_operations_per_transaction: ps.max_operations_per_transaction,
                        keys: key_sm,
                        items: item_sm,
                        lists: list_sm,
                    };
                let jc =
                    JournalConstants {
                        app_program_guid: KVSTORE_PROGRAM_GUID,
                        app_version_number: KVSTORE_PROGRAM_VERSION_NUMBER,
                        journal_capacity: journal_capacity.unwrap(),
                        app_area_start: sm_start.unwrap(),
                        app_area_end: pm_size,
                    };
                Self::write_static_metadata(pm, &kv_sm, &jc);
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (pm.view()).read_state };
                #[verus::internal(spec)]
                let mut state_after_sm_init;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_state_after_sm_init = verus_tmp;
                    state_after_sm_init = verus_tmp_state_after_sm_init;
                };
                match Journal::<PM>::setup(pm, &jc) {
                    Ok(jc) => {}
                    Err(_) => {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = KeyTableSnapshot::<K>::init() };
                #[verus::internal(spec)]
                let mut empty_keys;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_empty_keys = verus_tmp;
                    empty_keys = verus_tmp_empty_keys;
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(recover_static_metadata::<K,
                                                I, L>((pm.view()).read_state, jc), Some(kv_sm)),
                                    {
                                        lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                                I, L>(state_after_sm_init, (pm.view()).read_state, jc);
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(KeyTable::<PM,
                                                K>::recover((pm.view()).read_state, key_sm),
                                        Some(empty_keys)),
                                    {
                                        KeyTable::<PM,
                                                K>::lemma_recover_depends_only_on_my_area(state_after_key_init,
                                            (pm.view()).read_state, key_sm);
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(ItemTable::<PM,
                                                I>::recover((pm.view()).read_state, empty_keys.item_addrs(),
                                            item_sm), Some(ItemTableSnapshot::<I>::init())),
                                    {
                                        ItemTable::<PM,
                                                I>::lemma_recover_depends_only_on_my_area(state_after_item_init,
                                            (pm.view()).read_state, empty_keys.item_addrs(), item_sm);
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_by(::builtin::spec_eq(ListTable::<PM,
                                                L>::recover((pm.view()).read_state, empty_keys.list_addrs(),
                                            list_sm), Some(ListTableSnapshot::<L>::init())),
                                    {
                                        ListTable::<PM,
                                                L>::lemma_recover_depends_only_on_my_area(state_after_list_init,
                                            (pm.view()).read_state, empty_keys.list_addrs(), list_sm);
                                    });
                            }
                        };
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::ext_equal(recover_kv::<PM, K,
                                            I, L>((pm.view()).read_state, jc),
                                    Some(RecoveredKvStore::<K, I, L>::init(*ps))))
                        };
                };
                Ok(())
            }
        }
    }
    pub mod slots_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::util_v::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_filtering_keys_doesnt_affect_fold(self,
                pos: int) {
                ::builtin::requires([(self.view()).durable.m.dom().finite(),
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        pos), (self.view()).durable.m.dom().to_seq().len()))]);
                ::builtin::ensures([({
                                    let m = (self.view()).durable.m;
                                    let kseq = m.dom().to_seq();
                                    let kseq_truncated = kseq.take(pos);
                                    let kseq_truncated_and_filtered =
                                        kseq_truncated.filter(::builtin::closure_to_fn_spec(|k: K|
                                                    !::builtin::spec_eq((self.keys.view()).durable.key_info.spec_index(k).list_addr,
                                                            ::builtin::spec_literal_nat("0"))));
                                    ::builtin::spec_eq(kseq_truncated_and_filtered.fold_left(::builtin::spec_literal_integer("0"),
                                            ::builtin::closure_to_fn_spec(|total: int, k: K|
                                                    (total).spec_add(m.spec_index(k).1.len()))),
                                        kseq_truncated.fold_left(::builtin::spec_literal_integer("0"),
                                            ::builtin::closure_to_fn_spec(|total: int, k: K|
                                                    (total).spec_add(m.spec_index(k).1.len()))))
                                })]);
                ::builtin::decreases((pos,));
                let keys = (self.keys.view()).durable;
                let items = (self.items.view()).durable;
                let lists = (self.lists.view()).durable;
                let m = (self.view()).durable.m;
                let kseq = m.dom().to_seq();
                let kseq_truncated = kseq.take(pos);
                let filt =
                    ::builtin::closure_to_fn_spec(|k: K|
                            !::builtin::spec_eq(keys.key_info.spec_index(k).list_addr,
                                    ::builtin::spec_literal_nat("0")));
                if ::builtin::spec_eq(pos, ::builtin::spec_literal_nat("0")) {
                        return;
                    }
                ::builtin::assert_(::builtin::ext_equal(kseq_truncated.drop_last(),
                        kseq.take((pos).spec_sub(::builtin::spec_literal_nat("1")))));
                ::builtin::assert_(::builtin::spec_eq(kseq_truncated.last(),
                        kseq_truncated.spec_index((pos).spec_sub(::builtin::spec_literal_nat("1")))));
                self.lemma_filtering_keys_doesnt_affect_fold((pos).spec_sub(::builtin::spec_literal_nat("1")));
                let last_key = kseq_truncated.last();
                lemma_set_to_seq_contains_iff_set_contains(m.dom(), last_key);
                if ::builtin::spec_eq(keys.key_info.spec_index(last_key).list_addr,
                            ::builtin::spec_literal_nat("0")) {
                        {
                            ::builtin::assert_by(::builtin::spec_eq(kseq_truncated.filter(filt),
                                    kseq_truncated.drop_last().filter(filt)),
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(Seq::filter)
                                            }
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                });
                        }
                    } else {
                       {
                           ::builtin::assert_by(::builtin::spec_eq(kseq_truncated.filter(filt),
                                   kseq_truncated.drop_last().filter(filt).push(kseq_truncated.last())),
                               {
                                   ::builtin::reveal_hide_({
                                           #[verus::internal(reveal_fn)]
                                           fn __VERUS_REVEAL_INTERNAL__() {
                                               ::builtin::reveal_hide_internal_path_(Seq::filter)
                                           }
                                           __VERUS_REVEAL_INTERNAL__
                                       }, 1);
                               });
                       }
                       ::builtin::assert_(::builtin::spec_eq(kseq_truncated.filter(filt).drop_last(),
                               kseq_truncated.drop_last().filter(filt)));
                       ::builtin::assert_(::builtin::spec_eq(kseq_truncated.filter(filt).last(),
                               kseq_truncated.last()));
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_used_list_slots_correspond(self) {
                ::builtin::requires([self.inv_components_finite(),
                            self.inv_components_correspond(),
                            (self.keys.view()).durable.valid()]);
                ::builtin::ensures([::builtin::spec_eq((self.view()).durable.num_list_elements(),
                                (self.lists.view()).durable.m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                                    ::builtin::closure_to_fn_spec(|total: int, row_addr: u64|
                                            (total).spec_add((self.lists.view()).durable.m.spec_index(row_addr).len()))))]);
                let keys = (self.keys.view()).durable;
                let items = (self.items.view()).durable;
                let lists = (self.lists.view()).durable;
                let m = (self.view()).durable.m;
                let list_addr_seq = lists.m.dom().to_seq();
                let accumulate_row_addr =
                    ::builtin::closure_to_fn_spec(|total: int, row_addr: u64|
                            (total).spec_add(lists.m.spec_index(row_addr).len()));
                let list_used_slots =
                    list_addr_seq.fold_left(::builtin::spec_literal_integer("0"),
                        accumulate_row_addr);
                let accumulate_key =
                    ::builtin::closure_to_fn_spec(|total: int, k: K|
                            (total).spec_add(m.spec_index(k).1.len()));
                ::builtin::assert_(::builtin::spec_eq((self.view()).durable.num_list_elements(),
                        m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                            accumulate_key)));
                ::builtin::assert_(::builtin::ext_equal(m.dom(),
                        keys.key_info.dom()));
                let kseq = m.dom().to_seq();
                let key_has_list =
                    ::builtin::closure_to_fn_spec(|k: K|
                            !::builtin::spec_eq(keys.key_info.spec_index(k).list_addr,
                                    ::builtin::spec_literal_nat("0")));
                let keys_with_lists_seq = kseq.filter(key_has_list);
                {
                    ::builtin::assert_by(::builtin::spec_eq(kseq.fold_left(::builtin::spec_literal_integer("0"),
                                accumulate_key),
                            keys_with_lists_seq.fold_left(::builtin::spec_literal_integer("0"),
                                accumulate_key)),
                        {
                            self.lemma_filtering_keys_doesnt_affect_fold(::builtin::spec_cast_integer::<_,
                                        int>(kseq.len()));
                            ::builtin::assert_(::builtin::ext_equal(kseq,
                                    kseq.take(::builtin::spec_cast_integer::<_,
                                                int>(kseq.len()))));
                        });
                }
                let key_to_list_addr =
                    ::builtin::closure_to_fn_spec(|k: K|
                            keys.key_info.spec_index(k).list_addr);
                let keys_with_lists_seq_mapped =
                    keys_with_lists_seq.map_values(key_to_list_addr);
                {
                    ::builtin::assert_by(::builtin::spec_eq(keys_with_lists_seq.fold_left(::builtin::spec_literal_integer("0"),
                                accumulate_key),
                            keys_with_lists_seq_mapped.fold_left(::builtin::spec_literal_integer("0"),
                                accumulate_row_addr)),
                        {
                            {
                                ::builtin::assert_forall_by(|total: int, k: K|
                                        {
                                            ::builtin::requires(keys_with_lists_seq.contains(k));
                                            ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] accumulate_key(total,
                                                        k), accumulate_row_addr(total, key_to_list_addr(k))));
                                            ::builtin::assert_(!::builtin::spec_eq(keys.key_info.spec_index(k).list_addr,
                                                        ::builtin::spec_literal_nat("0")));
                                            lemma_if_filter_contains_then_original_contains(kseq,
                                                key_has_list, k);
                                            ::builtin::assert_(kseq.contains(k));
                                            lemma_set_to_seq_contains_iff_set_contains(m.dom(), k);
                                            ::builtin::assert_(keys.key_info.dom().contains(k));
                                            ::builtin::assert_(::builtin::spec_eq(m.spec_index(k).1,
                                                    lists.m.spec_index(keys.key_info.spec_index(k).list_addr)));
                                            ::builtin::assert_(::builtin::spec_eq(accumulate_key(total,
                                                        k), accumulate_row_addr(total, key_to_list_addr(k))));
                                        });
                            }
                            lemma_fold_equivalent_to_map_fold::<K, u64,
                                    int>(::builtin::spec_literal_integer("0"),
                                keys_with_lists_seq, key_to_list_addr, accumulate_key,
                                accumulate_row_addr);
                        });
                }
                {
                    ::builtin::assert_by(::builtin::ext_equal(keys_with_lists_seq_mapped.to_set(),
                            list_addr_seq.to_set()),
                        {
                            let s1 = keys_with_lists_seq_mapped;
                            let s2 = list_addr_seq;
                            {
                                ::builtin::assert_forall_by(|row_addr: u64|
                                        {
                                            ::builtin::requires(s1.contains(row_addr));
                                            ::builtin::ensures(s2.contains(row_addr));
                                            let i =
                                                ::builtin::choose::<int,
                                                        _>(|i: int|
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        i), s1.len())) &&
                                                            ::builtin::spec_eq(s1.spec_index(i), row_addr));
                                            let k = keys_with_lists_seq.spec_index(i);
                                            ::builtin::assert_(::builtin::spec_eq(keys.key_info.spec_index(k).list_addr,
                                                    row_addr));
                                            lemma_if_filter_contains_then_original_contains(kseq,
                                                key_has_list, k);
                                            lemma_set_to_seq_contains_iff_set_contains(m.dom(), k);
                                            lemma_set_to_seq_contains_iff_set_contains(lists.m.dom(),
                                                row_addr);
                                        });
                            }
                            {
                                ::builtin::assert_forall_by(|row_addr: u64|
                                        {
                                            ::builtin::requires(s2.contains(row_addr));
                                            ::builtin::ensures(s1.contains(row_addr));
                                            lemma_set_to_seq_contains_iff_set_contains(lists.m.dom(),
                                                row_addr);
                                            ::builtin::assert_(lists.m.contains_key(row_addr));
                                            ::builtin::assert_(keys.list_info.contains_key(row_addr));
                                            let k: K = keys.list_info.spec_index(row_addr);
                                            ::builtin::assert_(m.contains_key(k));
                                            lemma_set_to_seq_contains_iff_set_contains(m.dom(), k);
                                            ::builtin::assert_(kseq.contains(k));
                                            ::builtin::assert_(keys_with_lists_seq.contains(k));
                                            let i =
                                                ::builtin::choose::<int,
                                                        _>(|i: int|
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        i), keys_with_lists_seq.len())) &&
                                                            ::builtin::spec_eq(keys_with_lists_seq.spec_index(i), k));
                                            ::builtin::assert_(::builtin::spec_eq(s1.spec_index(i),
                                                    row_addr));
                                        });
                            }
                        });
                }
                {
                    ::builtin::assert_by(list_addr_seq.no_duplicates(),
                        {
                            lemma_set_to_seq_has_same_length_with_no_duplicates(lists.m.dom());
                        });
                }
                {
                    ::builtin::assert_by(keys_with_lists_seq.no_duplicates(),
                        {
                            lemma_set_to_seq_has_same_length_with_no_duplicates(m.dom());
                            lemma_filter_preserves_no_duplicates(kseq, key_has_list);
                        });
                }
                {
                    ::builtin::assert_by(keys_with_lists_seq_mapped.no_duplicates(),
                        {
                            let s = keys_with_lists_seq_mapped;
                            {
                                ::builtin::assert_forall_by(|i: int, j: int|
                                        {
                                            ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    i), s.len())) &&
                                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    j), s.len())) && !::builtin::spec_eq(i, j));
                                            ::builtin::ensures(!::builtin::spec_eq(s.spec_index(i),
                                                        s.spec_index(j)));
                                            let k1 = keys_with_lists_seq.spec_index(i);
                                            let k2 = keys_with_lists_seq.spec_index(j);
                                            ::builtin::assert_(!::builtin::spec_eq(k1, k2));
                                            lemma_if_filter_contains_then_original_contains(kseq,
                                                key_has_list, k1);
                                            lemma_if_filter_contains_then_original_contains(kseq,
                                                key_has_list, k2);
                                            lemma_set_to_seq_contains_iff_set_contains(m.dom(), k1);
                                            lemma_set_to_seq_contains_iff_set_contains(m.dom(), k2);
                                        });
                            }
                        });
                }
                let accumulate_row_addr_converted =
                    convert_foldl_to_foldr(accumulate_row_addr);
                {
                    ::builtin::assert_by(::builtin::spec_eq(keys_with_lists_seq_mapped.fold_left(::builtin::spec_literal_integer("0"),
                                accumulate_row_addr),
                            list_addr_seq.fold_left(::builtin::spec_literal_integer("0"),
                                accumulate_row_addr)),
                        {
                            lemma_two_seqs_with_no_duplicates_and_same_to_set_are_permutations::<u64>(keys_with_lists_seq_mapped,
                                list_addr_seq);
                            lemma_commutative_foldl_equivalent_to_corresponding_foldr(keys_with_lists_seq_mapped,
                                ::builtin::spec_literal_integer("0"), accumulate_row_addr);
                            lemma_commutative_foldl_equivalent_to_corresponding_foldr(list_addr_seq,
                                ::builtin::spec_literal_integer("0"), accumulate_row_addr);
                            vstd::seq_lib::lemma_fold_right_permutation::<u64,
                                    int>(keys_with_lists_seq_mapped, list_addr_seq,
                                accumulate_row_addr_converted,
                                ::builtin::spec_literal_integer("0"));
                        });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_used_slots_correspond(self) {
                ::builtin::requires([self.inv_components_finite(),
                            self.inv_components_correspond(),
                            self.inv_components_valid()]);
                ::builtin::ensures([::builtin::spec_eq((self.view()).durable.num_keys(),
                                (self.keys.view()).durable.key_info.dom().len()),
                            ::builtin::spec_eq((self.view()).durable.num_keys(),
                                (self.items.view()).durable.m.dom().len()),
                            ::builtin::spec_eq((self.view()).durable.num_list_elements(),
                                (self.lists.view()).durable.m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                                    ::builtin::closure_to_fn_spec(|total: int, row_addr: u64|
                                            (total).spec_add((self.lists.view()).durable.m.spec_index(row_addr).len()))))]);
                ::builtin::assert_(::builtin::ext_equal((self.view()).durable.m.dom(),
                        (self.keys.view()).durable.key_info.dom()));
                self.keys.lemma_valid_implications((self.journal.view()));
                {
                    ::builtin::assert_by(::builtin::spec_eq((self.keys.view()).durable.item_info.dom().len(),
                            (self.keys.view()).durable.key_info.dom().len()),
                        {
                            (self.keys.view()).durable.lemma_valid_implies_num_keys_equals_num_items();
                        });
                }
                self.lemma_used_list_slots_correspond();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_using_space_for_transaction_operation_maintains_invariant(self,
                old_self: Self) {
                ::builtin::requires([(self.sm.view()).valid::<K, I, L>(),
                            ::builtin::spec_eq(old_self.sm, self.sm),
                            ::builtin::spec_eq((self.used_transaction_operation_slots.view()),
                                ((old_self.used_transaction_operation_slots.view())).spec_add(::builtin::spec_literal_nat("1"))),
                            ((old_self.journal.view()).remaining_capacity).spec_ge(((((old_self.sm.view()).max_operations_per_transaction).spec_sub((old_self.used_transaction_operation_slots.view())))).spec_mul(spec_space_needed_for_transaction_operation())),
                            ((self.journal.view()).remaining_capacity).spec_ge(((old_self.journal.view()).remaining_capacity).spec_sub(spec_space_needed_for_transaction_operation()))]);
                ::builtin::ensures([((self.journal.view()).remaining_capacity).spec_ge(((((self.sm.view()).max_operations_per_transaction).spec_sub((self.used_transaction_operation_slots.view())))).spec_mul(spec_space_needed_for_transaction_operation()))]);
                let a = (old_self.sm.view()).max_operations_per_transaction;
                let b = (old_self.used_transaction_operation_slots.view());
                let c = spec_space_needed_for_transaction_operation();
                {
                    ::builtin::assert_by(::builtin::spec_eq(((((a).spec_sub(b))).spec_mul(c)).spec_sub(c),
                            (((a).spec_sub(((b).spec_add(::builtin::spec_literal_nat("1")))))).spec_mul(c)),
                        {
                            vstd::arithmetic::mul::lemma_mul_is_distributive_sub_other_way(::builtin::spec_cast_integer::<_,
                                        int>(c), (a).spec_sub(b),
                                ::builtin::spec_literal_integer("1"));
                        });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_insufficient_space_for_transaction_operation_indicates_all_slots_used(self) {
                ::builtin::requires([(self.sm.view()).valid::<K, I, L>(),
                            ((self.journal.view()).remaining_capacity).spec_ge(((((self.sm.view()).max_operations_per_transaction).spec_sub((self.used_transaction_operation_slots.view())))).spec_mul(spec_space_needed_for_transaction_operation()))]);
                ::builtin::ensures([::builtin::imply(((self.journal.view()).remaining_capacity).spec_lt(spec_space_needed_for_transaction_operation()),
                                ((self.used_transaction_operation_slots.view())).spec_ge((self.sm.view()).max_operations_per_transaction))]);
                let a = (self.sm.view()).max_operations_per_transaction;
                let b = (self.used_transaction_operation_slots.view());
                let c = spec_space_needed_for_transaction_operation();
                if (b).spec_lt(a) {
                        {
                            ::builtin::assert_by(((((a).spec_sub(b))).spec_mul(c)).spec_ge(c),
                                {
                                    vstd::arithmetic::mul::lemma_mul_inequality(::builtin::spec_literal_integer("1"),
                                        (a).spec_sub(b), ::builtin::spec_cast_integer::<_, int>(c));
                                });
                        }
                    }
            }
        }
    }
    pub mod spec_t {
        //! This file contains the unverified specification for the high-level KV store.
        //!
        //! This file should be audited for correctness.
        #![allow(unused_imports)]
        #![verus::trusted]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::pmem::pmemspec_t::*;
        use std::hash::Hash;
        #[verus::internal(verus_macro)]
        pub enum KvError {
            NotImplemented,
            InvalidParameter,
            InternalError,
            WrongKvStoreId {
                requested_id: u128,
                actual_id: u128,
            },
            KeyNotFound,
            KeyAlreadyExists,
            InvalidKey,
            IndexOutOfRange {
                upper_bound: usize,
            },
            KeySizeTooSmall,
            KeySizeTooBig,
            ItemSizeTooBig,
            ListEntrySizeTooBig,
            TooFewKeys,
            TooManyListEntriesPerNode,
            TooManyKeys,
            TooManyListNodes,
            OutOfSpace,
            InvalidPersistentMemoryRegionProvided,
            CRCMismatch,
            InvalidItemTableHeader,
            InvalidListMetadata,
            InvalidListRegionMetadata,
            EntryIsValid,
            EntryIsNotValid,
            InvalidLogEntryType,
            NoCurrentTransaction,
            LogicalRangeHasBeenTrimmed {
                logical_trim_position: usize,
            },
            LogicalRangeHasBeenPartiallyTrimmed {
                logical_trim_position: usize,
            },
            LogicalRangePartiallyBeyondEOF {
                end_of_valid_range: usize,
            },
            LogicalRangeBeyondEOF {
                end_of_valid_range: usize,
            },
            PageOutOfLogicalRangeOrder {
                end_of_valid_range: usize,
            },
            PageLeavesLogicalRangeGap {
                end_of_valid_range: usize,
            },
            LogicalRangeUpdateNotAllowed {
                old_start: usize,
                old_end: usize,
                new_start: usize,
                new_end: usize,
            },
            PmemErr {
                pmem_err: PmemError,
            },
            ListLengthWouldExceedUsizeMax,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for KvError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match self {
                    KvError::NotImplemented =>
                        ::core::fmt::Formatter::write_str(f, "NotImplemented"),
                    KvError::InvalidParameter =>
                        ::core::fmt::Formatter::write_str(f, "InvalidParameter"),
                    KvError::InternalError =>
                        ::core::fmt::Formatter::write_str(f, "InternalError"),
                    KvError::WrongKvStoreId {
                        requested_id: __self_0, actual_id: __self_1 } =>
                        ::core::fmt::Formatter::debug_struct_field2_finish(f,
                            "WrongKvStoreId", "requested_id", __self_0, "actual_id",
                            &__self_1),
                    KvError::KeyNotFound =>
                        ::core::fmt::Formatter::write_str(f, "KeyNotFound"),
                    KvError::KeyAlreadyExists =>
                        ::core::fmt::Formatter::write_str(f, "KeyAlreadyExists"),
                    KvError::InvalidKey =>
                        ::core::fmt::Formatter::write_str(f, "InvalidKey"),
                    KvError::IndexOutOfRange { upper_bound: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "IndexOutOfRange", "upper_bound", &__self_0),
                    KvError::KeySizeTooSmall =>
                        ::core::fmt::Formatter::write_str(f, "KeySizeTooSmall"),
                    KvError::KeySizeTooBig =>
                        ::core::fmt::Formatter::write_str(f, "KeySizeTooBig"),
                    KvError::ItemSizeTooBig =>
                        ::core::fmt::Formatter::write_str(f, "ItemSizeTooBig"),
                    KvError::ListEntrySizeTooBig =>
                        ::core::fmt::Formatter::write_str(f, "ListEntrySizeTooBig"),
                    KvError::TooFewKeys =>
                        ::core::fmt::Formatter::write_str(f, "TooFewKeys"),
                    KvError::TooManyListEntriesPerNode =>
                        ::core::fmt::Formatter::write_str(f,
                            "TooManyListEntriesPerNode"),
                    KvError::TooManyKeys =>
                        ::core::fmt::Formatter::write_str(f, "TooManyKeys"),
                    KvError::TooManyListNodes =>
                        ::core::fmt::Formatter::write_str(f, "TooManyListNodes"),
                    KvError::OutOfSpace =>
                        ::core::fmt::Formatter::write_str(f, "OutOfSpace"),
                    KvError::InvalidPersistentMemoryRegionProvided =>
                        ::core::fmt::Formatter::write_str(f,
                            "InvalidPersistentMemoryRegionProvided"),
                    KvError::CRCMismatch =>
                        ::core::fmt::Formatter::write_str(f, "CRCMismatch"),
                    KvError::InvalidItemTableHeader =>
                        ::core::fmt::Formatter::write_str(f,
                            "InvalidItemTableHeader"),
                    KvError::InvalidListMetadata =>
                        ::core::fmt::Formatter::write_str(f, "InvalidListMetadata"),
                    KvError::InvalidListRegionMetadata =>
                        ::core::fmt::Formatter::write_str(f,
                            "InvalidListRegionMetadata"),
                    KvError::EntryIsValid =>
                        ::core::fmt::Formatter::write_str(f, "EntryIsValid"),
                    KvError::EntryIsNotValid =>
                        ::core::fmt::Formatter::write_str(f, "EntryIsNotValid"),
                    KvError::InvalidLogEntryType =>
                        ::core::fmt::Formatter::write_str(f, "InvalidLogEntryType"),
                    KvError::NoCurrentTransaction =>
                        ::core::fmt::Formatter::write_str(f,
                            "NoCurrentTransaction"),
                    KvError::LogicalRangeHasBeenTrimmed {
                        logical_trim_position: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "LogicalRangeHasBeenTrimmed", "logical_trim_position",
                            &__self_0),
                    KvError::LogicalRangeHasBeenPartiallyTrimmed {
                        logical_trim_position: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "LogicalRangeHasBeenPartiallyTrimmed",
                            "logical_trim_position", &__self_0),
                    KvError::LogicalRangePartiallyBeyondEOF {
                        end_of_valid_range: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "LogicalRangePartiallyBeyondEOF", "end_of_valid_range",
                            &__self_0),
                    KvError::LogicalRangeBeyondEOF {
                        end_of_valid_range: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "LogicalRangeBeyondEOF", "end_of_valid_range", &__self_0),
                    KvError::PageOutOfLogicalRangeOrder {
                        end_of_valid_range: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "PageOutOfLogicalRangeOrder", "end_of_valid_range",
                            &__self_0),
                    KvError::PageLeavesLogicalRangeGap {
                        end_of_valid_range: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "PageLeavesLogicalRangeGap", "end_of_valid_range",
                            &__self_0),
                    KvError::LogicalRangeUpdateNotAllowed {
                        old_start: __self_0,
                        old_end: __self_1,
                        new_start: __self_2,
                        new_end: __self_3 } =>
                        ::core::fmt::Formatter::debug_struct_field4_finish(f,
                            "LogicalRangeUpdateNotAllowed", "old_start", __self_0,
                            "old_end", __self_1, "new_start", __self_2, "new_end",
                            &__self_3),
                    KvError::PmemErr { pmem_err: __self_0 } =>
                        ::core::fmt::Formatter::debug_struct_field1_finish(f,
                            "PmemErr", "pmem_err", &__self_0),
                    KvError::ListLengthWouldExceedUsizeMax =>
                        ::core::fmt::Formatter::write_str(f,
                            "ListLengthWouldExceedUsizeMax"),
                }
            }
        }
        #[verus::internal(verus_macro)]
        impl KvError {
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_old_end(self) -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "old_end")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_new_start(self) -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "new_start")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verus::internal(get_field_many_variants)]
            #[verifier::external]
            #[verus::internal(open)]
            pub fn arrow_end_of_valid_range(self) -> usize {
                ::core::panicking::panic("not implemented")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_upper_bound(self) -> usize {
                ::builtin::get_variant_field(self, "IndexOutOfRange",
                    "upper_bound")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_new_end(self) -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "new_end")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verus::internal(get_field_many_variants)]
            #[verifier::external]
            #[verus::internal(open)]
            pub fn arrow_logical_trim_position(self) -> usize {
                ::core::panicking::panic("not implemented")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_old_start(self) -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "old_start")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_requested_id(self) -> u128 {
                ::builtin::get_variant_field(self, "WrongKvStoreId",
                    "requested_id")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_actual_id(self) -> u128 {
                ::builtin::get_variant_field(self, "WrongKvStoreId",
                    "actual_id")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_pmem_err(self) -> PmemError {
                ::builtin::get_variant_field(self, "PmemErr", "pmem_err")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_WrongKvStoreId_requested_id(self) -> u128 {
                ::builtin::get_variant_field(self, "WrongKvStoreId",
                    "requested_id")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_WrongKvStoreId_actual_id(self) -> u128 {
                ::builtin::get_variant_field(self, "WrongKvStoreId",
                    "actual_id")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_IndexOutOfRange_upper_bound(self) -> usize {
                ::builtin::get_variant_field(self, "IndexOutOfRange",
                    "upper_bound")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangeHasBeenTrimmed_logical_trim_position(self)
                -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeHasBeenTrimmed", "logical_trim_position")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangeHasBeenPartiallyTrimmed_logical_trim_position(self)
                -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeHasBeenPartiallyTrimmed",
                    "logical_trim_position")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangePartiallyBeyondEOF_end_of_valid_range(self)
                -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangePartiallyBeyondEOF", "end_of_valid_range")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangeBeyondEOF_end_of_valid_range(self)
                -> usize {
                ::builtin::get_variant_field(self, "LogicalRangeBeyondEOF",
                    "end_of_valid_range")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_PageOutOfLogicalRangeOrder_end_of_valid_range(self)
                -> usize {
                ::builtin::get_variant_field(self,
                    "PageOutOfLogicalRangeOrder", "end_of_valid_range")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_PageLeavesLogicalRangeGap_end_of_valid_range(self)
                -> usize {
                ::builtin::get_variant_field(self,
                    "PageLeavesLogicalRangeGap", "end_of_valid_range")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangeUpdateNotAllowed_old_start(self)
                -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "old_start")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangeUpdateNotAllowed_old_end(self) -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "old_end")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangeUpdateNotAllowed_new_start(self)
                -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "new_start")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_LogicalRangeUpdateNotAllowed_new_end(self) -> usize {
                ::builtin::get_variant_field(self,
                    "LogicalRangeUpdateNotAllowed", "new_end")
            }
            #[cfg(verus_keep_ghost)]
            #[allow(non_snake_case)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            #[verifier::inline]
            #[verus::internal(open)]
            pub fn arrow_PmemErr_pmem_err(self) -> PmemError {
                ::builtin::get_variant_field(self, "PmemErr", "pmem_err")
            }
        }
        #[verus::internal(verus_macro)]
        pub enum LogicalRangeGapsPolicy {
            LogicalRangeGapsForbidden,
            LogicalRangeGapsPermitted,
        }
        #[verus::internal(verus_macro)]
        pub struct SetupParameters {
            pub kvstore_id: u128,
            pub logical_range_gaps_policy: LogicalRangeGapsPolicy,
            pub max_keys: u64,
            pub max_list_elements: u64,
            pub max_operations_per_transaction: u64,
        }
        #[verus::internal(verus_macro)]
        impl SetupParameters {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                (((::builtin::spec_literal_nat("0")).spec_lt(self.max_keys))
                            &&
                            ((::builtin::spec_literal_nat("0")).spec_lt(self.max_list_elements)))
                    &&
                    ((::builtin::spec_literal_nat("0")).spec_lt(self.max_operations_per_transaction))
            }
        }
        #[verus::internal(verus_macro)]
        pub trait LogicalRange {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_start(&self)
            -> usize;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_end(&self)
            -> usize;
            #[verifier::when_used_as_spec(spec_start)]
            #[verus::internal(verus_macro)]
            fn start(&self)
            -> usize;
            #[verifier::when_used_as_spec(spec_end)]
            #[verus::internal(verus_macro)]
            fn end(&self)
            -> usize;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_start(&self) -> usize {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_end(&self) -> usize {
                ::builtin::no_method_body()
            }
            #[verifier::when_used_as_spec(spec_start)]
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__start(&self) -> usize {
                ::builtin::ensures(|result: usize|
                        [::builtin::spec_eq(result, self.start())]);
                ::builtin::no_method_body()
            }
            #[verifier::when_used_as_spec(spec_end)]
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__end(&self) -> usize {
                ::builtin::ensures(|result: usize|
                        [::builtin::spec_eq(result, self.end())]);
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn end_of_range<L>(list_elements: Seq<L>) -> usize where
            L: LogicalRange {
            if ::builtin::spec_eq(list_elements.len(),
                        ::builtin::spec_literal_nat("0")) {
                    ::builtin::spec_literal_integer("0")
                } else { list_elements.last().end() }
        }
        #[doc =
        " An `AtomicKvStore` is an abstraction of an atomic key/value"]
        #[doc =
        " store, i.e., one that doesn\'t support tentative operations,"]
        #[doc = " aborts, and commits."]
        #[doc = " TODO: Should this be generic over the key/header/page"]
        #[doc = " types used in the kv store, or over their views?"]
        #[verifier::reject_recursive_types(K)]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct AtomicKvStore<K, I, L> {
            pub logical_range_gaps_policy: LogicalRangeGapsPolicy,
            pub m: Map<K, (I, Seq<L>)>,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> AtomicKvStore<K, I, L> where K: std::fmt::Debug,
            L: LogicalRange {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn init(logical_range_gaps_policy: LogicalRangeGapsPolicy)
                -> Self {
                Self {
                    logical_range_gaps_policy,
                    m: Map::<K, (I, Seq<L>)>::empty(),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn empty(self) -> bool { self.m.is_empty() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn contains_key(&self, key: K) -> bool {
                self.m.contains_key(key)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn num_keys(&self) -> int {
                ::builtin::spec_cast_integer::<_, int>(self.m.dom().len())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn num_list_elements(&self) -> int {
                self.m.dom().to_seq().fold_left(::builtin::spec_literal_integer("0"),
                    ::builtin::closure_to_fn_spec(|total: int, k: K|
                            (total).spec_add(self.m.spec_index(k).1.len())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn spec_index(self, key: K) -> Option<(I, Seq<L>)> {
                if self.m.contains_key(key) {
                        Some(self.m.spec_index(key))
                    } else { None }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn create(self, key: K, item: I) -> Result<Self, KvError> {
                if self.m.contains_key(key) {
                        Err(KvError::KeyAlreadyExists)
                    } else {
                       Ok(Self {
                               m: self.m.insert(key, (item, Seq::empty())),
                               ..self
                           })
                   }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn read_item(self, key: K) -> Result<I, KvError> {
                if self.m.contains_key(key) {
                        Ok(self.m.spec_index(key).0)
                    } else { Err(KvError::KeyNotFound) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn read_item_and_list(self, key: K)
                -> Result<(I, Seq<L>), KvError> {
                if self.m.contains_key(key) {
                        Ok(self.m.spec_index(key))
                    } else { Err(KvError::KeyNotFound) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn read_list_element_at_index(self, key: K, idx: nat)
                -> Result<L, KvError> {
                if self.m.contains_key(key) {
                        let (item, list) = self.m.spec_index(key);
                        if (idx).spec_lt(list.len()) {
                                Ok(list.spec_index(::builtin::spec_cast_integer::<_,
                                                int>(idx)))
                            } else {
                               Err(KvError::IndexOutOfRange {
                                       upper_bound: ::builtin::spec_cast_integer::<_,
                                               usize>(list.len()),
                                   })
                           }
                    } else { Err(KvError::KeyNotFound) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn get_list_length(self, key: K) -> Result<nat, KvError> {
                if self.m.contains_key(key) {
                        let (item, list) = self.m.spec_index(key);
                        Ok(list.len())
                    } else { Err(KvError::KeyNotFound) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn update_item(self, key: K, new_item: I)
                -> Result<Self, KvError> {
                match self.read_item_and_list(key) {
                    Ok((old_item, pages)) => {
                        Ok(Self {
                                m: self.m.insert(key, (new_item, pages)),
                                ..self
                            })
                    }
                    Err(e) => Err(e),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn delete(self, key: K) -> Result<Self, KvError> {
                if self.m.contains_key(key) {
                        Ok(Self { m: self.m.remove(key), ..self })
                    } else { Err(KvError::KeyNotFound) }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn append_to_list(self, key: K, new_list_element: L)
                -> Result<Self, KvError> {
                match self.read_item_and_list(key) {
                    Ok((item, list_elements)) => {
                        let end_of_valid_range = end_of_range(list_elements);
                        if (list_elements.len()).spec_ge(usize::MAX) {
                                Err(KvError::ListLengthWouldExceedUsizeMax)
                            } else if (new_list_element.start()).spec_lt(end_of_valid_range)
                               {
                               Err(KvError::PageOutOfLogicalRangeOrder {
                                       end_of_valid_range,
                                   })
                           } else if {
                                   (::builtin::is_variant(self.logical_range_gaps_policy,
                                               "LogicalRangeGapsForbidden")) &&
                                       ((new_list_element.start()).spec_gt(end_of_valid_range))
                               } {
                               Err(KvError::PageLeavesLogicalRangeGap {
                                       end_of_valid_range,
                                   })
                           } else {
                               Ok(Self {
                                       m: self.m.insert(key,
                                           (item, list_elements.push(new_list_element))),
                                       ..self
                                   })
                           }
                    }
                    Err(e) => Err(e),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn append_to_list_and_update_item(self, key: K,
                new_list_element: L, new_item: I) -> Result<Self, KvError> {
                match self.read_item_and_list(key) {
                    Ok((item, list_elements)) => {
                        let end_of_valid_range = end_of_range(list_elements);
                        if (list_elements.len()).spec_ge(usize::MAX) {
                                Err(KvError::ListLengthWouldExceedUsizeMax)
                            } else if (new_list_element.start()).spec_lt(end_of_valid_range)
                               {
                               Err(KvError::PageOutOfLogicalRangeOrder {
                                       end_of_valid_range,
                                   })
                           } else if {
                                   (::builtin::is_variant(self.logical_range_gaps_policy,
                                               "LogicalRangeGapsForbidden")) &&
                                       ((new_list_element.start()).spec_gt(end_of_valid_range))
                               } {
                               Err(KvError::PageLeavesLogicalRangeGap {
                                       end_of_valid_range,
                                   })
                           } else {
                               Ok(Self {
                                       m: self.m.insert(key,
                                           (new_item, list_elements.push(new_list_element))),
                                       ..self
                                   })
                           }
                    }
                    Err(e) => Err(e),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn update_list_element_at_index(self, key: K, idx: nat,
                new_list_element: L) -> Result<Self, KvError> {
                match self.read_item_and_list(key) {
                    Ok((item, list_elements)) =>
                        if (idx).spec_ge(list_elements.len()) {
                                Err(KvError::IndexOutOfRange {
                                        upper_bound: ::builtin::spec_cast_integer::<_,
                                                usize>(list_elements.len()),
                                    })
                            } else {
                               let old_list_element =
                                   list_elements.spec_index(::builtin::spec_cast_integer::<_,
                                               int>(idx));
                               if !::builtin::spec_eq(old_list_element.start(),
                                                   new_list_element.start()) ||
                                           !::builtin::spec_eq(old_list_element.end(),
                                                   new_list_element.end()) {
                                       Err(KvError::LogicalRangeUpdateNotAllowed {
                                               old_start: old_list_element.start(),
                                               old_end: old_list_element.end(),
                                               new_start: new_list_element.start(),
                                               new_end: new_list_element.end(),
                                           })
                                   } else {
                                      let new_list_elements =
                                          list_elements.update(::builtin::spec_cast_integer::<_,
                                                      int>(idx), new_list_element);
                                      Ok(Self {
                                              m: self.m.insert(key, (item, new_list_elements)),
                                              ..self
                                          })
                                  }
                           },
                    Err(e) => Err(e),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn update_list_element_at_index_and_item(self, key: K,
                idx: nat, new_list_element: L, new_item: I)
                -> Result<Self, KvError> {
                match self.read_item_and_list(key) {
                    Ok((item, list_elements)) => {
                        if (idx).spec_ge(list_elements.len()) {
                                Err(KvError::IndexOutOfRange {
                                        upper_bound: ::builtin::spec_cast_integer::<_,
                                                usize>(list_elements.len()),
                                    })
                            } else {
                               let old_list_element =
                                   list_elements.spec_index(::builtin::spec_cast_integer::<_,
                                               int>(idx));
                               if !::builtin::spec_eq(old_list_element.start(),
                                                   new_list_element.start()) ||
                                           !::builtin::spec_eq(old_list_element.end(),
                                                   new_list_element.end()) {
                                       Err(KvError::LogicalRangeUpdateNotAllowed {
                                               old_start: old_list_element.start(),
                                               old_end: old_list_element.end(),
                                               new_start: new_list_element.start(),
                                               new_end: new_list_element.end(),
                                           })
                                   } else {
                                      let new_list_elements =
                                          list_elements.update(::builtin::spec_cast_integer::<_,
                                                      int>(idx), new_list_element);
                                      Ok(Self {
                                              m: self.m.insert(key, (new_item, new_list_elements)),
                                              ..self
                                          })
                                  }
                           }
                    }
                    Err(e) => Err(e),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn trim_list(self, key: K, trim_length: nat)
                -> Result<Self, KvError> {
                match self.read_item_and_list(key) {
                    Ok((item, list_elements)) =>
                        if (trim_length).spec_gt(list_elements.len()) {
                                Err(KvError::IndexOutOfRange {
                                        upper_bound: ::builtin::spec_cast_integer::<_,
                                                usize>(list_elements.len()),
                                    })
                            } else {
                               let new_list_elements =
                                   list_elements.skip(::builtin::spec_cast_integer::<_,
                                               int>(trim_length));
                               Ok(Self {
                                       m: self.m.insert(key, (item, new_list_elements)),
                                       ..self
                                   })
                           },
                    Err(e) => Err(e),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn trim_list_and_update_item(self, key: K, trim_length: nat,
                new_item: I) -> Result<Self, KvError> {
                match self.read_item_and_list(key) {
                    Ok((item, list_elements)) =>
                        if (trim_length).spec_gt(list_elements.len()) {
                                Err(KvError::IndexOutOfRange {
                                        upper_bound: ::builtin::spec_cast_integer::<_,
                                                usize>(list_elements.len()),
                                    })
                            } else {
                               let new_list_elements =
                                   list_elements.skip(::builtin::spec_cast_integer::<_,
                                               int>(trim_length));
                               Ok(Self {
                                       m: self.m.insert(key, (new_item, new_list_elements)),
                                       ..self
                                   })
                           },
                    Err(e) => Err(e),
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn get_keys(self) -> Set<K> { self.m.dom() }
        }
        #[verifier::reject_recursive_types(K)]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct RecoveredKvStore<K, I, L> {
            pub ps: SetupParameters,
            pub kv: AtomicKvStore<K, I, L>,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> RecoveredKvStore<K, I, L> where K: std::fmt::Debug,
            L: LogicalRange {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn init(ps: SetupParameters) -> Self {
                Self {
                    ps,
                    kv: AtomicKvStore::<K, I,
                            L>::init(ps.logical_range_gaps_policy),
                }
            }
        }
        #[verifier::reject_recursive_types(K)]
        #[verus::internal(verus_macro)]
        pub struct KvStoreView<K, I, L> {
            pub ps: SetupParameters,
            pub used_key_slots: int,
            pub used_list_element_slots: int,
            pub used_transaction_operation_slots: int,
            pub pm_constants: PersistentMemoryConstants,
            pub durable: AtomicKvStore<K, I, L>,
            pub tentative: AtomicKvStore<K, I, L>,
            pub powerpm_id: int,
        }
        #[verus::internal(verus_macro)]
        impl<K, I, L> KvStoreView<K, I, L> where K: Hash + Eq +
            std::fmt::Debug, L: LogicalRange {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                (::builtin::spec_eq(self.ps.logical_range_gaps_policy,
                            self.durable.logical_range_gaps_policy)) &&
                    (::builtin::spec_eq(self.ps.logical_range_gaps_policy,
                            self.tentative.logical_range_gaps_policy))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn abort(self) -> Self {
                Self {
                    tentative: self.durable,
                    used_key_slots: self.durable.num_keys(),
                    used_list_element_slots: self.durable.num_list_elements(),
                    used_transaction_operation_slots: ::builtin::spec_literal_integer("0"),
                    ..self
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn commit(self) -> Self {
                Self {
                    durable: self.tentative,
                    used_key_slots: self.tentative.num_keys(),
                    used_list_element_slots: self.tentative.num_list_elements(),
                    used_transaction_operation_slots: ::builtin::spec_literal_integer("0"),
                    ..self
                }
            }
        }
    }
    pub mod start_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::recover_v::*;
        use crate::common::subrange_v::*;
        use crate::journal::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::traits_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::items::*;
        use super::keys::*;
        use super::lists::*;
        use super::recover_v::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + std::fmt::Debug,
            I: PmCopy + std::fmt::Debug, L: PmCopy + LogicalRange +
            std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            pub fn start(powerpm: PoWERPersistentMemoryRegion<PM>,
                kvstore_id: u128,
                verus_tmp_state: Ghost<RecoveredKvStore<K, I, L>>,
                verus_tmp_perm_factory: Tracked<PermFactory>)
                -> Result<Self, KvError> {
                #[verus::internal(header_unwrap_parameter)]
                let state;

                #[verifier::proof_block]
                { state = verus_tmp_state.view() };
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([powerpm.inv(),
                            ::builtin::spec_eq(Self::recover((powerpm.view()).durable_state),
                                Some(state)), vstd::std_specs::hash::obeys_key_model::<K>(),
                            ::builtin::spec_eq(perm_factory.id(), powerpm.id()),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply(::builtin::spec_eq(Self::recover(s1),
                                            Self::recover(s2)),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures(|result: Result<Self, KvError>|
                        [match result {
                                    Ok(kv) => {
                                        ((((((((((kv.valid()) && ((kv.view()).valid())) &&
                                                                                                            (::builtin::spec_eq((kv.view()).ps, state.ps))) &&
                                                                                                    ((kv.view()).ps.valid())) &&
                                                                                            (::builtin::spec_eq((kv.view()).used_key_slots,
                                                                                                    state.kv.num_keys()))) &&
                                                                                    (::builtin::spec_eq((kv.view()).used_list_element_slots,
                                                                                            state.kv.num_list_elements()))) &&
                                                                            (::builtin::spec_eq((kv.view()).used_transaction_operation_slots,
                                                                                    ::builtin::spec_literal_nat("0")))) &&
                                                                    (::builtin::spec_eq((kv.view()).pm_constants,
                                                                            powerpm.constants()))) &&
                                                            (::builtin::spec_eq((kv.view()).durable, state.kv))) &&
                                                    (::builtin::spec_eq((kv.view()).tentative, state.kv))) &&
                                            (::builtin::spec_eq((kv.view()).powerpm_id, powerpm.id()))
                                    }
                                    Err(KvError::CRCMismatch) =>
                                        !powerpm.constants().impervious_to_corruption(),
                                    Err(KvError::WrongKvStoreId { requested_id, actual_id }) =>
                                        {
                                        (::builtin::spec_eq(requested_id, kvstore_id)) &&
                                            (::builtin::spec_eq(actual_id, state.ps.kvstore_id))
                                    }
                                    Err(KvError::KeySizeTooSmall) =>
                                        ::builtin::spec_eq(K::spec_size_of(),
                                            ::builtin::spec_literal_nat("0")),
                                    Err(_) => false,
                                }]);

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::reveal_hide_({
                                    #[verus::internal(reveal_fn)]
                                    fn __VERUS_REVEAL_INTERNAL__() {
                                        ::builtin::reveal_hide_internal_path_(recover_static_metadata)
                                    }
                                    __VERUS_REVEAL_INTERNAL__
                                }, 1)
                        };
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = (powerpm.view()).durable_state };
                #[verus::internal(spec)]
                let mut old_state;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_old_state = verus_tmp;
                    old_state = verus_tmp_old_state;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = Journal::<PM>::recover(old_state).unwrap() };
                #[verus::internal(spec)]
                let mut journal_recovered;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_journal_recovered = verus_tmp;
                    journal_recovered = verus_tmp_journal_recovered;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = journal_recovered.constants };
                #[verus::internal(spec)]
                let mut jc;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_jc = verus_tmp;
                    jc = verus_tmp_jc;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = journal_recovered.state };
                #[verus::internal(spec)]
                let mut js;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_js = verus_tmp;
                    js = verus_tmp_js;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        recover_static_metadata::<K, I, L>(js, jc).unwrap()
                };
                #[verus::internal(spec)]
                let mut sm;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_sm = verus_tmp;
                    sm = verus_tmp_sm;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp = KeyTable::<PM, K>::recover(js, sm.keys).unwrap()
                };
                #[verus::internal(spec)]
                let mut recovered_keys;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_recovered_keys = verus_tmp;
                    recovered_keys = verus_tmp_recovered_keys;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ItemTable::<PM,
                                    I>::recover(js, recovered_keys.item_addrs(),
                                sm.items).unwrap()
                };
                #[verus::internal(spec)]
                let mut recovered_items;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_recovered_items = verus_tmp;
                    recovered_items = verus_tmp_recovered_items;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        ListTable::<PM,
                                    L>::recover(js, recovered_keys.list_addrs(),
                                sm.lists).unwrap()
                };
                #[verus::internal(spec)]
                let mut recovered_lists;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_recovered_lists = verus_tmp;
                    recovered_lists = verus_tmp_recovered_lists;
                };

                #[verifier::proof_block]
                {
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                }

                                #[verus::internal(broadcast_use_reveal)]
                                __VERUS_REVEAL_INTERNAL__
                            }, 1);
                    }
                }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            {
                                ::builtin::assert_forall_by(|s: Seq<u8>|
                                        {
                                            ::builtin::requires(Journal::<PM>::recovery_equivalent_for_app(s,
                                                    old_state));
                                            ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission(old_state,
                                                    s));
                                            let js2 = Journal::<PM>::recover(s).unwrap().state;
                                            KeyTable::<PM,
                                                    K>::lemma_recover_depends_only_on_my_area(js, js2, sm.keys);
                                            ItemTable::<PM,
                                                    I>::lemma_recover_depends_only_on_my_area(js, js2,
                                                recovered_keys.item_addrs(), sm.items);
                                            ListTable::<PM,
                                                    L>::lemma_recover_depends_only_on_my_area(js, js2,
                                                recovered_keys.list_addrs(), sm.lists);
                                        });
                            }
                        };
                }
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = perm_factory.clone() };
                #[verus::internal(infer_mode)]
                let mut journal_perm_factory;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let verus_tmp_journal_perm_factory = verus_tmp;
                    journal_perm_factory = verus_tmp_journal_perm_factory;
                };

                #[verifier::proof_block]
                {
                    Self::lemma_establish_recovery_equivalent_for_app(journal_perm_factory);
                }
                let journal =
                    match Journal::<PM>::start::<PermFactory>(powerpm,
                            #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] journal_perm_factory))
                        {
                        Ok(j) => j,
                        Err(JournalError::CRCError) => {
                            return Err(KvError::CRCMismatch);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                let jc: &JournalConstants = journal.constants();
                if jc.app_program_guid != KVSTORE_PROGRAM_GUID {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }
                if jc.app_version_number != KVSTORE_PROGRAM_VERSION_NUMBER {

                        #[verifier::proof_block]
                        {

                            #[verus::internal(const_header_wrapper)]
                            || { ::builtin::assert_(false) };
                        };
                        return Err(KvError::InternalError);
                    }

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    || { ::builtin::assert_(journal.recover_idempotent()) };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(Journal::<PM>::recovery_equivalent_for_app((journal.view()).read_state,
                                    old_state))
                        };
                };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(seqs_match_in_range((journal.view()).read_state,
                                    js,
                                    ::builtin::spec_cast_integer::<_, int>(jc.app_area_start),
                                    ::builtin::spec_cast_integer::<_, int>(jc.app_area_end)))
                        };
                };
                let sm =
                    match exec_recover_object::<PM,
                                KvStaticMetadata>(journal.get_pm_region_ref(),
                            jc.app_area_start,
                            jc.app_area_start + size_of::<KvStaticMetadata>() as u64) {
                        Some(sm) => sm,
                        None => { return Err(KvError::CRCMismatch); }
                    };
                if sm.id != kvstore_id {
                        return Err(KvError::WrongKvStoreId {
                                    requested_id: kvstore_id,
                                    actual_id: sm.id,
                                });
                    }
                let logical_range_gaps_policy =
                    match decode_policies(sm.encoded_policies) {
                        Some(p) => p,
                        None => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };

                #[verifier::proof_block]
                {
                    KeyTable::<PM,
                            K>::lemma_recover_depends_only_on_my_area(js,
                        (journal.view()).read_state, sm.keys);
                    ItemTable::<PM,
                            I>::lemma_recover_depends_only_on_my_area(js,
                        (journal.view()).read_state, recovered_keys.item_addrs(),
                        sm.items);
                    ListTable::<PM,
                            L>::lemma_recover_depends_only_on_my_area(js,
                        (journal.view()).read_state, recovered_keys.list_addrs(),
                        sm.lists);
                }
                let (keys, item_addrs, list_addrs) =
                    match KeyTable::<PM, K>::start(&journal, &sm.keys) {
                        Ok((k, i, l)) => (k, i, l),
                        Err(KvError::CRCMismatch) => {
                            return Err(KvError::CRCMismatch);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                let items =
                    match ItemTable::<PM,
                                I>::start(&journal, &item_addrs, &sm.items) {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            return Err(KvError::CRCMismatch);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };
                let lists =
                    match ListTable::<PM,
                                L>::start(&journal, logical_range_gaps_policy, &list_addrs,
                            &sm.lists) {
                        Ok(i) => i,
                        Err(KvError::CRCMismatch) => {
                            return Err(KvError::CRCMismatch);
                        }
                        _ => {

                            #[verifier::proof_block]
                            {

                                #[verus::internal(const_header_wrapper)]
                                || { ::builtin::assert_(false) };
                            };
                            return Err(KvError::InternalError);
                        }
                    };

                #[verifier::proof_block]
                {

                    #[verus::internal(const_header_wrapper)]
                    ||
                        {
                            ::builtin::assert_(::builtin::spec_eq((lists.view()).durable.m.dom(),
                                    (list_addrs.view()).to_set()))
                        };
                };
                let kv =
                    Self {
                        status: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] KvStoreStatus::Quiescent),
                        sm: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] sm),
                        used_key_slots: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] state.kv.num_keys()),
                        used_list_element_slots: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] state.kv.num_list_elements()),
                        used_transaction_operation_slots: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] ::builtin::spec_literal_integer("0")),
                        journal,
                        keys,
                        items,
                        lists,
                        perm_factory: #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory),
                    };

                #[verifier::proof_block]
                { kv.lemma_used_slots_correspond(); }
                Ok(kv)
            }
        }
    }
    pub mod util_v {
        #![allow(unused_imports)]
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use crate::common::subrange_v::*;
        use crate::journal::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use std::hash::Hash;
        use super::impl_v::*;
        use super::items::*;
        use super::keys::*;
        use super::lists::*;
        use super::recover_v::*;
        use super::spec_t::*;
        #[verus::internal(verus_macro)]
        impl<PermFactory, PM, K, I, L>
            UntrustedKvStoreImpl<PermFactory, PM, K, I, L> where
            PermFactory: PermissionFactory<Seq<u8>>,
            PM: PersistentMemoryRegion, K: Hash + PmCopy + Sized +
            std::fmt::Debug, I: PmCopy + Sized + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_establish_recovery_equivalent_for_app(perm_factory:
                    PermFactory) {
                ::builtin::requires([::builtin::forall(|s1: Seq<u8>,
                                    s2: Seq<u8>|
                                    ::builtin::imply(::builtin::spec_eq(Self::recover(s1),
                                            Self::recover(s2)),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([::builtin::forall(|s1: Seq<u8>,
                                    s2: Seq<u8>|
                                    ::builtin::imply(Journal::<PM>::recovery_equivalent_for_app(s1,
                                            s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2)))]);
                {
                    ::builtin::assert_forall_by(|s1: Seq<u8>, s2: Seq<u8>|
                            {
                                ::builtin::requires(Journal::<PM>::recovery_equivalent_for_app(s1,
                                        s2));
                                ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission(s1,
                                        s2));
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                                let r1 = Journal::<PM>::recover(s1).unwrap();
                                let jc = r1.constants;
                                let js1 = r1.state;
                                let r2 = Journal::<PM>::recover(s2).unwrap();
                                let js2 = r2.state;
                                ::builtin::assert_(::builtin::spec_eq(r1.constants,
                                        r2.constants));
                                if !::builtin::spec_eq(jc.app_program_guid,
                                                    KVSTORE_PROGRAM_GUID) ||
                                            !::builtin::spec_eq(jc.app_version_number,
                                                    KVSTORE_PROGRAM_VERSION_NUMBER)
                                        {} else if (((jc.app_area_start).spec_add(KvStaticMetadata::spec_size_of())).spec_add(u64::spec_size_of())).spec_gt(jc.app_area_end)
                                       {
                                       {
                                           ::builtin::assert_by(::builtin::is_variant(Self::recover(s1),
                                                       "None") && ::builtin::is_variant(Self::recover(s2), "None"),
                                               {
                                                   ::builtin::reveal_hide_({
                                                           #[verus::internal(reveal_fn)]
                                                           fn __VERUS_REVEAL_INTERNAL__() {
                                                               ::builtin::reveal_hide_internal_path_(recover_static_metadata)
                                                           }
                                                           __VERUS_REVEAL_INTERNAL__
                                                       }, 1);
                                               });
                                       }
                                   } else {
                                       ::builtin::assert_(states_match_in_static_metadata_area(js1,
                                               js2, jc));
                                       lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                               I, L>(js1, js2, jc);
                                       match recover_static_metadata::<K, I, L>(js1, jc) {
                                           None => {}
                                           Some(sm) => {
                                               {
                                                   ::builtin::assert_by(validate_static_metadata::<K, I,
                                                               L>(sm, jc),
                                                       {
                                                           ::builtin::reveal_hide_({
                                                                   #[verus::internal(reveal_fn)]
                                                                   fn __VERUS_REVEAL_INTERNAL__() {
                                                                       ::builtin::reveal_hide_internal_path_(recover_static_metadata)
                                                                   }
                                                                   __VERUS_REVEAL_INTERNAL__
                                                               }, 1);
                                                       });
                                               }
                                               if {
                                                           (((jc.journal_capacity).spec_lt((sm.max_operations_per_transaction).spec_mul(spec_space_needed_for_transaction_operation())))
                                                                       || (::builtin::is_variant(sm.setup_parameters(), "None")))
                                                               || (!sm.setup_parameters().unwrap().valid())
                                                       }
                                                       {} else {
                                                      KeyTable::<PM,
                                                              K>::lemma_recover_depends_only_on_my_area(js1, js2,
                                                          sm.keys);
                                                      match KeyTable::<PM, K>::recover(js1, sm.keys) {
                                                          None => {}
                                                          Some(keys) => {
                                                              ItemTable::<PM,
                                                                      I>::lemma_recover_depends_only_on_my_area(js1, js2,
                                                                  keys.item_addrs(), sm.items);
                                                              match ItemTable::<PM,
                                                                          I>::recover(js1, keys.item_addrs(), sm.items) {
                                                                  None => {}
                                                                  Some(items) => {
                                                                      ListTable::<PM,
                                                                              L>::lemma_recover_depends_only_on_my_area(js1, js2,
                                                                          keys.list_addrs(), sm.lists);
                                                                  }
                                                              }
                                                          }
                                                      }
                                                  }
                                           }
                                       }
                                   }
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_establish_recovery_equivalent_for_app_on_commit<Perm>(self,
                perm: Perm) where Perm: CheckPermission<Seq<u8>> {
                ::builtin::requires([self.valid(),
                            ::builtin::forall(|s1: Seq<u8>, s2: Seq<u8>|
                                    ::builtin::imply({
                                            (::builtin::spec_eq(Self::recover(s1),
                                                        Some(RecoveredKvStore::<K, I,
                                                                L> { ps: (self.view()).ps, kv: (self.view()).durable }))) &&
                                                (::builtin::spec_eq(Self::recover(s2),
                                                        Some(RecoveredKvStore::<K, I,
                                                                L> { ps: (self.view()).ps, kv: (self.view()).tentative })))
                                        },
                                        #[verus::internal(trigger)] perm.check_permission(s1,
                                            s2)))]);
                ::builtin::ensures([::builtin::forall(|s1: Seq<u8>,
                                    s2: Seq<u8>|
                                    ::builtin::imply({
                                            (Journal::<PM>::recovery_equivalent_for_app(s1,
                                                        (self.journal.view()).durable_state)) &&
                                                (Journal::<PM>::recovery_equivalent_for_app(s2,
                                                        (self.journal.view()).commit_state))
                                        },
                                        #[verus::internal(trigger)] perm.check_permission(s1,
                                            s2)))]);
                self.journal.lemma_recover_from_commit_idempotent();
                let jc = (self.journal.view()).constants;
                let js = (self.journal.view()).commit_state;
                let sm = (self.sm.view());
                let keys = (self.keys.view()).tentative.unwrap();
                {
                    ::builtin::assert_forall_by(|s1: Seq<u8>, s2: Seq<u8>|
                            {
                                ::builtin::requires({
                                        (Journal::<PM>::recovery_equivalent_for_app(s1,
                                                    (self.journal.view()).durable_state)) &&
                                            (Journal::<PM>::recovery_equivalent_for_app(s2,
                                                    (self.journal.view()).commit_state))
                                    });
                                ::builtin::ensures(#[verus::internal(trigger)] perm.check_permission(s1,
                                        s2));
                                {
                                    ::builtin::reveal_hide_({
                                            #[verus::internal(reveal_fn)]
                                            fn __VERUS_REVEAL_INTERNAL__() {
                                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                                            }

                                            #[verus::internal(broadcast_use_reveal)]
                                            __VERUS_REVEAL_INTERNAL__
                                        }, 1);
                                }
                                let js1 = Journal::<PM>::recover(s1).unwrap().state;
                                let js2 = Journal::<PM>::recover(s2).unwrap().state;
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>((self.journal.view()).durable_state, js1, jc);
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I,
                                        L>((self.journal.view()).durable_state,
                                    (self.journal.view()).commit_state, jc);
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>((self.journal.view()).commit_state, js2, jc);
                                self.keys.lemma_valid_implications((self.journal.view()));
                                self.items.lemma_valid_implications((self.journal.view()));
                                self.lists.lemma_valid_implications((self.journal.view()));
                                KeyTable::<PM,
                                        K>::lemma_recover_depends_only_on_my_area((self.journal.view()).durable_state,
                                    js1, sm.keys);
                                KeyTable::<PM,
                                        K>::lemma_recover_depends_only_on_my_area((self.journal.view()).commit_state,
                                    js2, sm.keys);
                                ItemTable::<PM,
                                        I>::lemma_recover_depends_only_on_my_area((self.journal.view()).durable_state,
                                    js1, (self.items.view()).durable.m.dom(), sm.items);
                                ItemTable::<PM,
                                        I>::lemma_recover_depends_only_on_my_area((self.journal.view()).commit_state,
                                    js2, keys.item_addrs(), sm.items);
                                ListTable::<PM,
                                        L>::lemma_recover_depends_only_on_my_area((self.journal.view()).durable_state,
                                    js1, (self.lists.view()).durable.m.dom(), sm.lists);
                                ListTable::<PM,
                                        L>::lemma_recover_depends_only_on_my_area((self.journal.view()).commit_state,
                                    js2, keys.list_addrs(), sm.lists);
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s1),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s2),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).tentative })));
                            });
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_inv_implies_recover_works(&self) {
                ::builtin::requires([self.inv()]);
                ::builtin::ensures([::builtin::spec_eq(Self::recover((self.journal.view()).durable_state),
                                Some(RecoveredKvStore::<K, I,
                                        L> { ps: (self.view()).ps, kv: (self.view()).durable }))]);
                self.keys.lemma_valid_implications((self.journal.view()));
                self.items.lemma_valid_implications((self.journal.view()));
                self.lists.lemma_valid_implications((self.journal.view()));
                ::builtin::assert_(::builtin::ext_equal(Self::recover((self.journal.view()).durable_state),
                        Some(RecoveredKvStore::<K, I,
                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_prepare_for_key_table_update(&self) -> Self {
                ::builtin::requires([self.inv(),
                            ::builtin::is_variant((self.status.view()),
                                "ComponentsDontCorrespond")]);
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq(result, self),
                                self.keys.perm_factory_permits_states_equivalent_for_me((self.journal.view()),
                                    (self.perm_factory.view()))]);
                #[verus::internal(spec)]
                let jc = (self.journal.view()).constants;
                #[verus::internal(spec)]
                let js = (self.journal.view()).durable_state;
                #[verus::internal(spec)]
                let sm = (self.sm.view());
                {
                    ::builtin::assert_by(::builtin::spec_eq(KeyTable::<PM,
                                    K>::recover(js, sm.keys), Some((self.keys.view()).durable)),
                        {
                            self.keys.lemma_valid_implications((self.journal.view()));
                        });
                }
                {
                    ::builtin::assert_by(::builtin::spec_eq(Self::recover(js),
                            Some(RecoveredKvStore::<K, I,
                                    L> { ps: (self.view()).ps, kv: (self.view()).durable })),
                        { self.lemma_inv_implies_recover_works(); });
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::assert_forall_by(|s1: Seq<u8>, s2: Seq<u8>|
                            {
                                ::builtin::requires({
                                        (KeyTable::<PM,
                                                        K>::state_equivalent_for_me(s1, js, jc,
                                                    (self.keys.view()).sm)) &&
                                            (KeyTable::<PM,
                                                        K>::state_equivalent_for_me(s2, js, jc,
                                                    (self.keys.view()).sm))
                                    });
                                ::builtin::ensures(#[verus::internal(trigger)] (self.perm_factory.view()).check_permission(s1,
                                        s2));
                                let js1 = Journal::<PM>::recover(s1).unwrap().state;
                                let js2 = Journal::<PM>::recover(s2).unwrap().state;
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>(js, js1, jc);
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>(js, js2, jc);
                                self.items.lemma_valid_implications((self.journal.view()));
                                self.lists.lemma_valid_implications((self.journal.view()));
                                ItemTable::<PM,
                                        I>::lemma_recover_depends_only_on_my_area(js, js1,
                                    (self.items.view()).durable.m.dom(), sm.items);
                                ItemTable::<PM,
                                        I>::lemma_recover_depends_only_on_my_area(js, js2,
                                    (self.items.view()).durable.m.dom(), sm.items);
                                ListTable::<PM,
                                        L>::lemma_recover_depends_only_on_my_area(js, js1,
                                    (self.lists.view()).durable.m.dom(), sm.lists);
                                ListTable::<PM,
                                        L>::lemma_recover_depends_only_on_my_area(js, js2,
                                    (self.lists.view()).durable.m.dom(), sm.lists);
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s1),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s2),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
                            });
                }
                *self
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_reflect_key_table_update(self,
                old_self: Self) {
                ::builtin::requires([old_self.inv(),
                            ::builtin::is_variant((old_self.status.view()),
                                "ComponentsDontCorrespond"),
                            self.keys.valid((self.journal.view())),
                            self.journal.valid(),
                            (old_self.journal.view()).matches_except_in_range((self.journal.view()),
                                ::builtin::spec_cast_integer::<_,
                                        int>((self.keys.view()).sm.start()),
                                ::builtin::spec_cast_integer::<_,
                                        int>((self.keys.view()).sm.end())),
                            ::builtin::spec_eq(self,
                                (Self {
                                        keys: self.keys,
                                        journal: self.journal,
                                        ..old_self
                                    })),
                            ::builtin::spec_eq((self.keys.view()),
                                (KeyTableView {
                                        tentative: (self.keys.view()).tentative,
                                        used_slots: (self.keys.view()).used_slots,
                                        ..(old_self.keys.view())
                                    })),
                            ::builtin::spec_eq((self.view()).powerpm_id,
                                (old_self.view()).powerpm_id)]);
                ::builtin::ensures([({
                                    let new_self: Self =
                                        if ::builtin::is_variant((self.keys.view()).tentative,
                                                    "Some") {
                                                self
                                            } else {
                                               Self {
                                                   status: ::builtin::Ghost::new(KvStoreStatus::MustAbort),
                                                   ..self
                                               }
                                           };
                                    new_self.inv()
                                })]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                self.journal.lemma_valid_implications();
                self.items.lemma_valid_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
                self.items.lemma_valid_implications((self.journal.view()));
                self.lists.lemma_valid_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
                self.lists.lemma_valid_implications((self.journal.view()));
                self.lemma_recover_static_metadata_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_prepare_for_item_table_update(&self) -> Self {
                ::builtin::requires([self.inv(),
                            ::builtin::is_variant((self.status.view()),
                                "ComponentsDontCorrespond")]);
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq(result, self),
                                self.items.perm_factory_permits_states_equivalent_for_me((self.journal.view()),
                                    (self.perm_factory.view()))]);
                #[verus::internal(spec)]
                let jc = (self.journal.view()).constants;
                #[verus::internal(spec)]
                let js = (self.journal.view()).durable_state;
                #[verus::internal(spec)]
                let sm = (self.sm.view());
                {
                    ::builtin::assert_by(::builtin::spec_eq(ItemTable::<PM,
                                    I>::recover(js, (self.items.view()).durable.m.dom(),
                                sm.items), Some((self.items.view()).durable)),
                        {
                            self.items.lemma_valid_implications((self.journal.view()));
                        });
                }
                {
                    ::builtin::assert_by(::builtin::spec_eq(Self::recover(js),
                            Some(RecoveredKvStore::<K, I,
                                    L> { ps: (self.view()).ps, kv: (self.view()).durable })),
                        { self.lemma_inv_implies_recover_works(); });
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::assert_forall_by(|s1: Seq<u8>, s2: Seq<u8>|
                            {
                                ::builtin::requires({
                                        (ItemTable::<PM,
                                                        I>::state_equivalent_for_me(s1, js,
                                                    (self.items.view()).durable.m.dom(), jc,
                                                    (self.items.view()).sm)) &&
                                            (ItemTable::<PM,
                                                        I>::state_equivalent_for_me(s2, js,
                                                    (self.items.view()).durable.m.dom(), jc,
                                                    (self.items.view()).sm))
                                    });
                                ::builtin::ensures(#[verus::internal(trigger)] (self.perm_factory.view()).check_permission(s1,
                                        s2));
                                let js1 = Journal::<PM>::recover(s1).unwrap().state;
                                let js2 = Journal::<PM>::recover(s2).unwrap().state;
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>(js, js1, jc);
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>(js, js2, jc);
                                self.keys.lemma_valid_implications((self.journal.view()));
                                self.lists.lemma_valid_implications((self.journal.view()));
                                KeyTable::<PM,
                                        K>::lemma_recover_depends_only_on_my_area(js, js1, sm.keys);
                                KeyTable::<PM,
                                        K>::lemma_recover_depends_only_on_my_area(js, js2, sm.keys);
                                ListTable::<PM,
                                        L>::lemma_recover_depends_only_on_my_area(js, js1,
                                    (self.lists.view()).durable.m.dom(), sm.lists);
                                ListTable::<PM,
                                        L>::lemma_recover_depends_only_on_my_area(js, js2,
                                    (self.lists.view()).durable.m.dom(), sm.lists);
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s1),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s2),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
                            });
                }
                *self
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_reflect_item_table_update(self,
                old_self: Self) {
                ::builtin::requires([old_self.inv(),
                            ::builtin::is_variant((old_self.status.view()),
                                "ComponentsDontCorrespond"),
                            self.items.valid((self.journal.view())),
                            self.journal.valid(),
                            (old_self.journal.view()).matches_except_in_range((self.journal.view()),
                                ::builtin::spec_cast_integer::<_,
                                        int>((self.items.view()).sm.start()),
                                ::builtin::spec_cast_integer::<_,
                                        int>((self.items.view()).sm.end())),
                            ::builtin::spec_eq(self,
                                (Self {
                                        items: self.items,
                                        journal: self.journal,
                                        ..old_self
                                    })),
                            ::builtin::spec_eq((self.items.view()),
                                (ItemTableView {
                                        tentative: (self.items.view()).tentative,
                                        used_slots: (self.items.view()).used_slots,
                                        ..(old_self.items.view())
                                    })),
                            ::builtin::spec_eq((self.view()).powerpm_id,
                                (old_self.view()).powerpm_id)]);
                ::builtin::ensures([({
                                    let new_self: Self =
                                        if ::builtin::is_variant((self.items.view()).tentative,
                                                    "Some") {
                                                self
                                            } else {
                                               Self {
                                                   status: ::builtin::Ghost::new(KvStoreStatus::MustAbort),
                                                   ..self
                                               }
                                           };
                                    new_self.inv()
                                })]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                self.journal.lemma_valid_implications();
                self.keys.lemma_valid_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
                self.keys.lemma_valid_implications((self.journal.view()));
                self.lists.lemma_valid_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
                self.lists.lemma_valid_implications((self.journal.view()));
                self.lemma_recover_static_metadata_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_prepare_for_list_table_update(&self) -> Self {
                ::builtin::requires([self.inv(),
                            ::builtin::is_variant((self.status.view()),
                                "ComponentsDontCorrespond")]);
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq(result, self),
                                self.lists.perm_factory_permits_states_equivalent_for_me((self.journal.view()),
                                    (self.perm_factory.view()))]);
                #[verus::internal(spec)]
                let jc = (self.journal.view()).constants;
                #[verus::internal(spec)]
                let js = (self.journal.view()).durable_state;
                #[verus::internal(spec)]
                let sm = (self.sm.view());
                {
                    ::builtin::assert_by(::builtin::spec_eq(ListTable::<PM,
                                    L>::recover(js, (self.lists.view()).durable.m.dom(),
                                sm.lists), Some((self.lists.view()).durable)),
                        {
                            self.lists.lemma_valid_implications((self.journal.view()));
                        });
                }
                {
                    ::builtin::assert_by(::builtin::spec_eq(Self::recover(js),
                            Some(RecoveredKvStore::<K, I,
                                    L> { ps: (self.view()).ps, kv: (self.view()).durable })),
                        { self.lemma_inv_implies_recover_works(); });
                }
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_seqs_match_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                {
                    ::builtin::assert_forall_by(|s1: Seq<u8>, s2: Seq<u8>|
                            {
                                ::builtin::requires({
                                        (ListTable::<PM,
                                                        L>::state_equivalent_for_me(s1,
                                                    (self.journal.view()).durable_state,
                                                    (self.lists.view()).durable.m.dom(),
                                                    (self.journal.view()).constants, (self.lists.view()).sm)) &&
                                            (ListTable::<PM,
                                                        L>::state_equivalent_for_me(s2,
                                                    (self.journal.view()).durable_state,
                                                    (self.lists.view()).durable.m.dom(),
                                                    (self.journal.view()).constants, (self.lists.view()).sm))
                                    });
                                ::builtin::ensures(#[verus::internal(trigger)] (self.perm_factory.view()).check_permission(s1,
                                        s2));
                                let js1 = Journal::<PM>::recover(s1).unwrap().state;
                                let js2 = Journal::<PM>::recover(s2).unwrap().state;
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>(js, js1, jc);
                                lemma_recover_static_metadata_depends_only_on_its_area::<K,
                                        I, L>(js, js2, jc);
                                self.keys.lemma_valid_implications((self.journal.view()));
                                self.lists.lemma_valid_implications((self.journal.view()));
                                KeyTable::<PM,
                                        K>::lemma_recover_depends_only_on_my_area(js, js1, sm.keys);
                                KeyTable::<PM,
                                        K>::lemma_recover_depends_only_on_my_area(js, js2, sm.keys);
                                ItemTable::<PM,
                                        I>::lemma_recover_depends_only_on_my_area(js, js1,
                                    (self.items.view()).durable.m.dom(), sm.items);
                                ItemTable::<PM,
                                        I>::lemma_recover_depends_only_on_my_area(js, js2,
                                    (self.items.view()).durable.m.dom(), sm.items);
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s1),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
                                ::builtin::assert_(::builtin::ext_equal(Self::recover(s2),
                                        Some(RecoveredKvStore::<K, I,
                                                L> { ps: (self.view()).ps, kv: (self.view()).durable })));
                            });
                }
                *self
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub(super) fn lemma_reflect_list_table_update(self,
                old_self: Self) {
                ::builtin::requires([old_self.inv(),
                            ::builtin::is_variant((old_self.status.view()),
                                "ComponentsDontCorrespond"),
                            self.lists.valid((self.journal.view())),
                            self.journal.valid(),
                            (old_self.journal.view()).matches_except_in_range((self.journal.view()),
                                ::builtin::spec_cast_integer::<_,
                                        int>((self.lists.view()).sm.start()),
                                ::builtin::spec_cast_integer::<_,
                                        int>((self.lists.view()).sm.end())),
                            ::builtin::spec_eq(self,
                                (Self {
                                        lists: self.lists,
                                        journal: self.journal,
                                        ..old_self
                                    })),
                            ::builtin::spec_eq((self.lists.view()),
                                (ListTableView {
                                        tentative: (self.lists.view()).tentative,
                                        used_slots: (self.lists.view()).used_slots,
                                        ..(old_self.lists.view())
                                    })),
                            ::builtin::spec_eq((self.view()).powerpm_id,
                                (old_self.view()).powerpm_id)]);
                ::builtin::ensures([({
                                    let new_self: Self =
                                        if ::builtin::is_variant((self.lists.view()).tentative,
                                                    "Some") {
                                                self
                                            } else {
                                               Self {
                                                   status: ::builtin::Ghost::new(KvStoreStatus::MustAbort),
                                                   ..self
                                               }
                                           };
                                    new_self.inv()
                                })]);
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(broadcast_journal_view_matches_in_range_can_narrow_range)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                self.journal.lemma_valid_implications();
                self.keys.lemma_valid_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
                self.keys.lemma_valid_implications((self.journal.view()));
                self.items.lemma_valid_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
                self.items.lemma_valid_implications((self.journal.view()));
                self.lists.lemma_valid_implications((self.journal.view()));
                self.lemma_recover_static_metadata_depends_only_on_my_area((old_self.journal.view()),
                    (self.journal.view()));
            }
        }
    }
}
pub mod pmem {
    #[cfg(target_os = "linux")]
    pub mod linux_pmemfile_t {
        #![verus::trusted]
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use core::ffi::c_void;
        use core::slice;
        use std::{cell::RefCell, convert::TryInto, ffi::CString, rc::Rc};
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use deps_hack::{
            pmem::pmem_memcpy_nodrain_helper, pmem_drain, pmem_errormsg,
            pmem_flush, pmem_map_file, pmem_memcpy_nodrain, pmem_unmap,
            rand::Rng, PMEM_FILE_CREATE, PMEM_FILE_EXCL,
        };
        pub struct MemoryMappedFile {
            virt_addr: *mut u8,
            size: usize,
            num_bytes_sectioned: usize,
        }
        impl Drop for MemoryMappedFile {
            fn drop(&mut self) {
                unsafe {
                    pmem_unmap(self.virt_addr as *mut c_void, self.size)
                };
            }
        }
        impl MemoryMappedFile {
            fn from_file<'a>(file_to_map: &str, size: usize,
                file_open_behavior: FileOpenBehavior,
                persistent_memory_check: PersistentMemoryCheck)
                -> Result<Self, PmemError> {
                let mut mapped_len = 0;
                let mut is_pm = 0;
                let file =
                    CString::new(file_to_map).map_err(|_|
                                PmemError::InvalidFileName)?;
                let file = file.as_c_str();
                let require_pm =
                    match persistent_memory_check {
                        PersistentMemoryCheck::CheckForPersistentMemory => true,
                        PersistentMemoryCheck::DontCheckForPersistentMemory =>
                            false,
                    };
                let create_flags =
                    match file_open_behavior {
                        FileOpenBehavior::CreateNew =>
                            PMEM_FILE_CREATE | PMEM_FILE_EXCL,
                        FileOpenBehavior::OpenExisting => 0,
                    };
                let len =
                    match file_open_behavior {
                        FileOpenBehavior::OpenExisting => 0,
                        FileOpenBehavior::CreateNew => size,
                    };
                let addr =
                    unsafe {
                        pmem_map_file(file.as_ptr(), len,
                            create_flags.try_into().unwrap(), 0o666, &mut mapped_len,
                            &mut is_pm)
                    };
                if addr.is_null() {
                        {
                            ::std::io::_eprint(format_args!("pmem_map_file: {0}\n",
                                    unsafe {
                                        CString::from_raw(pmem_errormsg() as
                                                        *mut i8).into_string().unwrap()
                                    }));
                        };
                        Err(PmemError::CannotOpenPmFile)
                    } else if is_pm == 0 && require_pm {
                       {
                           ::std::io::_eprint(format_args!("pmem_map_file: {0}\n",
                                   unsafe {
                                       CString::from_raw(pmem_errormsg() as
                                                       *mut i8).into_string().unwrap()
                                   }));
                       };
                       Err(PmemError::NotPm)
                   } else if addr as isize >= isize::MAX - mapped_len as isize
                       {
                       Err(PmemError::AccessOutOfRange)
                   } else {
                       Ok(Self {
                               virt_addr: addr as *mut u8,
                               size: mapped_len.try_into().unwrap(),
                               num_bytes_sectioned: 0,
                           })
                   }
            }
        }
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        pub struct MemoryMappedFileSection {
            mmf: Rc<RefCell<MemoryMappedFile>>,
            virt_addr: *mut u8,
            size: usize,
        }
        #[verus::internal(verus_macro)]
        impl MemoryMappedFileSection {
            #[verifier::external]
            #[verus::internal(verus_macro)]
            fn new(mmf: Rc<RefCell<MemoryMappedFile>>, len: usize)
                -> Result<Self, PmemError> {
                let mut mmf_borrowed = mmf.borrow_mut();
                let offset = mmf_borrowed.num_bytes_sectioned;
                let offset_as_isize: isize =
                    match offset.try_into() {
                        Ok(off) => off,
                        Err(_) => {
                            {
                                ::std::io::_eprint(format_args!("Can\'t express offset {0} as isize\n",
                                        offset));
                            };
                            return Err(PmemError::AccessOutOfRange)
                        }
                    };
                if offset + len > mmf_borrowed.size {
                        {
                            ::std::io::_eprint(format_args!("Can\'t allocate {0} bytes because only {1} remain\n",
                                    len, mmf_borrowed.size - offset));
                        };
                        return Err(PmemError::AccessOutOfRange);
                    }
                mmf_borrowed.num_bytes_sectioned += len;
                let new_virt_addr =
                    unsafe { mmf_borrowed.virt_addr.offset(offset_as_isize) };
                std::mem::drop(mmf_borrowed);
                let section =
                    Self { mmf, virt_addr: new_virt_addr, size: len };
                Ok(section)
            }
        }
        #[verus::internal(verus_macro)]
        pub enum FileOpenBehavior { CreateNew, OpenExisting, }
        #[automatically_derived]
        impl ::core::clone::Clone for FileOpenBehavior {
            #[inline]
            fn clone(&self) -> FileOpenBehavior { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FileOpenBehavior { }
        #[automatically_derived]
        impl ::core::fmt::Debug for FileOpenBehavior {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        FileOpenBehavior::CreateNew => "CreateNew",
                        FileOpenBehavior::OpenExisting => "OpenExisting",
                    })
            }
        }
        #[verus::internal(verus_macro)]
        pub enum PersistentMemoryCheck {
            CheckForPersistentMemory,
            DontCheckForPersistentMemory,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PersistentMemoryCheck {
            #[inline]
            fn clone(&self) -> PersistentMemoryCheck { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for PersistentMemoryCheck { }
        #[verus::internal(verus_macro)]
        pub struct FileBackedPersistentMemoryRegion {
            section: MemoryMappedFileSection,
        }
        #[verus::internal(verus_macro)]
        impl FileBackedPersistentMemoryRegion {
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn new_internal(path: &str, region_size: u64,
                open_behavior: FileOpenBehavior,
                persistent_memory_check: PersistentMemoryCheck)
                -> Result<Self, PmemError> {
                ::builtin::ensures(|result: Result<Self, PmemError>|
                        [match result {
                                    Ok(region) =>
                                        region.inv() && (region.view()).valid() &&
                                            ::builtin::spec_eq((region.view()).len(), region_size),
                                    Err(_) => true,
                                }]);
                let mmf =
                    MemoryMappedFile::from_file(path, region_size as usize,
                            open_behavior, persistent_memory_check)?;
                let mmf =
                    Rc::<RefCell<MemoryMappedFile>>::new(RefCell::<MemoryMappedFile>::new(mmf));
                let section =
                    MemoryMappedFileSection::new(mmf, region_size as usize)?;
                Ok(Self { section })
            }
            #[verus::internal(verus_macro)]
            pub fn new(path: &str, region_size: u64,
                persistent_memory_check: PersistentMemoryCheck)
                -> Result<Self, PmemError> {
                ::builtin::ensures(|result: Result<Self, PmemError>|
                        [match result {
                                    Ok(region) =>
                                        region.inv() && (region.view()).valid() &&
                                            ::builtin::spec_eq((region.view()).len(), region_size),
                                    Err(_) => true,
                                }]);
                Self::new_internal(path, region_size,
                    FileOpenBehavior::CreateNew, persistent_memory_check)
            }
            #[verus::internal(verus_macro)]
            pub fn restore(path: &str, region_size: u64)
                -> Result<Self, PmemError> {
                ::builtin::ensures(|result: Result<Self, PmemError>|
                        [match result {
                                    Ok(region) =>
                                        region.inv() && (region.view()).valid() &&
                                            ::builtin::spec_eq((region.view()).len(), region_size),
                                    Err(_) => true,
                                }]);
                Self::new_internal(path, region_size,
                    FileOpenBehavior::OpenExisting,
                    PersistentMemoryCheck::DontCheckForPersistentMemory)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn new_from_section(section: MemoryMappedFileSection) -> Self {
                Self { section }
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn get_slice_at_offset(&self, addr: u64, len: u64)
                -> Result<&[u8], PmemError> {
                ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            addr), (addr).spec_add(len)), (self.view()).len()))]);
                ::builtin::ensures(|result: Result<&[u8], PmemError>|
                        [match result {
                                    Ok(slice) => {
                                        let addrs =
                                            Seq::new(::builtin::spec_cast_integer::<_, nat>(len),
                                                ::builtin::closure_to_fn_spec(|i: int| (addr).spec_add(i)));
                                        self.constants().maybe_corrupted((slice.view()),
                                            (self.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                        int>(addr), (addr).spec_add(len)), addrs)
                                    }
                                    _ => false,
                                }]);
                let raw_addr = addr as isize;
                let addr_on_pm: *const u8 =
                    unsafe { self.section.virt_addr.offset(raw_addr) };
                let pm_slice: &[u8] =
                    unsafe {
                        std::slice::from_raw_parts(addr_on_pm, len as usize)
                    };
                Ok(pm_slice)
            }
        }
        #[verus::internal(verus_macro)]
        impl PersistentMemoryRegion for FileBackedPersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            fn view(&self) -> PersistentMemoryRegionView {
                ::core::panicking::panic("not implemented")
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            fn constants(&self) -> PersistentMemoryConstants {
                ::core::panicking::panic("not implemented")
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn inv(&self) -> bool { self.constants().valid() }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn lemma_inv_implies_view_valid(&self) {}
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn get_region_size(&self) -> u64 { self.section.size as u64 }
            #[verus::internal(verus_macro)]
            fn read_aligned<S>(&self, addr: u64)
                -> Result<MaybeCorruptedBytes<S>, PmemError> where S: PmCopy {
                let pm_slice =
                    self.get_slice_at_offset(addr, S::size_of() as u64)?;
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        Seq::new(::builtin::spec_cast_integer::<_,
                                    nat>(S::spec_size_of()),
                            ::builtin::closure_to_fn_spec(|i: int| (addr).spec_add(i)))
                };
                #[verus::internal(spec)]
                let mut addrs;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_addrs = verus_tmp;
                    addrs = verus_tmp_addrs;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        (self.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                    int>(addr), (addr).spec_add(S::spec_size_of()))
                };
                #[verus::internal(spec)]
                let mut true_bytes;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_true_bytes = verus_tmp;
                    true_bytes = verus_tmp_true_bytes;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = S::spec_from_bytes(true_bytes) };
                #[verus::internal(spec)]
                let mut true_val;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_true_val = verus_tmp;
                    true_val = verus_tmp_true_val;
                };
                let mut maybe_corrupted_val = MaybeCorruptedBytes::new();
                maybe_corrupted_val.copy_from_slice(pm_slice,
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_val),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] addrs),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] self.constants()));
                Ok(maybe_corrupted_val)
            }
            #[verus::internal(verus_macro)]
            fn read_unaligned(&self, addr: u64, num_bytes: u64)
                -> Result<Vec<u8>, PmemError> {
                let pm_slice = self.get_slice_at_offset(addr, num_bytes)?;
                let unaligned_buffer = copy_from_slice(pm_slice);
                Ok(unaligned_buffer)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn write(&mut self, addr: u64, bytes: &[u8]) {
                let addr_on_pm: *mut u8 =
                    unsafe {
                        self.section.virt_addr.offset(addr.try_into().unwrap())
                    };
                unsafe {
                    pmem_memcpy_nodrain_helper(addr_on_pm as *mut c_void,
                        bytes.as_ptr() as *const c_void, bytes.len());
                }
            }
            #[verifier::external_body]
            #[allow(unused_variables)]
            #[verus::internal(verus_macro)]
            fn serialize_and_write<S>(&mut self, addr: u64, to_write: &S)
                where S: PmCopy + Sized {
                let num_bytes: usize = S::size_of() as usize;
                let addr_on_pm: *mut u8 =
                    unsafe {
                        self.section.virt_addr.offset(addr.try_into().unwrap())
                    };
                let s_pointer = to_write as *const S as *const u8;
                unsafe {
                    pmem_memcpy_nodrain_helper(addr_on_pm as *mut c_void,
                        s_pointer as *const c_void, num_bytes);
                }
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn flush(&mut self) { unsafe { pmem_drain(); } }
        }
    }
    #[cfg(target_family = "unix")]
    pub mod mmap_pmemfile_t {
        #![verus::trusted]
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::pmemspec_t::*;
        use core::ffi::c_void;
        use core::slice;
        use deps_hack::memmap::MmapMut;
        use std::fs::OpenOptions;
        use std::sync::Arc;
        use std::{cell::RefCell, convert::TryInto, ffi::CString, rc::Rc};
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use deps_hack::rand::Rng;
        pub struct MemoryMappedFile {
            mmap: MmapMut,
            num_bytes_sectioned: usize,
        }
        impl MemoryMappedFile {
            fn from_file<'a>(file_to_map: &str, size: usize,
                file_open_behavior: FileOpenBehavior)
                -> Result<Self, PmemError> {
                let mut file;
                match file_open_behavior {
                    FileOpenBehavior::CreateNew => {
                        file =
                            match OpenOptions::new().read(true).write(true).create_new(true).open(file_to_map)
                                {
                                Ok(file) => file,
                                Err(e) => {
                                    { ::std::io::_eprint(format_args!("open: {0:?}\n", e)); };
                                    return Err(PmemError::CannotOpenPmFile);
                                }
                            };
                        match file.set_len(size as u64) {
                            Ok(_) => (),
                            Err(e) => {
                                {
                                    ::std::io::_eprint(format_args!("set_len: {0:?}\n", e));
                                };
                                return Err(PmemError::CannotOpenPmFile);
                            }
                        };
                    }
                    FileOpenBehavior::OpenExisting => {
                        file =
                            match OpenOptions::new().read(true).write(true).open(file_to_map)
                                {
                                Ok(file) => file,
                                Err(e) => {
                                    { ::std::io::_eprint(format_args!("open: {0:?}\n", e)); };
                                    return Err(PmemError::CannotOpenPmFile);
                                }
                            };
                    }
                };
                let mmap =
                    match unsafe { MmapMut::map_mut(&file) } {
                        Ok(mmap) => mmap,
                        Err(e) => {
                            { ::std::io::_eprint(format_args!("mmap: {0:?}\n", e)); };
                            return Err(PmemError::CannotOpenPmFile);
                        }
                    };
                Ok(Self { mmap: mmap, num_bytes_sectioned: 0 })
            }
        }
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        pub struct MemoryMappedFileSection {
            mmf: Rc<RefCell<MemoryMappedFile>>,
            offset: usize,
            size: usize,
        }
        #[verus::internal(verus_macro)]
        impl MemoryMappedFileSection {
            #[verifier::external]
            #[verus::internal(verus_macro)]
            fn new(mmf: Rc<RefCell<MemoryMappedFile>>, len: usize)
                -> Result<Self, PmemError> {
                let mut mmf_borrowed = mmf.borrow_mut();
                let offset = mmf_borrowed.num_bytes_sectioned;
                if len > mmf_borrowed.mmap.len() - offset {
                        {
                            ::std::io::_eprint(format_args!("Can\'t allocate {0} bytes because only {1} remain\n",
                                    len, mmf_borrowed.mmap.len() - offset));
                        };
                        return Err(PmemError::AccessOutOfRange);
                    }
                mmf_borrowed.num_bytes_sectioned += len;
                std::mem::drop(mmf_borrowed);
                let section = Self { mmf, offset: offset, size: len };
                Ok(section)
            }
        }
        #[verus::internal(verus_macro)]
        pub enum FileOpenBehavior { CreateNew, OpenExisting, }
        #[automatically_derived]
        impl ::core::clone::Clone for FileOpenBehavior {
            #[inline]
            fn clone(&self) -> FileOpenBehavior { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FileOpenBehavior { }
        #[automatically_derived]
        impl ::core::fmt::Debug for FileOpenBehavior {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        FileOpenBehavior::CreateNew => "CreateNew",
                        FileOpenBehavior::OpenExisting => "OpenExisting",
                    })
            }
        }
        #[verus::internal(verus_macro)]
        pub struct FileBackedPersistentMemoryRegion {
            section: MemoryMappedFileSection,
        }
        #[verus::internal(verus_macro)]
        impl FileBackedPersistentMemoryRegion {
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn new_internal(path: &str, region_size: u64,
                open_behavior: FileOpenBehavior) -> Result<Self, PmemError> {
                ::builtin::ensures(|result: Result<Self, PmemError>|
                        [match result {
                                    Ok(region) =>
                                        region.inv() && (region.view()).valid() &&
                                            ::builtin::spec_eq((region.view()).len(), region_size),
                                    Err(_) => true,
                                }]);
                let mmf =
                    MemoryMappedFile::from_file(path, region_size as usize,
                            open_behavior)?;
                let mmf =
                    Rc::<RefCell<MemoryMappedFile>>::new(RefCell::<MemoryMappedFile>::new(mmf));
                let section =
                    MemoryMappedFileSection::new(mmf, region_size as usize)?;
                Ok(Self { section })
            }
            #[verus::internal(verus_macro)]
            pub fn new(path: &str, region_size: u64)
                -> Result<Self, PmemError> {
                ::builtin::ensures(|result: Result<Self, PmemError>|
                        [match result {
                                    Ok(region) =>
                                        region.inv() && (region.view()).valid() &&
                                            ::builtin::spec_eq((region.view()).len(), region_size),
                                    Err(_) => true,
                                }]);
                Self::new_internal(path, region_size,
                    FileOpenBehavior::CreateNew)
            }
            #[verus::internal(verus_macro)]
            pub fn restore(path: &str, region_size: u64)
                -> Result<Self, PmemError> {
                ::builtin::ensures(|result: Result<Self, PmemError>|
                        [match result {
                                    Ok(region) =>
                                        region.inv() && (region.view()).valid() &&
                                            ::builtin::spec_eq((region.view()).len(), region_size),
                                    Err(_) => true,
                                }]);
                Self::new_internal(path, region_size,
                    FileOpenBehavior::OpenExisting)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn new_from_section(section: MemoryMappedFileSection) -> Self {
                Self { section }
            }
        }
        #[verus::internal(verus_macro)]
        impl PersistentMemoryRegion for FileBackedPersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            fn view(&self) -> PersistentMemoryRegionView {
                ::core::panicking::panic("not implemented")
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            fn constants(&self) -> PersistentMemoryConstants {
                ::core::panicking::panic("not implemented")
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn inv(&self) -> bool { self.constants().valid() }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn lemma_inv_implies_view_valid(&self) {}
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn get_region_size(&self) -> u64 { self.section.size as u64 }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn read_aligned<S>(&self, addr: u64)
                -> Result<MaybeCorruptedBytes<S>, PmemError> where S: PmCopy {
                let mut mmf_borrowed = self.section.mmf.borrow_mut();
                let pm_slice: &[u8] =
                    &mmf_borrowed.mmap[addr as
                                    usize..addr as usize + S::size_of()];
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        Seq::new(::builtin::spec_cast_integer::<_,
                                    nat>(S::spec_size_of()),
                            ::builtin::closure_to_fn_spec(|i: int| (addr).spec_add(i)))
                };
                #[verus::internal(spec)]
                let mut addrs;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_addrs = verus_tmp;
                    addrs = verus_tmp_addrs;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        (self.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                    int>(addr), (addr).spec_add(S::spec_size_of()))
                };
                #[verus::internal(spec)]
                let mut true_bytes;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_true_bytes = verus_tmp;
                    true_bytes = verus_tmp_true_bytes;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = S::spec_from_bytes(true_bytes) };
                #[verus::internal(spec)]
                let mut true_val;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_true_val = verus_tmp;
                    true_val = verus_tmp_true_val;
                };
                let mut maybe_corrupted_val = MaybeCorruptedBytes::new();
                maybe_corrupted_val.copy_from_slice(pm_slice,
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_val),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] addrs),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] self.constants()));
                Ok(maybe_corrupted_val)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn read_unaligned(&self, addr: u64, num_bytes: u64)
                -> Result<Vec<u8>, PmemError> {
                let mut mmf_borrowed = self.section.mmf.borrow_mut();
                let pm_slice: &[u8] =
                    &mmf_borrowed.mmap[addr as
                                    usize..(addr + num_bytes) as usize];
                let unaligned_buffer = copy_from_slice(pm_slice);
                Ok(unaligned_buffer)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn write(&mut self, addr: u64, bytes: &[u8]) {
                let mut mmf_borrowed = self.section.mmf.borrow_mut();
                mmf_borrowed.mmap[addr as
                                usize..addr as usize + bytes.len()].copy_from_slice(bytes);
            }
            #[verifier::external_body]
            #[allow(unused_variables)]
            #[verus::internal(verus_macro)]
            fn serialize_and_write<S>(&mut self, addr: u64, to_write: &S)
                where S: PmCopy + Sized {
                let num_bytes: usize = S::size_of() as usize;
                let s_pointer = to_write as *const S as *const u8;
                let s_slice =
                    unsafe { std::slice::from_raw_parts(s_pointer, num_bytes) };
                let mut mmf_borrowed = self.section.mmf.borrow_mut();
                mmf_borrowed.mmap[addr as
                                usize..addr as usize + num_bytes].copy_from_slice(s_slice);
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn flush(&mut self) {
                let mut mmf_borrowed = self.section.mmf.borrow_mut();
                match mmf_borrowed.mmap.flush() {
                    Ok(_) => (),
                    Err(e) => {
                        { ::std::io::_eprint(format_args!("flush: {0:?}\n", e)); };
                    }
                };
            }
        }
    }
    pub mod crc_t {
        #![verus::trusted]
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use builtin::*;
        use builtin_macros::*;
        use vstd::bytes::*;
        use vstd::prelude::*;
        use deps_hack::crc64fast::Digest;
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        struct ExternalDigest {
            digest: Digest,
        }
        #[verus::internal(verus_macro)]
        pub struct CrcDigest {
            digest: ExternalDigest,
            bytes_in_digest: Ghost<Seq<u8>>,
        }
        #[verus::internal(verus_macro)]
        impl CrcDigest {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn bytes_in_digest(self) -> Seq<u8> {
                (self.bytes_in_digest.view())
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            pub fn new() -> Self {
                ::builtin::ensures(|output: Self|
                        [::builtin::spec_eq(output.bytes_in_digest(),
                                    Seq::<u8>::empty())]);
                Self {
                    digest: ExternalDigest { digest: Digest::new() },
                    bytes_in_digest: #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] Seq::<u8>::empty()),
                }
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            pub fn write<S>(&mut self, val: &S) where S: PmCopy {
                ::builtin::ensures([::builtin::spec_eq(self.bytes_in_digest(),
                                (old(self).bytes_in_digest()).spec_add(val.spec_to_bytes()))]);
                let num_bytes: usize = S::size_of().try_into().unwrap();
                let s_pointer = val as *const S;
                let bytes_pointer = s_pointer as *const u8;
                let bytes =
                    unsafe {
                        std::slice::from_raw_parts(bytes_pointer, num_bytes)
                    };
                self.digest.digest.write(bytes);
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            pub fn write_bytes(&mut self, val: &[u8]) {
                ::builtin::ensures([::builtin::spec_eq(self.bytes_in_digest(),
                                (old(self).bytes_in_digest()).spec_add((val.view())))]);
                self.digest.digest.write(val);
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            pub fn sum64(&self) -> u64 {
                ::builtin::ensures(|output: u64|
                        [::builtin::spec_eq(output,
                                    spec_crc_u64(self.bytes_in_digest())),
                                ::builtin::spec_eq(output.spec_to_bytes(),
                                    spec_crc_bytes(self.bytes_in_digest()))]);
                self.digest.digest.sum64()
            }
        }
    }
    pub mod hamming_t {
        #![verus::trusted]
        use vstd::prelude::*;
        use vstd::seq_lib::*;
        use vstd::relations::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn sum(l: Seq<nat>) -> nat {
            l.fold_right(::builtin::closure_to_fn_spec(|i, s: nat|
                        {
                            (s).spec_add(::builtin::spec_cast_integer::<_, nat>(i))
                        }), ::builtin::spec_literal_integer("0"))
        }
        #[verifier::inline]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn _popcnt_byte(a: u8) -> nat {
            let p0 = (1u8).spec_bitand(((a).spec_shr(0u8)));
            let p1 = (1u8).spec_bitand(((a).spec_shr(1u8)));
            let p2 = (1u8).spec_bitand(((a).spec_shr(2u8)));
            let p3 = (1u8).spec_bitand(((a).spec_shr(3u8)));
            let p4 = (1u8).spec_bitand(((a).spec_shr(4u8)));
            let p5 = (1u8).spec_bitand(((a).spec_shr(5u8)));
            let p6 = (1u8).spec_bitand(((a).spec_shr(6u8)));
            let p7 = (1u8).spec_bitand(((a).spec_shr(7u8)));
            let sum =
                add(p0,
                    add(p1, add(p2, add(p3, add(p4, add(p5, add(p6, p7)))))));
            ::builtin::spec_cast_integer::<_, nat>(sum)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn popcnt_byte(a: u8) -> nat { _popcnt_byte(a) }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn popcnt_seq(l: Seq<u8>) -> Seq<nat> {
            l.map_values(::builtin::closure_to_fn_spec(|v: u8|
                        popcnt_byte(v)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn popcnt(l: Seq<u8>) -> nat { sum(popcnt_seq(l)) }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn xor(a: Seq<u8>, b: Seq<u8>) -> Seq<u8> {
            a.zip_with(b).map_values(::builtin::closure_to_fn_spec(|v:
                            (u8, u8)| (v.0).spec_bitxor(v.1)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn hamming(a: Seq<u8>, b: Seq<u8>) -> nat { popcnt(xor(a, b)) }
    }
    pub mod hamming_v {
        use vstd::prelude::*;
        use super::hamming_t::*;
        use vstd::seq_lib::*;
        use vstd::relations::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn valid_index<T>(s: Seq<T>, i: int) -> bool {
            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                        i), s.len()))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn valid_indexes<T>(s: Seq<T>, indexes: Seq<int>) -> bool {
            ::builtin::forall(|i: int|
                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    i), indexes.len())),
                        #[verus::internal(trigger)] valid_index(s,
                            indexes.spec_index(i))))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn valid_indexes_permute<T>(s: Seq<T>, idx1: Seq<int>,
            idx2: Seq<int>) {
            ::builtin::requires([valid_indexes(s, idx1),
                        ::builtin::spec_eq(idx1.to_multiset(),
                            idx2.to_multiset())]);
            ::builtin::ensures([valid_indexes(s, idx2)]);
            {
                ::builtin::assert_forall_by(|i: int|
                        {
                            ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                            i), idx2.len())));
                            ::builtin::ensures(#[verus::internal(trigger)] valid_index(s,
                                    idx2.spec_index(i)));
                            let idx = idx2.spec_index(i);
                            idx1.to_multiset_ensures();
                            idx2.to_multiset_ensures();
                            ::builtin::assert_((idx2.to_multiset().count(idx)).spec_gt(::builtin::spec_literal_nat("0")));
                        });
            }
        }
        #[verus::internal(verus_macro)]
        pub struct WSeq<T> {
            pub s: Seq<T>,
        }
        #[verus::internal(verus_macro)]
        impl<T> WSeq<T> {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn spec_index(self, idx: Seq<int>) -> Seq<T> {
                ::builtin::recommends([valid_indexes(self.s, idx)]);
                idx.map_values(::builtin::closure_to_fn_spec(|a: int|
                            self.s.spec_index(a)))
            }
        }
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn S<T>(s: Seq<T>) -> WSeq<T> { WSeq { s: s } }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn indexes_first<T>(s: Seq<T>, indexes: Seq<int>) {
            ::builtin::requires([(indexes.len()).spec_gt(::builtin::spec_literal_nat("0")),
                        valid_indexes(s, indexes)]);
            ::builtin::ensures([::builtin::ext_equal(S(s).spec_index(indexes),
                            (::vstd::vstd::seq::Seq::empty().push(s.spec_index(indexes.first()))).spec_add(S(s).spec_index(indexes.drop_first()))),
                        valid_index(s, indexes.first()),
                        valid_indexes(s, indexes.drop_first())]);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn indexes_permute<T>(s: Seq<T>, idx1: Seq<int>, idx2: Seq<int>) {
            ::builtin::requires([valid_indexes(s, idx1),
                        ::builtin::spec_eq(idx1.to_multiset(),
                            idx2.to_multiset())]);
            ::builtin::ensures([::builtin::ext_equal(S(s).spec_index(idx1).to_multiset(),
                            S(s).spec_index(idx2).to_multiset())]);
            ::builtin::decreases((idx1.len()));
            idx1.to_multiset_ensures();
            idx2.to_multiset_ensures();
            S(s).spec_index(idx1).to_multiset_ensures();
            S(s).spec_index(idx2).to_multiset_ensures();
            if (idx1.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    let i = idx1.first();
                    ::builtin::assert_(idx1.to_multiset().contains(i));
                    let idx2pos = idx2.index_of(i);
                    let idx1rec =
                        idx1.remove(::builtin::spec_literal_integer("0"));
                    let idx2rec = idx2.remove(idx2pos);
                    indexes_permute(s, idx1rec, idx2rec);
                    lemma_seq_union_to_multiset_commutative(::vstd::vstd::seq::Seq::empty().push(s.spec_index(i)),
                        S(s).spec_index(idx1rec));
                    lemma_multiset_commutative(S(s).spec_index(idx1rec),
                        ::vstd::vstd::seq::Seq::empty().push(s.spec_index(i)));
                    ::vstd::vstd::seq::Seq::empty().push(s.spec_index(i)).to_multiset_ensures();
                    ::builtin::assert_(::builtin::spec_eq(::vstd::vstd::seq::Seq::empty().push(s.spec_index(i)).first(),
                            s.spec_index(i)));
                    ::builtin::assert_(::builtin::ext_equal(S(s).spec_index(idx1),
                            (::vstd::vstd::seq::Seq::empty().push(s.spec_index(i))).spec_add(S(s).spec_index(idx1rec))));
                    ::builtin::assert_(::builtin::ext_equal(S(s).spec_index(idx2rec),
                            S(s).spec_index(idx2).remove(idx2pos)));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn sum_permute(s1: Seq<nat>, s2: Seq<nat>) {
            ::builtin::requires([::builtin::spec_eq(s1.to_multiset(),
                            s2.to_multiset())]);
            ::builtin::ensures([::builtin::spec_eq(sum(s1), sum(s2))]);
            lemma_fold_right_permutation(s1, s2,
                ::builtin::closure_to_fn_spec(|i, s: nat|
                        {
                            (s).spec_add(::builtin::spec_cast_integer::<_, nat>(i))
                        }), ::builtin::spec_literal_integer("0"))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn sum_concat(s1: Seq<nat>, s2: Seq<nat>) {
            ::builtin::ensures([::builtin::spec_eq(sum((s1).spec_add(s2)),
                            (sum(s1)).spec_add(sum(s2)))]);
            let s = (s1).spec_add(s2);
            ::builtin::assert_(::builtin::spec_eq(s1,
                    s.subrange(::builtin::spec_literal_integer("0"),
                        ::builtin::spec_cast_integer::<_, int>(s1.len()))));
            ::builtin::assert_(::builtin::spec_eq(s2,
                    s.subrange(::builtin::spec_cast_integer::<_, int>(s1.len()),
                        ::builtin::spec_cast_integer::<_, int>(s.len()))));
            s.lemma_fold_right_split(::builtin::closure_to_fn_spec(|i, s: nat|
                        {
                            (s).spec_add(::builtin::spec_cast_integer::<_, nat>(i))
                        }), ::builtin::spec_literal_integer("0"),
                ::builtin::spec_cast_integer::<_, int>(s1.len()));
            s1.lemma_fold_right_commute_one(sum(s2),
                ::builtin::closure_to_fn_spec(|i, s: nat|
                        {
                            (s).spec_add(::builtin::spec_cast_integer::<_, nat>(i))
                        }), ::builtin::spec_literal_integer("0"));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn sum_remove(s: Seq<nat>, i: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    i), s.len()))]);
            ::builtin::ensures([::builtin::spec_eq(sum(s),
                            (s.spec_index(i)).spec_add(sum(s.remove(i))))]);
            let s1 = s.subrange(::builtin::spec_literal_integer("0"), i);
            let s2 =
                s.subrange(i,
                    ::builtin::spec_cast_integer::<_, int>(s.len()));
            ::builtin::assert_(::builtin::spec_eq(s, (s1).spec_add(s2)));
            ::builtin::assert_(::builtin::spec_eq(s.remove(i),
                    (s1).spec_add(s2.drop_first())));
            sum_concat(s1, s2);
            ::builtin::assert_(::builtin::spec_eq(sum(s),
                    (sum(s1)).spec_add(sum(s2))));
            sum_concat(s1, s2.drop_first());
            ::builtin::assert_(::builtin::spec_eq(sum(s.remove(i)),
                    (sum(s1)).spec_add(sum(s2.drop_first()))));
            s2.lemma_fold_right_alt(::builtin::closure_to_fn_spec(|i, s: nat|
                        {
                            (s).spec_add(::builtin::spec_cast_integer::<_, nat>(i))
                        }), ::builtin::spec_literal_integer("0"));
            s2.drop_first().lemma_fold_right_alt(::builtin::closure_to_fn_spec(|i,
                        s: nat|
                        {
                            (s).spec_add(::builtin::spec_cast_integer::<_, nat>(i))
                        }), ::builtin::spec_literal_integer("0"));
            ::builtin::assert_(::builtin::spec_eq(sum(s2),
                    (s2.spec_index(::builtin::spec_literal_integer("0"))).spec_add(sum(s2.drop_first()))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn sum_indexes(s: Seq<nat>, idx: Seq<int>) {
            ::builtin::requires([idx.no_duplicates(), valid_indexes(s, idx)]);
            ::builtin::ensures([(sum(S(s).spec_index(idx))).spec_le(sum(s))]);
            idx.lemma_sort_ensures();
            let idx_sorted = idx.sort();
            idx.lemma_multiset_has_no_duplicates();
            idx_sorted.lemma_multiset_has_no_duplicates_conv();
            valid_indexes_permute(s, idx, idx_sorted);
            sum_indexes_helper(s, idx_sorted);
            indexes_permute(s, idx, idx_sorted);
            sum_permute(S(s).spec_index(idx), S(s).spec_index(idx_sorted));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn sum_indexes_helper(s: Seq<nat>, indexes: Seq<int>) {
            ::builtin::requires([indexes.no_duplicates(),
                        valid_indexes(s, indexes),
                        sorted_by(indexes,
                            ::builtin::closure_to_fn_spec(|x: int, y: int|
                                    (x).spec_le(y)))]);
            ::builtin::ensures([(sum(S(s).spec_index(indexes))).spec_le(sum(s))]);
            ::builtin::decreases((s.len()));
            if (indexes.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    let i = indexes.last();
                    ::builtin::assert_(valid_index(s, i));
                    let s0 =
                        s.subrange(::builtin::spec_literal_integer("0"), i);
                    let s1 =
                        s.subrange(i,
                            ::builtin::spec_cast_integer::<_, int>(s.len()));
                    ::builtin::assert_(::builtin::spec_eq(s,
                            (s0).spec_add(s1)));
                    sum_concat(s0, s1);
                    {
                        ::builtin::assert_forall_by(|j: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    j), indexes.drop_last().len())));
                                    ::builtin::ensures(#[verus::internal(trigger)] valid_index(s0,
                                            indexes.drop_last().spec_index(j)));
                                    let idx = indexes.drop_last().spec_index(j);
                                    ::builtin::assert_(valid_index(s, idx));
                                    ::builtin::assert_((::builtin::closure_to_fn_spec(|x: int,
                                                        y: int|
                                                        (x).spec_le(y)))(indexes.spec_index(j), indexes.last()));
                                });
                    }
                    sum_indexes_helper(s0, indexes.drop_last());
                    {
                        ::builtin::assert_forall_by(|j: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    j), indexes.drop_last().len())));
                                    ::builtin::ensures(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    #[verus::internal(trigger)] indexes.drop_last().spec_index(j)),
                                                s0.len())));
                                    ::builtin::assert_(valid_index(s0,
                                            indexes.drop_last().spec_index(j)));
                                });
                    }
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(Seq::fold_right)
                            }
                            __VERUS_REVEAL_INTERNAL__
                        }, 2);
                    sum_remove(s1, ::builtin::spec_literal_integer("0"));
                    ::builtin::assert_(::builtin::spec_eq((S(s0).spec_index(indexes.drop_last())).spec_add(S(s).spec_index(::vstd::vstd::seq::Seq::empty().push(i))),
                            S(s).spec_index(indexes)));
                    sum_concat(S(s0).spec_index(indexes.drop_last()),
                        S(s).spec_index(::vstd::vstd::seq::Seq::empty().push(i)));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        fn popcnt_remove(l: Seq<u8>, i: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                    i), l.len()))]);
            ::builtin::ensures([::builtin::spec_eq(popcnt(l),
                            (popcnt_byte(l.spec_index(i))).spec_add(popcnt(l.remove(i))))]);
            sum_remove(popcnt_seq(l), i);
            ::builtin::assert_(::builtin::spec_eq(popcnt_seq(l).remove(i),
                    popcnt_seq(l.remove(i))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        fn popcnt_indexes(s: Seq<u8>, idx: Seq<int>) {
            ::builtin::requires([valid_indexes(s, idx)]);
            ::builtin::ensures([::builtin::ext_equal(popcnt_seq(S(s).spec_index(idx)),
                            S(popcnt_seq(s)).spec_index(idx))]);
            ::builtin::decreases((idx.len()));
            if (idx.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    popcnt_indexes(s, idx.drop_first());
                    indexes_first(s, idx);
                    ::builtin::assert_(::builtin::ext_equal(popcnt_seq((::vstd::vstd::seq::Seq::empty().push(s.spec_index(idx.spec_index(::builtin::spec_literal_integer("0"))))).spec_add(S(s).spec_index(idx.drop_first()))),
                            (::vstd::vstd::seq::Seq::empty().push(popcnt_byte(s.spec_index(idx.spec_index(::builtin::spec_literal_integer("0")))))).spec_add(popcnt_seq(S(s).spec_index(idx.drop_first())))));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn popcnt_indexes_le(s: Seq<u8>, idx: Seq<int>) {
            ::builtin::requires([idx.no_duplicates(), valid_indexes(s, idx)]);
            ::builtin::ensures([(popcnt(S(s).spec_index(idx))).spec_le(popcnt(s))]);
            ::builtin::assert_(::builtin::forall(|i: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), idx.len())),
                            ::builtin::imply(valid_index(s, idx.spec_index(i)),
                                #[verus::internal(trigger)] valid_index(popcnt_seq(s),
                                    idx.spec_index(i))))));
            sum_indexes(popcnt_seq(s), idx);
            popcnt_indexes(s, idx);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn popcnt_index_le(s: Seq<u8>, idx: int) {
            ::builtin::requires([valid_index(s, idx)]);
            ::builtin::ensures([(popcnt_byte(s.spec_index(idx))).spec_le(popcnt(s))]);
            popcnt_remove(s, idx);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn popcnt_ext_le(s1: Seq<u8>, s2: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(s1.len(), s2.len()),
                        ::builtin::forall(|i: int|
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), s1.len())),
                                    (#[verus::internal(trigger)] popcnt_byte(s1.spec_index(i))).spec_le(popcnt_byte(s2.spec_index(i)))))]);
            ::builtin::ensures([(popcnt(s1)).spec_le(popcnt(s2))]);
            ::builtin::decreases((s1.len(),));
            if (s1.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    popcnt_remove(s1, ::builtin::spec_literal_integer("0"));
                    popcnt_remove(s2, ::builtin::spec_literal_integer("0"));
                    popcnt_ext_le(s1.drop_first(), s2.drop_first());
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn and(a: Seq<u8>, b: Seq<u8>) -> Seq<u8> {
            a.zip_with(b).map_values(::builtin::closure_to_fn_spec(|v:
                            (u8, u8)| (v.0).spec_bitand(v.1)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn byte_xor_xor(a: u8, b: u8) {
            ::builtin::ensures([::builtin::spec_eq((((a).spec_bitxor(b))).spec_bitxor(a),
                            b)]);
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures(::builtin::spec_eq((((a).spec_bitxor(b))).spec_bitxor(a),
                                b));
                    })
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn byte_and_zero(a: u8) {
            ::builtin::ensures([::builtin::spec_eq((a).spec_bitand(0),
                            ::builtin::spec_literal_nat("0"))]);
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures(::builtin::spec_eq((a).spec_bitand(0),
                                ::builtin::spec_literal_nat("0")));
                    })
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn byte_xor_mask_popcnt_byte_le(a: u8, mask: u8, b: u8) {
            ::builtin::ensures([(popcnt_byte((((a).spec_bitxor(((mask).spec_bitand(b))))).spec_bitxor(a))).spec_le(popcnt_byte(b))]);
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures((_popcnt_byte((((a).spec_bitxor(((mask).spec_bitand(b))))).spec_bitxor(a))).spec_le(_popcnt_byte(b)));
                    })
            };
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn list_xor_xor(a: Seq<u8>, b: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(a.len(), b.len())]);
            ::builtin::ensures([::builtin::ext_equal(xor(xor(a, b), a), b)]);
            ::builtin::decreases((a.len()));
            if (a.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    byte_xor_xor(a.spec_index(::builtin::spec_literal_integer("0")),
                        b.spec_index(::builtin::spec_literal_integer("0")));
                    list_xor_xor(a.drop_first(), b.drop_first());
                    ::builtin::assert_(::builtin::spec_eq(b,
                            (::vstd::vstd::seq::Seq::empty().push(b.spec_index(::builtin::spec_literal_integer("0")))).spec_add(b.drop_first())));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn xor_indexes(s1: Seq<u8>, s2: Seq<u8>, idx: Seq<int>) {
            ::builtin::requires([::builtin::spec_eq(s1.len(), s2.len()),
                        valid_indexes(s1, idx)]);
            ::builtin::ensures([::builtin::ext_equal(xor(S(s1).spec_index(idx),
                                S(s2).spec_index(idx)), S(xor(s1, s2)).spec_index(idx))]);
            ::builtin::decreases((idx.len()));
            if (idx.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    xor_indexes(s1, s2, idx.drop_first());
                    ::builtin::assert_(::builtin::ext_equal(idx,
                            (::vstd::vstd::seq::Seq::empty().push(idx.first())).spec_add(idx.drop_first())));
                    ::builtin::assert_(::builtin::ext_equal(S(xor(s1,
                                        s2)).spec_index((::vstd::vstd::seq::Seq::empty().push(idx.first())).spec_add(idx.drop_first())),
                            (::vstd::vstd::seq::Seq::empty().push(xor(s1,
                                                s2).spec_index(idx.first()))).spec_add(S(xor(s1,
                                            s2)).spec_index(idx.drop_first()))));
                    ::builtin::assert_(valid_index(s1, idx.first()));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn xor_comm(s1: Seq<u8>, s2: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(s1.len(), s2.len())]);
            ::builtin::ensures([::builtin::ext_equal(xor(s1, s2),
                            xor(s2, s1))]);
            ::builtin::decreases((s1.len()));
            if (s1.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    let a = s1.first();
                    let b = s2.first();
                    {
                        ::builtin::assert_bitvector_by({
                                ::builtin::ensures(::builtin::spec_eq((a).spec_bitxor(b),
                                        (b).spec_bitxor(a)));
                            })
                    };
                    xor_comm(s1.drop_first(), s2.drop_first());
                    ::builtin::assert_(::builtin::spec_eq(xor(s1, s2),
                            (::vstd::vstd::seq::Seq::empty().push(xor(s1,
                                                s2).first())).spec_add(xor(s1, s2).drop_first())));
                    ::builtin::assert_(::builtin::spec_eq(xor(s1,
                                    s2).drop_first(), xor(s1.drop_first(), s2.drop_first())));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        fn popcnt_byte_and(a: u8, b: u8) {
            ::builtin::ensures([(popcnt_byte((a).spec_bitand(b))).spec_le(popcnt_byte(a)),
                        (popcnt_byte((a).spec_bitand(b))).spec_le(popcnt_byte(b))]);
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures((_popcnt_byte((a).spec_bitand(b))).spec_le(_popcnt_byte(a)));
                    })
            };
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures((_popcnt_byte((a).spec_bitand(b))).spec_le(_popcnt_byte(b)));
                    })
            };
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn popcnt_and(a: Seq<u8>, b: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(a.len(), b.len())]);
            ::builtin::ensures([(popcnt(and(a, b))).spec_le(popcnt(a)),
                        (popcnt(and(a, b))).spec_le(popcnt(b))]);
            ::builtin::decreases((a.len(),));
            if (a.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    popcnt_byte_and(a.spec_index(::builtin::spec_literal_integer("0")),
                        b.spec_index(::builtin::spec_literal_integer("0")));
                    popcnt_and(a.drop_first(), b.drop_first());
                    popcnt_remove(a, ::builtin::spec_literal_integer("0"));
                    popcnt_remove(b, ::builtin::spec_literal_integer("0"));
                    popcnt_remove(and(a, b),
                        ::builtin::spec_literal_integer("0"));
                    ::builtin::assert_(::builtin::spec_eq(and(a,
                                    b).drop_first(), and(a.drop_first(), b.drop_first())));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn popcnt_byte_zero(a: u8) {
            ::builtin::requires([::builtin::spec_eq(popcnt_byte(a),
                            ::builtin::spec_literal_nat("0"))]);
            ::builtin::ensures([::builtin::spec_eq(a,
                            ::builtin::spec_literal_nat("0"))]);
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures(::builtin::imply(::builtin::spec_eq(_popcnt_byte(a),
                                    ::builtin::spec_literal_nat("0")),
                                ::builtin::spec_eq(a, ::builtin::spec_literal_nat("0"))));
                    })
            };
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn xor_byte_zero(a: u8) {
            ::builtin::ensures([::builtin::spec_eq((a).spec_bitxor(0u8), a)]);
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures(::builtin::spec_eq((a).spec_bitxor(0),
                                a));
                    })
            };
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn xor_zeroes(a: Seq<u8>, b: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(a.len(), b.len()),
                        ::builtin::spec_eq(popcnt(b),
                            ::builtin::spec_literal_nat("0"))]);
            ::builtin::ensures([::builtin::ext_equal(xor(a, b), a)]);
            ::builtin::decreases((a.len()));
            if (a.len()).spec_gt(::builtin::spec_literal_nat("0")) {
                    popcnt_remove(b, ::builtin::spec_literal_integer("0"));
                    popcnt_byte_zero(b.first());
                    xor_byte_zero(a.first());
                    xor_zeroes(a.drop_first(), b.drop_first());
                    ::builtin::assert_(::builtin::spec_eq(a,
                            (::vstd::vstd::seq::Seq::empty().push(a.first())).spec_add(a.drop_first())));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn u8_zeroes(len: nat) -> Seq<u8> {
            Seq::new(len,
                ::builtin::closure_to_fn_spec(|i: int|
                        ::builtin::spec_literal_integer("0")))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        fn sum_nat_zeroes(len: nat) {
            ::builtin::ensures([::builtin::spec_eq(sum(Seq::new(len,
                                    ::builtin::closure_to_fn_spec(|i: int|
                                            ::builtin::spec_literal_nat("0")))),
                            ::builtin::spec_literal_nat("0"))]);
            ::builtin::decreases((len));
            if (len).spec_gt(::builtin::spec_literal_nat("0")) {
                    let l =
                        Seq::new(len,
                            ::builtin::closure_to_fn_spec(|i: int|
                                    ::builtin::spec_literal_nat("0")));
                    let l1 =
                        Seq::new(::builtin::spec_cast_integer::<_,
                                    nat>(((len).spec_sub(::builtin::spec_literal_nat("1")))),
                            ::builtin::closure_to_fn_spec(|i: int|
                                    ::builtin::spec_literal_nat("0")));
                    sum_nat_zeroes(l1.len());
                    ::builtin::assert_(::builtin::spec_eq(l1, l.drop_last()));
                }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn popcnt_u8_zeroes(len: nat) {
            ::builtin::ensures([::builtin::spec_eq(popcnt(u8_zeroes(len)),
                            ::builtin::spec_literal_nat("0")),
                        ::builtin::spec_eq(u8_zeroes(len).len(), len)]);
            {
                ::builtin::assert_bitvector_by({
                        ::builtin::ensures(::builtin::spec_eq(_popcnt_byte(::builtin::spec_literal_integer("0")),
                                ::builtin::spec_literal_nat("0")));
                    })
            };
            ::builtin::assert_(::builtin::spec_eq(u8_zeroes(len).map_values(::builtin::closure_to_fn_spec(|v:
                                    u8| popcnt_byte(v))),
                    Seq::new(len,
                        ::builtin::closure_to_fn_spec(|i: int|
                                ::builtin::spec_literal_nat("0")))));
            sum_nat_zeroes(len);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn hamming_indexes(s1: Seq<u8>, s2: Seq<u8>, idx: Seq<int>) {
            ::builtin::requires([::builtin::spec_eq(s1.len(), s2.len()),
                        idx.no_duplicates(), valid_indexes(s1, idx)]);
            ::builtin::ensures([(hamming(S(s1).spec_index(idx),
                                    S(s2).spec_index(idx))).spec_le(hamming(s1, s2))]);
            xor_indexes(s1, s2, idx);
            ::builtin::assert_(::builtin::forall(|i: int|
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        i), idx.len())),
                            ::builtin::imply(valid_index(s1, idx.spec_index(i)),
                                #[verus::internal(trigger)] valid_index(xor(s1, s2),
                                    idx.spec_index(i))))));
            popcnt_indexes_le(xor(s1, s2), idx);
        }
    }
    pub mod pmemmock_t {
        //! This file contains the trusted implementation for
        //! `VolatileMemoryMockingPersistentMemoryRegions`, a collection of
        //! volatile memory regions. It serves as a mock of persistent memory
        //! regions by implementing trait `PersistentMemoryRegions`.
        //!
        //! THIS IS ONLY INTENDED FOR USE IN TESTING! In practice, one should
        //! use actually persistent memory to implement persistent memory!
        #![verus::trusted]
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use builtin::*;
        use builtin_macros::*;
        use deps_hack::rand::Rng;
        use std::convert::*;
        use vstd::prelude::*;
        #[verus::internal(verus_macro)]
        pub struct VolatileMemoryMockingPersistentMemoryRegion {
            contents: Vec<u8>,
        }
        #[verus::internal(verus_macro)]
        impl VolatileMemoryMockingPersistentMemoryRegion {
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn new(region_size: u64) -> Self {
                ::builtin::ensures(|result: Self|
                        [result.inv(), (result.view()).valid(),
                                ::builtin::spec_eq((result.view()).len(), region_size)]);
                let contents: Vec<u8> =
                    ::alloc::vec::from_elem(0, region_size as usize);
                Self { contents }
            }
        }
        #[verus::internal(verus_macro)]
        impl PersistentMemoryRegion for
            VolatileMemoryMockingPersistentMemoryRegion {
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            fn view(&self) -> PersistentMemoryRegionView {
                ::core::panicking::panic("not implemented")
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn inv(&self) -> bool {
                (((((self.contents.len()).spec_le(u64::MAX)) &&
                                            (::builtin::spec_eq(self.contents.len(),
                                                    (self.view()).len()))) &&
                                    (::builtin::spec_eq((self.contents.view()),
                                            (self.view()).read_state))) &&
                            (::builtin::spec_eq((self.contents.view()),
                                    (self.view()).durable_state))) && (self.constants().valid())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            fn constants(&self) -> PersistentMemoryConstants {
                ::core::panicking::panic("not implemented")
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn lemma_inv_implies_view_valid(&self) {}
            #[verus::internal(verus_macro)]
            fn get_region_size(&self) -> u64 { self.contents.len() as u64 }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn read_aligned<S>(&self, addr: u64)
                -> Result<MaybeCorruptedBytes<S>, PmemError> where S: PmCopy {
                let pm_slice =
                    &self.contents[addr as
                                    usize..addr as usize + S::size_of() as usize];
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        Seq::new(::builtin::spec_cast_integer::<_,
                                    nat>(S::spec_size_of()),
                            ::builtin::closure_to_fn_spec(|i: int| (addr).spec_add(i)))
                };
                #[verus::internal(spec)]
                let mut addrs;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_addrs = verus_tmp;
                    addrs = verus_tmp_addrs;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                {
                    verus_tmp =
                        (self.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                    int>(addr), (addr).spec_add(S::size_of()))
                };
                #[verus::internal(spec)]
                let mut true_bytes;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_true_bytes = verus_tmp;
                    true_bytes = verus_tmp_true_bytes;
                };
                #[verus::internal(spec)]
                #[verus::internal(unwrapped_binding)]
                let mut verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = S::spec_from_bytes(true_bytes) };
                #[verus::internal(spec)]
                let mut true_val;

                #[verifier::proof_block]
                {
                    #[verus::internal(spec)]
                    let verus_tmp_true_val = verus_tmp;
                    true_val = verus_tmp_true_val;
                };
                let mut maybe_corrupted_val = MaybeCorruptedBytes::new();
                maybe_corrupted_val.copy_from_slice(pm_slice,
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_val),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] addrs),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] self.constants()));
                Ok(maybe_corrupted_val)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn read_unaligned(&self, addr: u64, num_bytes: u64)
                -> Result<Vec<u8>, PmemError> {
                let pm_slice =
                    &self.contents[addr as
                                    usize..addr as usize + num_bytes as usize];
                let unaligned_buffer = copy_from_slice(pm_slice);
                Ok(unaligned_buffer)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn write(&mut self, addr: u64, bytes: &[u8]) {
                let addr_usize: usize = addr.try_into().unwrap();
                self.contents.splice(addr_usize..addr_usize + bytes.len(),
                    bytes.iter().cloned());
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn serialize_and_write<S>(&mut self, addr: u64, to_write: &S)
                where S: PmCopy + Sized {
                let addr_usize: usize = addr.try_into().unwrap();
                let num_bytes: usize = S::size_of().try_into().unwrap();
                let s_pointer = to_write as *const S;
                let bytes_pointer = s_pointer as *const u8;
                let bytes =
                    unsafe {
                        std::slice::from_raw_parts(bytes_pointer, num_bytes)
                    };
                self.contents.splice(addr_usize..addr_usize + num_bytes,
                    bytes.iter().cloned());
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            fn flush(&mut self) {}
        }
    }
    pub mod pmemspec_t {
        //! This file contains the trusted specification for how a persistent
        //! memory region (implementing trait `PersistentMemoryRegion`)
        //! behaves.
        //!
        //! One of the things it models is what can happen to a persistent
        //! memory region if the system crashes in the middle of a write.
        //! Specifically, it says that on a crash some subset of the
        //! outstanding byte writes will be flushed (performed before the
        //! crash) and the rest of the outstanding byte writes will be
        //! discarded. Furthermore, any 8-byte-aligned 8-byte chunk either has
        //! all its outstanding writes flushed or all of them discarded.
        //!
        //! Following Perennial, this model uses prophecy to describe the
        //! current state of the persistent memory. The abstract state of the
        //! storage consists of a read state, which doesn't use prophecy, and
        //! a durable state, which does use prophecy.
        //! The read state is straightforward: It reflects all writes done so
        //! far, regardless of whether those writes have been made durable and
        //! will survive a crash. So it reflects what future reads will see,
        //! at least until the next crash terminates the Verus program.
        //!
        //! The durable state represents what state would result if a crash
        //! happened now. It forms this representation by predicting, every
        //! time a write occurs, which of the bytes in that write will be made
        //! durable before the next crash. Of course, this prediction can't be
        //! made in reality, but that doesn't stop us from making the
        //! prediction in ghost state.
        //!
        //! The semantics of a flush is that, if you're calling flush right
        //! now, the predictor must have predicted that all outstanding
        //! written bytes would be flushed to persistent memory before the
        //! next crash. So a *precondition* of a flush operation is that the
        //! read state matches the durable state.
        //!
        //! Modeling with an omniscient predictor is naturally unrealistic.
        //! But in Perennial, it's been proved that any program correct under
        //! the prophecy model is correct under the traditional model of a
        //! storage system. So the model is a reasonable and sound one.
        //!
        //! Another thing this file models is how bit corruption manifests,
        //! in terms of a Hamming bound (i.e., total number of bits that could
        //! be corrupted on read).
        #![verus::trusted]
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::hamming_t::*;
        use crate::pmem::hamming_v::*;
        use builtin::*;
        use builtin_macros::*;
        use core::fmt::Debug;
        use vstd::bytes::*;
        use vstd::prelude::*;
        use deps_hack::crc64fast::Digest;
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        pub fn copy_from_slice(bytes: &[u8]) -> Vec<u8> {
            ::builtin::ensures(|out: Vec<u8>|
                    [::builtin::spec_eq((out.view()), (bytes.view()))]);
            let mut buffer = ::alloc::vec::from_elem(0, bytes.len());
            let buffer_slice = buffer.as_mut_slice();
            buffer_slice.copy_from_slice(bytes);
            buffer
        }
        #[verus::internal(verus_macro)]
        pub enum PmemError {
            InvalidFileName,
            CannotOpenPmFile,
            NotPm,
            PmdkError,
            AccessOutOfRange,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PmemError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f,
                    match self {
                        PmemError::InvalidFileName => "InvalidFileName",
                        PmemError::CannotOpenPmFile => "CannotOpenPmFile",
                        PmemError::NotPm => "NotPm",
                        PmemError::PmdkError => "PmdkError",
                        PmemError::AccessOutOfRange => "AccessOutOfRange",
                    })
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for PmemError {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PmemError { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PmemError {
            #[inline]
            fn eq(&self, other: &PmemError) -> bool {
                let __self_discr =
                    ::core::intrinsics::discriminant_value(self);
                let __arg1_discr =
                    ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PmemError {
            #[inline]
            fn clone(&self) -> PmemError { *self }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for PmemError { }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn bytes_read_from_storage(read_bytes: Seq<u8>,
            true_bytes: Seq<u8>, addr: int, pmc: PersistentMemoryConstants)
            -> bool {
            let addrs =
                Seq::<int>::new(true_bytes.len(),
                    ::builtin::closure_to_fn_spec(|i: int| (i).spec_add(addr)));
            pmc.valid() && pmc.maybe_corrupted(read_bytes, true_bytes, addrs)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_crc_bytes(bytes: Seq<u8>) -> Seq<u8> {
            spec_crc_u64(bytes).spec_to_bytes()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(uninterp)]
        #[verus::internal(spec)]
        #[verus::internal(external_body)]
        pub fn spec_crc_u64(bytes: Seq<u8>) -> u64 {
            ::core::panicking::panic("not implemented")
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_crc_hamming_bound(len: nat) -> nat {
            if (len).spec_le((((::builtin::spec_literal_nat("32768")).spec_add(::builtin::spec_literal_nat("7")))).spec_euclidean_div(::builtin::spec_literal_integer("8")))
                    {
                    ::builtin::spec_literal_integer("8")
                } else if (len).spec_le((((::builtin::spec_literal_nat("32768")).spec_add(::builtin::spec_literal_nat("7")))).spec_euclidean_div(::builtin::spec_literal_integer("8")))
                   {
                   ::builtin::spec_literal_integer("7")
               } else if (len).spec_le((((::builtin::spec_literal_nat("126701")).spec_add(::builtin::spec_literal_nat("7")))).spec_euclidean_div(::builtin::spec_literal_integer("8")))
                   {
                   ::builtin::spec_literal_integer("6")
               } else if (len).spec_le((((::builtin::spec_literal_nat("126701")).spec_add(::builtin::spec_literal_nat("7")))).spec_euclidean_div(::builtin::spec_literal_integer("8")))
                   {
                   ::builtin::spec_literal_integer("5")
               } else if (len).spec_le((((::builtin::spec_literal_nat("8589606850")).spec_add(::builtin::spec_literal_nat("7")))).spec_euclidean_div(::builtin::spec_literal_integer("8")))
                   {
                   ::builtin::spec_literal_integer("4")
               } else if (len).spec_le((((::builtin::spec_literal_nat("8589606850")).spec_add(::builtin::spec_literal_nat("7")))).spec_euclidean_div(::builtin::spec_literal_integer("8")))
                   {
                   ::builtin::spec_literal_integer("3")
               } else { ::builtin::spec_literal_integer("2") }
        }
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn crc_hamming_bound_valid(bytes1: Seq<u8>, bytes2: Seq<u8>,
            crc1: Seq<u8>, crc2: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(crc1,
                            spec_crc_bytes(bytes1)),
                        ::builtin::spec_eq(crc2, spec_crc_bytes(bytes2)),
                        ::builtin::spec_eq(((bytes1).spec_add(crc1)).len(),
                            ((bytes2).spec_add(crc2)).len())]);
            ::builtin::ensures([::builtin::spec_eq(bytes1, bytes2) ||
                            (hamming((bytes1).spec_add(crc1),
                                        (bytes2).spec_add(crc2))).spec_ge(spec_crc_hamming_bound(((bytes1).spec_add(crc1)).len()))]);
        }
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn bytes_crc(bytes: &[u8]) -> Vec<u8> {
            ::builtin::ensures(|out: Vec<u8>|
                    [::builtin::spec_eq(spec_u64_to_le_bytes(spec_crc_u64((bytes.view()))),
                                (out.view())),
                            ::builtin::spec_eq((out.view()).len(),
                                u64::spec_size_of())]);
            let mut digest = Digest::new();
            digest.write(bytes);
            u64_to_le_bytes(digest.sum64())
        }
        #[verifier::external_body]
        #[inline(always)]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn compare_crcs(crc1: &[u8], crc2: u64) -> bool {
            ::builtin::requires([::builtin::spec_eq((crc1.view()).len(),
                            u64::spec_size_of())]);
            ::builtin::ensures(|out: bool|
                    [::builtin::imply(out,
                                ::builtin::spec_eq((crc1.view()), crc2.spec_to_bytes())),
                            ::builtin::imply(!out,
                                !::builtin::spec_eq((crc1.view()), crc2.spec_to_bytes()))]);
            let crc1_u64 = u64_from_le_bytes(crc1);
            crc1_u64 == crc2
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        pub const CDB_FALSE: u64 = 0xa32842d19001605e;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        pub const CDB_TRUE: u64 = 0xab21aa73069531b7;
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn cdb_hamming() {
            ::builtin::ensures([(hamming(CDB_FALSE.spec_to_bytes(),
                                    CDB_TRUE.spec_to_bytes())).spec_gt(::builtin::spec_literal_nat("8"))]);
        }
        #[doc =
        " We model the persistent memory as getting flushed in chunks,"]
        #[doc =
        " where each chunk has `const_persistence_chunk_size()` bytes. We refer"]
        #[doc =
        " to chunk number `c` as the set of addresses `addr` such that"]
        #[doc = " `addr / const_persistence_chunk_size() == c`."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn const_persistence_chunk_size() -> int {
            ::builtin::spec_literal_integer("8")
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn persistence_chunk_size() -> usize {
            ::builtin::ensures(|out: usize|
                    [::builtin::spec_eq(out, const_persistence_chunk_size())]);
            8
        }
        #[doc = " We model the state of a region of persistent memory as a"]
        #[doc =
        " `PersistentMemoryRegionView`, which is two sequences of `u8`."]
        #[doc =
        " The first is the latest bytes written, reflecting what will"]
        #[doc =
        " be read by a `read` operation. The second is the bytes that"]
        #[doc = " will be on persistent memory in the event of a crash,"]
        #[doc = " reflecting a prophecy of which outstanding writes will be"]
        #[doc = " made durable."]
        #[verifier::ext_equal]
        #[verus::internal(verus_macro)]
        pub struct PersistentMemoryRegionView {
            pub read_state: Seq<u8>,
            pub durable_state: Seq<u8>,
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn update_bytes(s: Seq<u8>, addr: int, bytes: Seq<u8>)
            -> Seq<u8> {
            Seq::new(s.len(),
                ::builtin::closure_to_fn_spec(|i: int|
                        if ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(addr),
                                            i), (addr).spec_add(bytes.len()))) {
                                bytes.spec_index((i).spec_sub(addr))
                            } else { s.spec_index(i) }))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn addr_in_chunk(chunk: int, addr: int) -> bool {
            ::builtin::spec_eq((addr).spec_euclidean_div(const_persistence_chunk_size()),
                chunk)
        }
        #[doc =
        " We model writes as prophesizing which bytes will be written,"]
        #[doc = " subject to the constraint that bytes in the same chunk"]
        #[doc =
        " (aligned on `const_persistence_chunk_size()` boundaries) will"]
        #[doc = " either all be written or have none of them written."]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn chunk_corresponds(s1: Seq<u8>, s2: Seq<u8>, chunk: int)
            -> bool {
            ::builtin::forall(|addr: int|
                    ::builtin::imply({
                            (::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                addr), s1.len()))) && (addr_in_chunk(chunk, addr))
                        },
                        ::builtin::spec_eq(#[verus::internal(trigger)] s1.spec_index(addr),
                            s2.spec_index(addr))))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn chunk_trigger(chunk: int) -> bool { true }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn can_result_from_partial_write(post: Seq<u8>, pre: Seq<u8>,
            addr: int, bytes: Seq<u8>) -> bool {
            (::builtin::spec_eq(post.len(), pre.len())) &&
                (::builtin::forall(|chunk|
                            ::builtin::imply(#[verus::internal(trigger)] chunk_trigger(chunk),
                                {
                                    (chunk_corresponds(post, pre, chunk)) ||
                                        (chunk_corresponds(post, update_bytes(pre, addr, bytes),
                                                chunk))
                                })))
        }
        #[verus::internal(verus_macro)]
        impl PersistentMemoryRegionView {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn len(self) -> nat { self.read_state.len() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                ::builtin::spec_eq(self.read_state.len(),
                    self.durable_state.len())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn can_result_from_write(self, pre: Self, addr: int,
                bytes: Seq<u8>) -> bool {
                (::builtin::spec_eq(self.read_state,
                            update_bytes(pre.read_state, addr, bytes))) &&
                    (can_result_from_partial_write(self.durable_state,
                            pre.durable_state, addr, bytes))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn flush_predicted(self) -> bool {
                ::builtin::spec_eq(self.durable_state, self.read_state)
            }
        }
        #[verus::internal(verus_macro)]
        pub struct PersistentMemoryConstants {
            pub corruption: Seq<u8>,
        }
        #[verus::internal(verus_macro)]
        impl PersistentMemoryConstants {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn impervious_to_corruption(self) -> bool {
                ::builtin::spec_eq(popcnt(self.corruption),
                    ::builtin::spec_literal_nat("0"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn valid(self) -> bool {
                (popcnt(self.corruption)).spec_lt(::builtin::spec_literal_nat("2"))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn maybe_corrupted_byte(self, byte: u8, true_byte: u8,
                addr: int) -> bool {
                (valid_index(self.corruption, addr)) &&
                    (::builtin::exists(|mask: u8|
                                ::builtin::spec_eq(byte,
                                    #[verus::internal(trigger)] ((true_byte).spec_bitxor(((mask).spec_bitand(self.corruption.spec_index(addr))))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn maybe_corrupted_byte_popcnt(self, byte: u8, true_byte: u8,
                addr: int) {
                ::builtin::requires([self.maybe_corrupted_byte(byte,
                                true_byte, addr)]);
                ::builtin::ensures([(popcnt_byte((byte).spec_bitxor(true_byte))).spec_le(popcnt_byte(self.corruption.spec_index(addr)))]);
                let c = self.corruption.spec_index(addr);
                {
                    ::builtin::assert_forall_by(|mask: u8|
                            {
                                ::builtin::ensures((popcnt_byte((#[verus::internal(trigger)] ((true_byte).spec_bitxor(((mask).spec_bitand(c))))).spec_bitxor(true_byte))).spec_le(popcnt_byte(c)));
                                byte_xor_mask_popcnt_byte_le(true_byte, mask, c);
                            });
                };
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn maybe_corrupted(self, bytes: Seq<u8>, true_bytes: Seq<u8>,
                addrs: Seq<int>) -> bool {
                (::builtin::spec_chained_cmp(::builtin::spec_chained_eq(::builtin::spec_chained_eq(::builtin::spec_chained_value(bytes.len()),
                                    true_bytes.len()), addrs.len()))) &&
                    (::builtin::forall(|i: int|
                                #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    i), bytes.len())),
                                        self.maybe_corrupted_byte(bytes.spec_index(i),
                                            true_bytes.spec_index(i), addrs.spec_index(i))))))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn maybe_corrupted_zero_addrs(self, bytes: Seq<u8>,
                true_bytes: Seq<u8>, addrs: Seq<int>) {
                ::builtin::requires([self.maybe_corrupted(bytes, true_bytes,
                                addrs), self.impervious_to_corruption()]);
                ::builtin::ensures([::builtin::ext_equal(bytes, true_bytes)]);
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), bytes.len())));
                                ::builtin::ensures(::builtin::spec_eq(bytes.spec_index(i),
                                        true_bytes.spec_index(i)));
                                popcnt_index_le(self.corruption, addrs.spec_index(i));
                                popcnt_byte_zero(self.corruption.spec_index(addrs.spec_index(i)));
                                {
                                    ::builtin::assert_forall_by(|mask: u8|
                                            {
                                                ::builtin::ensures(::builtin::spec_eq(((mask).spec_bitand(0)),
                                                        ::builtin::spec_literal_nat("0")));
                                                byte_and_zero(mask);
                                            });
                                };
                                xor_byte_zero(true_bytes.spec_index(i));
                            });
                };
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn maybe_corrupted_zero(self, bytes: Seq<u8>,
                true_bytes: Seq<u8>) {
                ::builtin::requires([::builtin::exists(|addrs: Seq<int>|
                                    #[verus::internal(trigger)] self.maybe_corrupted(bytes,
                                        true_bytes, addrs)), self.impervious_to_corruption()]);
                ::builtin::ensures([::builtin::ext_equal(bytes, true_bytes)]);
                {
                    ::builtin::assert_forall_by(|addrs: Seq<int>|
                            {
                                ::builtin::requires(#[verus::internal(trigger)] self.maybe_corrupted(bytes,
                                        true_bytes, addrs));
                                ::builtin::ensures(::builtin::ext_equal(bytes, true_bytes));
                                self.maybe_corrupted_zero_addrs(bytes, true_bytes, addrs);
                            });
                };
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn maybe_corrupted_hamming(self, bytes: Seq<u8>,
                true_bytes: Seq<u8>, addrs: Seq<int>) {
                ::builtin::requires([self.maybe_corrupted(bytes, true_bytes,
                                addrs), addrs.no_duplicates()]);
                ::builtin::ensures([(hamming(bytes,
                                        true_bytes)).spec_le(popcnt(self.corruption))]);
                {
                    ::builtin::assert_forall_by(|i: int|
                            {
                                ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), bytes.len())));
                                ::builtin::ensures((#[verus::internal(trigger)] popcnt_byte((bytes.spec_index(i)).spec_bitxor(true_bytes.spec_index(i)))).spec_le(popcnt_byte(self.corruption.spec_index(addrs.spec_index(i)))));
                                self.maybe_corrupted_byte_popcnt(bytes.spec_index(i),
                                    true_bytes.spec_index(i), addrs.spec_index(i));
                            });
                };
                popcnt_ext_le(xor(bytes, true_bytes),
                    S(self.corruption).spec_index(addrs));
                popcnt_indexes_le(self.corruption, addrs);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn _maybe_corrupted_crc(self, x_c: Seq<u8>, x: Seq<u8>,
                x_addrs: Seq<int>, y_c: Seq<u8>, y: Seq<u8>,
                y_addrs: Seq<int>) {
                ::builtin::requires([::builtin::spec_eq(x_c.len(), x.len()),
                            ::builtin::spec_eq(y, spec_crc_bytes(x)),
                            ::builtin::spec_eq(y_c, spec_crc_bytes(x_c)),
                            ((x_addrs).spec_add(y_addrs)).no_duplicates(),
                            self.maybe_corrupted(x_c, x, x_addrs),
                            self.maybe_corrupted(y_c, y, y_addrs),
                            (popcnt(self.corruption)).spec_lt(spec_crc_hamming_bound(((x).spec_add(y)).len()))]);
                ::builtin::ensures([::builtin::spec_eq(x, x_c)]);
                self.maybe_corrupted_hamming((x_c).spec_add(y_c),
                    (x).spec_add(y), (x_addrs).spec_add(y_addrs));
                crc_hamming_bound_valid(x_c, x, y_c, y);
            }
            #[doc =
            " The first main lemmas about corruption, `_maybe_corrupted_crc` above,"]
            #[doc =
            " is that if we have byte sequences `x` and `y` stored in persistent memory,"]
            #[doc =
            " where `y` is the CRC of `x`, then we can detect an absence of corruption"]
            #[doc = " by reading both of them and checking the CRC checksum."]
            #[doc = ""]
            #[doc =
            " Specifically, if we read from those locations and get `x_c` and `y_c`"]
            #[doc =
            " (corruptions of `x` and `y` respectively), and `y_c` is the CRC of `x_c`,"]
            #[doc =
            " and the total number of corrupted bits is smaller than CRC64\'s Hamming"]
            #[doc =
            " bound, then we can conclude that `x` wasn\'t corrupted, i.e., `x_c == x`."]
            #[doc = ""]
            #[doc =
            " The valid() predicate of PersistentMemoryConstants asserts that the max"]
            #[doc =
            " number of corrupted bits is less than CRC64\'s Hamming bound for any length,"]
            #[doc =
            " which simplifies the statement of the `maybe_corrupted_crc` lemma."]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn maybe_corrupted_crc(self, x_c: Seq<u8>, x: Seq<u8>,
                x_addrs: Seq<int>, y_c: Seq<u8>, y: Seq<u8>,
                y_addrs: Seq<int>) {
                ::builtin::requires([::builtin::spec_eq(x_c.len(), x.len()),
                            ::builtin::spec_eq(y, spec_crc_bytes(x)),
                            ::builtin::spec_eq(y_c, spec_crc_bytes(x_c)),
                            ((x_addrs).spec_add(y_addrs)).no_duplicates(),
                            self.maybe_corrupted(x_c, x, x_addrs),
                            self.maybe_corrupted(y_c, y, y_addrs), self.valid()]);
                ::builtin::ensures([::builtin::spec_eq(x, x_c)]);
                self._maybe_corrupted_crc(x_c, x, x_addrs, y_c, y, y_addrs);
            }
            #[doc =
            " The second lemma, encapsulated in `maybe_corrupted_cdb`, is that the"]
            #[doc =
            " values `CDB_FALSE` and `CDB_TRUE` are so randomly different from each"]
            #[doc =
            " other that corruption can\'t make one appear to be the other."]
            #[doc = " (CDB stands for Corruption-Detecting Boolean.)"]
            #[doc = ""]
            #[doc =
            " That is, if we know we wrote either `CDB_FALSE` or `CDB_TRUE`"]
            #[doc =
            " to a certain part of persistent memory, and when we read that"]
            #[doc =
            " same part we get `CDB_FALSE` or `CDB_TRUE`, we can conclude it"]
            #[doc = " matches what we last wrote to it."]
            #[doc = ""]
            #[doc =
            " We set these values to CRC(b\"0\") and CRC(b\"1\"), respectively."]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn maybe_corrupted_cdb(self, cdb_c: Seq<u8>, cdb: Seq<u8>,
                addrs: Seq<int>) {
                ::builtin::requires([self.valid(),
                            self.maybe_corrupted(cdb_c, cdb, addrs),
                            addrs.no_duplicates(),
                            ::builtin::spec_eq(cdb.len(), u64::spec_size_of()),
                            ::builtin::spec_eq(cdb_c, CDB_FALSE.spec_to_bytes()) ||
                                ::builtin::spec_eq(cdb_c, CDB_TRUE.spec_to_bytes()),
                            ::builtin::spec_eq(cdb, CDB_FALSE.spec_to_bytes()) ||
                                ::builtin::spec_eq(cdb, CDB_TRUE.spec_to_bytes())]);
                ::builtin::ensures([::builtin::spec_eq(cdb_c, cdb)]);
                if !::builtin::spec_eq(cdb_c, cdb) {
                        self.maybe_corrupted_hamming(cdb_c, cdb, addrs);
                        cdb_hamming();
                        xor_comm(CDB_FALSE.spec_to_bytes(),
                            CDB_TRUE.spec_to_bytes());
                    }
            }
        }
        #[verus::internal(verus_macro)]
        pub trait PersistentMemoryRegion: Sized {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn view(&self)
            -> PersistentMemoryRegionView;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn inv(&self)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn constants(&self)
            -> PersistentMemoryConstants;
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn lemma_inv_implies_view_valid(&self);
            #[verus::internal(verus_macro)]
            fn get_region_size(&self)
            -> u64;
            #[verus::internal(verus_macro)]
            fn read_aligned<S>(&self, addr: u64)
            -> Result<MaybeCorruptedBytes<S>, PmemError>
            where
            S: PmCopy +
            Sized;
            #[verus::internal(verus_macro)]
            fn read_unaligned(&self, addr: u64, num_bytes: u64)
            -> Result<Vec<u8>, PmemError>;
            #[verus::internal(verus_macro)]
            fn write(&mut self, addr: u64, bytes: &[u8]);
            #[verus::internal(verus_macro)]
            fn serialize_and_write<S>(&mut self, addr: u64, to_write: &S)
            where
            S: PmCopy +
            Sized;
            #[verus::internal(verus_macro)]
            fn flush(&mut self);
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__view(&self) -> PersistentMemoryRegionView {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__inv(&self) -> bool { ::builtin::no_method_body() }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__constants(&self) -> PersistentMemoryConstants {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn VERUS_SPEC__lemma_inv_implies_view_valid(&self) {
                ::builtin::requires([self.inv()]);
                ::builtin::ensures([(self.view()).valid(),
                            self.constants().valid()]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__get_region_size(&self) -> u64 {
                ::builtin::requires([self.inv()]);
                ::builtin::ensures(|result: u64|
                        [::builtin::spec_eq(result, (self.view()).len())]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__read_aligned<S>(&self, addr: u64)
                -> Result<MaybeCorruptedBytes<S>, PmemError> where S: PmCopy +
                Sized {
                ::builtin::requires([self.inv(),
                            ((addr).spec_add(S::spec_size_of())).spec_le((self.view()).len()),
                            S::bytes_parseable((self.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                            int>(addr), (addr).spec_add(S::spec_size_of())))]);
                ::builtin::ensures(|bytes:
                            Result<MaybeCorruptedBytes<S>, PmemError>|
                        [match bytes {
                                    Ok(bytes) =>
                                        bytes_read_from_storage((bytes.view()),
                                            (self.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                        int>(addr), (addr).spec_add(S::spec_size_of())),
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            self.constants()),
                                    _ => false,
                                }]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__read_unaligned(&self, addr: u64, num_bytes: u64)
                -> Result<Vec<u8>, PmemError> {
                ::builtin::requires([self.inv(),
                            ((addr).spec_add(num_bytes)).spec_le((self.view()).len())]);
                ::builtin::ensures(|bytes: Result<Vec<u8>, PmemError>|
                        [match bytes {
                                    Ok(bytes) =>
                                        bytes_read_from_storage((bytes.view()),
                                            (self.view()).read_state.subrange(::builtin::spec_cast_integer::<_,
                                                        int>(addr),
                                                (addr).spec_add(::builtin::spec_cast_integer::<_,
                                                            nat>(num_bytes))),
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            self.constants()),
                                    _ => false,
                                }]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__write(&mut self, addr: u64, bytes: &[u8]) {
                ::builtin::requires([old(self).inv(),
                            ((addr).spec_add((bytes.view()).len())).spec_le((old(self).view()).len())]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            (self.view()).can_result_from_write((old(self).view()),
                                ::builtin::spec_cast_integer::<_, int>(addr),
                                (bytes.view()))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__serialize_and_write<S>(&mut self, addr: u64,
                to_write: &S) where S: PmCopy + Sized {
                ::builtin::requires([old(self).inv(),
                            ((addr).spec_add(S::spec_size_of())).spec_le((old(self).view()).len())]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            (self.view()).can_result_from_write((old(self).view()),
                                ::builtin::spec_cast_integer::<_, int>(addr),
                                to_write.spec_to_bytes())]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__flush(&mut self) {
                ::builtin::requires([old(self).inv()]);
                ::builtin::ensures([(old(self).view()).flush_predicted(),
                            self.inv(),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            ::builtin::spec_eq((self.view()), (old(self).view()))]);
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn extract_bytes(bytes: Seq<u8>, pos: nat, len: nat) -> Seq<u8> {
            bytes.subrange(::builtin::spec_cast_integer::<_, int>(pos),
                ::builtin::spec_cast_integer::<_, int>(((pos).spec_add(len))))
        }
    }
    pub mod pmemutil_v {
        //! This file contains lemmas and utility executable functions about
        //! persistent memory regions.
        //!
        //! The code in this file is verified and untrusted (as indicated by
        //! the `_v.rs` suffix), so you don't have to read it to be confident
        //! of the system's correctness.
        use crate::pmem::crc_t::*;
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::crc_t::*;
        use builtin::*;
        use builtin_macros::*;
        use vstd::bytes::*;
        use vstd::prelude::*;
        #[verus::internal(verus_macro)]
        #[verus::internal(item_broadcast_use)]
        const _: () =
            {
                ::builtin::reveal_hide_({
                        #[verus::internal(reveal_fn)]
                        fn __VERUS_REVEAL_INTERNAL__() {
                            ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                        }

                        #[verus::internal(broadcast_use_reveal)]
                        __VERUS_REVEAL_INTERNAL__
                    }, 1);
            };
        #[verus::internal(verus_macro)]
        pub fn check_crc(data_c: &[u8], crc_c: &[u8],
            verus_tmp_true_bytes: Ghost<Seq<u8>>,
            verus_tmp_pmc: Ghost<PersistentMemoryConstants>,
            verus_tmp_data_addr: Ghost<int>, verus_tmp_crc_addr: Ghost<int>)
            -> bool {
            #[verus::internal(header_unwrap_parameter)]
            let true_bytes;

            #[verifier::proof_block]
            { true_bytes = verus_tmp_true_bytes.view() };
            #[verus::internal(header_unwrap_parameter)]
            let pmc;

            #[verifier::proof_block]
            { pmc = verus_tmp_pmc.view() };
            #[verus::internal(header_unwrap_parameter)]
            let data_addr;

            #[verifier::proof_block]
            { data_addr = verus_tmp_data_addr.view() };
            #[verus::internal(header_unwrap_parameter)]
            let crc_addr;

            #[verifier::proof_block]
            { crc_addr = verus_tmp_crc_addr.view() };
            ::builtin::requires([pmc.valid(),
                        ::builtin::spec_eq((crc_c.view()).len(),
                            u64::spec_size_of()),
                        bytes_read_from_storage((data_c.view()), true_bytes,
                            data_addr, pmc),
                        bytes_read_from_storage((crc_c.view()),
                            spec_crc_bytes(true_bytes), crc_addr, pmc),
                        ({
                                let data_addrs =
                                    Seq::<int>::new(true_bytes.len(),
                                        ::builtin::closure_to_fn_spec(|i: int|
                                                (i).spec_add(data_addr)));
                                let crc_addrs =
                                    Seq::<int>::new(spec_crc_bytes(true_bytes).len(),
                                        ::builtin::closure_to_fn_spec(|i: int|
                                                (i).spec_add(crc_addr)));
                                ((data_addrs).spec_add(crc_addrs)).no_duplicates()
                            })]);
            ::builtin::ensures(|b: bool|
                    [if b {
                                    (::builtin::spec_eq((data_c.view()), true_bytes)) &&
                                        (::builtin::spec_eq((crc_c.view()),
                                                spec_crc_bytes(true_bytes)))
                                } else { !pmc.impervious_to_corruption() }]);
            let computed_crc = calculate_crc_bytes(data_c);
            let crcs_match = compare_crcs(crc_c, computed_crc);

            #[verifier::proof_block]
            {
                let true_crc_bytes = spec_crc_bytes(true_bytes);
                let data_addrs =
                    Seq::<int>::new(true_bytes.len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                (i).spec_add(data_addr)));
                let true_crc_bytes = spec_crc_bytes(true_bytes);
                let crc_addrs =
                    Seq::<int>::new(u64::spec_size_of(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                (i).spec_add(crc_addr)));
                if pmc.impervious_to_corruption() {
                        pmc.maybe_corrupted_zero((data_c.view()), true_bytes);
                        pmc.maybe_corrupted_zero((crc_c.view()), true_crc_bytes);
                    }
                if { (!pmc.impervious_to_corruption()) && (crcs_match) } {
                        pmc.maybe_corrupted_crc((data_c.view()), true_bytes,
                            data_addrs, (crc_c.view()), true_crc_bytes, crc_addrs);
                    }
            }
            crcs_match
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn check_crc_for_two_reads(data1_c: &[u8], data2_c: &[u8],
            crc_c: &[u8], verus_tmp_true_bytes1: Ghost<Seq<u8>>,
            verus_tmp_true_bytes2: Ghost<Seq<u8>>,
            verus_tmp_pmc: Ghost<PersistentMemoryConstants>,
            verus_tmp_data_addr1: Ghost<int>,
            verus_tmp_data_addr2: Ghost<int>, verus_tmp_crc_addr: Ghost<int>)
            -> bool {
            #[verus::internal(header_unwrap_parameter)]
            let true_bytes1;

            #[verifier::proof_block]
            { true_bytes1 = verus_tmp_true_bytes1.view() };
            #[verus::internal(header_unwrap_parameter)]
            let true_bytes2;

            #[verifier::proof_block]
            { true_bytes2 = verus_tmp_true_bytes2.view() };
            #[verus::internal(header_unwrap_parameter)]
            let pmc;

            #[verifier::proof_block]
            { pmc = verus_tmp_pmc.view() };
            #[verus::internal(header_unwrap_parameter)]
            let data_addr1;

            #[verifier::proof_block]
            { data_addr1 = verus_tmp_data_addr1.view() };
            #[verus::internal(header_unwrap_parameter)]
            let data_addr2;

            #[verifier::proof_block]
            { data_addr2 = verus_tmp_data_addr2.view() };
            #[verus::internal(header_unwrap_parameter)]
            let crc_addr;

            #[verifier::proof_block]
            { crc_addr = verus_tmp_crc_addr.view() };
            ::builtin::requires([pmc.valid(),
                        ::builtin::spec_eq((crc_c.view()).len(),
                            u64::spec_size_of()),
                        ({
                                (((data_addr1).spec_add((data1_c.view()).len())).spec_le(data_addr2))
                                    ||
                                    (((data_addr2).spec_add((data2_c.view()).len())).spec_le(data_addr1))
                            }),
                        bytes_read_from_storage((data1_c.view()), true_bytes1,
                            data_addr1, pmc),
                        bytes_read_from_storage((data2_c.view()), true_bytes2,
                            data_addr2, pmc),
                        bytes_read_from_storage((crc_c.view()),
                            spec_crc_bytes((true_bytes1).spec_add(true_bytes2)),
                            crc_addr, pmc),
                        ({
                                let data_addrs1 =
                                    Seq::<int>::new(true_bytes1.len(),
                                        ::builtin::closure_to_fn_spec(|i: int|
                                                (i).spec_add(data_addr1)));
                                let data_addrs2 =
                                    Seq::<int>::new(true_bytes2.len(),
                                        ::builtin::closure_to_fn_spec(|i: int|
                                                (i).spec_add(data_addr2)));
                                let crc_addrs =
                                    Seq::<int>::new(spec_crc_bytes((true_bytes1).spec_add(true_bytes2)).len(),
                                        ::builtin::closure_to_fn_spec(|i: int|
                                                (i).spec_add(crc_addr)));
                                (((data_addrs1).spec_add(data_addrs2)).spec_add(crc_addrs)).no_duplicates()
                            })]);
            ::builtin::ensures(|b: bool|
                    [({
                                    if b {
                                            ((::builtin::spec_eq((data1_c.view()), true_bytes1)) &&
                                                        (::builtin::spec_eq((data2_c.view()), true_bytes2))) &&
                                                (::builtin::spec_eq((crc_c.view()),
                                                        spec_crc_bytes((true_bytes1).spec_add(true_bytes2))))
                                        } else { !pmc.impervious_to_corruption() }
                                })]);
            let mut digest = CrcDigest::new();
            digest.write_bytes(data1_c);
            digest.write_bytes(data2_c);

            #[verifier::proof_block]
            {
                ::builtin::assert_(::builtin::ext_equal(digest.bytes_in_digest(),
                        ((data1_c.view())).spec_add((data2_c.view()))));
            }
            let computed_crc = digest.sum64();

            #[verifier::proof_block]
            {

                #[verus::internal(const_header_wrapper)]
                ||
                    {
                        ::builtin::assert_(::builtin::spec_eq(computed_crc,
                                spec_crc_u64(((data1_c.view())).spec_add((data2_c.view())))))
                    };
            };
            let crcs_match = compare_crcs(crc_c, computed_crc);

            #[verifier::proof_block]
            {
                let data_c = ((data1_c.view())).spec_add((data2_c.view()));
                let true_data = (true_bytes1).spec_add(true_bytes2);
                let true_crc_bytes = spec_crc_bytes(true_data);
                let data_addrs1 =
                    Seq::<int>::new((data1_c.view()).len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                (i).spec_add(data_addr1)));
                let data_addrs2 =
                    Seq::<int>::new((data2_c.view()).len(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                (i).spec_add(data_addr2)));
                let crc_addrs =
                    Seq::<int>::new(u64::spec_size_of(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                (i).spec_add(crc_addr)));
                if pmc.impervious_to_corruption() {
                        pmc.maybe_corrupted_zero_addrs(data_c, true_data,
                            (data_addrs1).spec_add(data_addrs2));
                        pmc.maybe_corrupted_zero((crc_c.view()), true_crc_bytes);
                        ::builtin::assert_(::builtin::spec_eq(extract_bytes(data_c,
                                    ::builtin::spec_literal_integer("0"),
                                    (data1_c.view()).len()), (data1_c.view())));
                        ::builtin::assert_(::builtin::spec_eq(extract_bytes(data_c,
                                    (data1_c.view()).len(), (data2_c.view()).len()),
                                (data2_c.view())));
                        ::builtin::assert_(::builtin::spec_eq((data1_c.view()),
                                true_bytes1));
                        ::builtin::assert_(::builtin::spec_eq((data2_c.view()),
                                true_bytes2));
                    }
                if { (!pmc.impervious_to_corruption()) && (crcs_match) } {
                        pmc.maybe_corrupted_crc(data_c, true_data,
                            (data_addrs1).spec_add(data_addrs2), (crc_c.view()),
                            true_crc_bytes, crc_addrs);
                        ::builtin::assert_(::builtin::spec_eq(extract_bytes(data_c,
                                    ::builtin::spec_literal_integer("0"),
                                    (data1_c.view()).len()), (data1_c.view())));
                        ::builtin::assert_(::builtin::spec_eq(extract_bytes(data_c,
                                    (data1_c.view()).len(), (data2_c.view()).len()),
                                (data2_c.view())));
                        ::builtin::assert_(::builtin::spec_eq((data1_c.view()),
                                true_bytes1));
                        ::builtin::assert_(::builtin::spec_eq((data2_c.view()),
                                true_bytes2));
                    }
            }
            crcs_match
        }
        #[verus::internal(verus_macro)]
        pub fn check_cdb(cdb_c: MaybeCorruptedBytes<u64>,
            verus_tmp_true_cdb_bytes: Ghost<Seq<u8>>,
            verus_tmp_pmc: Ghost<PersistentMemoryConstants>,
            verus_tmp_cdb_addr: Ghost<int>) -> Option<bool> {
            #[verus::internal(header_unwrap_parameter)]
            let true_cdb_bytes;

            #[verifier::proof_block]
            { true_cdb_bytes = verus_tmp_true_cdb_bytes.view() };
            #[verus::internal(header_unwrap_parameter)]
            let pmc;

            #[verifier::proof_block]
            { pmc = verus_tmp_pmc.view() };
            #[verus::internal(header_unwrap_parameter)]
            let cdb_addr;

            #[verifier::proof_block]
            { cdb_addr = verus_tmp_cdb_addr.view() };
            ::builtin::requires([bytes_read_from_storage((cdb_c.view()),
                            true_cdb_bytes, cdb_addr, pmc),
                        ({
                                let true_cdb = u64::spec_from_bytes(true_cdb_bytes);
                                (u64::bytes_parseable(true_cdb_bytes)) &&
                                    (::builtin::spec_eq(true_cdb, CDB_FALSE) ||
                                            ::builtin::spec_eq(true_cdb, CDB_TRUE))
                            })]);
            ::builtin::ensures(|result: Option<bool>|
                    [({
                                    let true_cdb = u64::spec_from_bytes(true_cdb_bytes);
                                    match result {
                                        Some(b) =>
                                            if b {
                                                    ::builtin::spec_eq(true_cdb, CDB_TRUE)
                                                } else { ::builtin::spec_eq(true_cdb, CDB_FALSE) },
                                        None => !pmc.impervious_to_corruption(),
                                    }
                                })]);
            #[verus::internal(spec)]
            #[verus::internal(unwrapped_binding)]
            let mut verus_tmp;

            #[verifier::proof_block]
            {
                verus_tmp =
                    Seq::<int>::new(u64::spec_size_of(),
                        ::builtin::closure_to_fn_spec(|i: int|
                                (i).spec_add(cdb_addr)))
            };
            #[verus::internal(spec)]
            let mut cdb_addrs;

            #[verifier::proof_block]
            {
                #[verus::internal(spec)]
                let verus_tmp_cdb_addrs = verus_tmp;
                cdb_addrs = verus_tmp_cdb_addrs;
            };

            #[verifier::proof_block]
            {
                if pmc.impervious_to_corruption() {
                        pmc.maybe_corrupted_zero((cdb_c.view()), true_cdb_bytes);
                    }
                if !pmc.impervious_to_corruption() &&
                            (::builtin::spec_eq((cdb_c.view()),
                                        CDB_FALSE.spec_to_bytes()) ||
                                    ::builtin::spec_eq((cdb_c.view()),
                                        CDB_TRUE.spec_to_bytes())) {
                        pmc.maybe_corrupted_cdb((cdb_c.view()), true_cdb_bytes,
                            cdb_addrs);
                    }
            }
            let cdb_val =
                cdb_c.extract_cdb(#[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] true_cdb_bytes),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] cdb_addrs),
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] pmc));

            #[verifier::proof_block]
            {

                #[verus::internal(const_header_wrapper)]
                ||
                    {
                        ::builtin::assert_(::builtin::spec_eq(cdb_val.spec_to_bytes(),
                                (cdb_c.view())))
                    };
            };
            if *cdb_val == CDB_FALSE {
                    Some(false)
                } else if *cdb_val == CDB_TRUE {
                   Some(true)
               } else {

                   #[verifier::proof_block]
                   { axiom_to_from_bytes::<u64>(*cdb_val); }
                   None
               }
        }
        #[doc =
        " If the only outstanding write is `const_persistence_chunk_size()`-sized and"]
        #[doc =
        " -aligned, then there are only two possible resulting crash states,"]
        #[doc = " one with the write and one without."]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_only_two_crash_states_introduced_by_aligned_chunk_write(new_durable_state:
                Seq<u8>, durable_state: Seq<u8>, write_addr: int,
            bytes_to_write: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(bytes_to_write.len(),
                            const_persistence_chunk_size()),
                        ::builtin::spec_eq((write_addr).spec_euclidean_mod(const_persistence_chunk_size()),
                            ::builtin::spec_literal_nat("0")),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(const_persistence_chunk_size())).spec_le(durable_state.len()),
                        can_result_from_partial_write(new_durable_state,
                            durable_state, write_addr, bytes_to_write)]);
            ::builtin::ensures([({
                                (::builtin::spec_eq(new_durable_state, durable_state)) ||
                                    (::builtin::spec_eq(new_durable_state,
                                            update_bytes(durable_state, write_addr, bytes_to_write)))
                            })]);
            let chunk =
                (write_addr).spec_euclidean_div(const_persistence_chunk_size());
            ::builtin::assert_(chunk_trigger(chunk));
            if chunk_corresponds(new_durable_state, durable_state, chunk) {
                    {
                        ::builtin::assert_forall_by(|addr: int|
                                {
                                    ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    addr), new_durable_state.len())));
                                    ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] new_durable_state.spec_index(addr),
                                            durable_state.spec_index(addr)));
                                    ::builtin::assert_(chunk_trigger((addr).spec_euclidean_div(const_persistence_chunk_size())));
                                });
                    }
                    ::builtin::assert_(::builtin::ext_equal(new_durable_state,
                            durable_state));
                } else {
                   {
                       ::builtin::assert_forall_by(|addr: int|
                               {
                                   ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                   addr), new_durable_state.len())));
                                   ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] new_durable_state.spec_index(addr),
                                           update_bytes(durable_state, write_addr,
                                                   bytes_to_write).spec_index(addr)));
                                   ::builtin::assert_(chunk_trigger((addr).spec_euclidean_div(const_persistence_chunk_size())));
                               });
                   }
                   ::builtin::assert_(::builtin::ext_equal(new_durable_state,
                           update_bytes(durable_state, write_addr, bytes_to_write)));
               }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_auto_only_two_crash_states_introduced_by_aligned_chunk_write() {
            ::builtin::ensures([(::builtin::forall(|durable_state: Seq<u8>,
                                    write_addr: int, bytes_to_write: Seq<u8>,
                                    new_durable_state: Seq<u8>|
                                    ::builtin::imply({
                                            ((((::builtin::spec_eq(bytes_to_write.len(),
                                                                                const_persistence_chunk_size())) &&
                                                                        (::builtin::spec_eq((write_addr).spec_euclidean_mod(const_persistence_chunk_size()),
                                                                                ::builtin::spec_literal_nat("0")))) &&
                                                                ((::builtin::spec_literal_nat("0")).spec_le(write_addr))) &&
                                                        (((write_addr).spec_add(const_persistence_chunk_size())).spec_le(durable_state.len())))
                                                &&
                                                (#[verus::internal(trigger)] can_result_from_partial_write(new_durable_state,
                                                        durable_state, write_addr, bytes_to_write))
                                        },
                                        {
                                            (::builtin::spec_eq(new_durable_state, durable_state)) ||
                                                (::builtin::spec_eq(new_durable_state,
                                                        update_bytes(durable_state, write_addr, bytes_to_write)))
                                        })))]);
            {
                ::builtin::assert_forall_by(|durable_state: Seq<u8>,
                        write_addr: int, bytes_to_write: Seq<u8>,
                        new_durable_state: Seq<u8>|
                        {
                            ::builtin::requires({
                                    ((((::builtin::spec_eq(bytes_to_write.len(),
                                                                        const_persistence_chunk_size())) &&
                                                                (::builtin::spec_eq((write_addr).spec_euclidean_mod(const_persistence_chunk_size()),
                                                                        ::builtin::spec_literal_nat("0")))) &&
                                                        ((::builtin::spec_literal_nat("0")).spec_le(write_addr))) &&
                                                (((write_addr).spec_add(const_persistence_chunk_size())).spec_le(durable_state.len())))
                                        &&
                                        (#[verus::internal(trigger)] can_result_from_partial_write(new_durable_state,
                                                durable_state, write_addr, bytes_to_write))
                                });
                            ::builtin::ensures({
                                    (::builtin::spec_eq(new_durable_state, durable_state)) ||
                                        (::builtin::spec_eq(new_durable_state,
                                                update_bytes(durable_state, write_addr, bytes_to_write)))
                                });
                            lemma_only_two_crash_states_introduced_by_aligned_chunk_write(new_durable_state,
                                durable_state, write_addr, bytes_to_write);
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn addresses_not_accessed_by_recovery<T>(s: Seq<u8>,
            addrs: Set<int>, recover_fn: ::builtin::FnSpec<(Seq<u8>,), T>)
            -> bool {
            ::builtin::forall(|s2: Seq<u8>|
                    ::builtin::imply({
                            (::builtin::spec_eq(s2.len(), s.len())) &&
                                (::builtin::forall(|i: int|
                                            ::builtin::with_triggers(((s2.spec_index(i),),),
                                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                    i), s.len())) && !addrs.contains(i),
                                                    ::builtin::spec_eq(s.spec_index(i), s2.spec_index(i))))))
                        },
                        ::builtin::spec_eq(#[verus::internal(trigger)] recover_fn(s2),
                            recover_fn(s))))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_if_addresses_unreachable_in_recovery_then_recovery_unchanged_by_write<T>(new_durable_state:
                Seq<u8>, durable_state: Seq<u8>, write_addr: int,
            bytes_to_write: Seq<u8>, addrs: Set<int>,
            recover_fn: ::builtin::FnSpec<(Seq<u8>,), T>) {
            ::builtin::requires([addresses_not_accessed_by_recovery::<T>(durable_state,
                            addrs, recover_fn),
                        ::builtin::forall(|addr: int|
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                addr), (write_addr).spec_add(bytes_to_write.len()))),
                                    addrs.contains(addr))),
                        (::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes_to_write.len())).spec_le(durable_state.len()),
                        can_result_from_partial_write(new_durable_state,
                            durable_state, write_addr, bytes_to_write)]);
            ::builtin::ensures([::builtin::spec_eq(recover_fn(new_durable_state),
                            recover_fn(durable_state))]);
            ::builtin::assert_(::builtin::spec_eq(new_durable_state.len(),
                    durable_state.len()));
            {
                ::builtin::assert_forall_by(|i: int|
                        {
                            ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), durable_state.len())) && !addrs.contains(i));
                            ::builtin::ensures(::builtin::spec_eq(new_durable_state.spec_index(i),
                                    durable_state.spec_index(i)));
                            lemma_auto_can_result_from_partial_write_effect();
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_auto_if_addresses_unreachable_in_recovery_then_recovery_unchanged_by_write<T>(durable_state:
                Seq<u8>, addrs: Set<int>,
            recover_fn: ::builtin::FnSpec<(Seq<u8>,), T>) {
            ::builtin::requires([addresses_not_accessed_by_recovery::<T>(durable_state,
                            addrs, recover_fn)]);
            ::builtin::ensures([::builtin::forall(|new_durable_state: Seq<u8>,
                                write_addr: int, bytes_to_write: Seq<u8>|
                                ::builtin::imply({
                                        (((::builtin::forall(|addr: int|
                                                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                                                        addr), (write_addr).spec_add(bytes_to_write.len()))),
                                                                            addrs.contains(addr)))) &&
                                                            ((::builtin::spec_literal_nat("0")).spec_le(write_addr))) &&
                                                    (((write_addr).spec_add(bytes_to_write.len())).spec_le(durable_state.len())))
                                            &&
                                            (#[verus::internal(trigger)] can_result_from_partial_write(new_durable_state,
                                                    durable_state, write_addr, bytes_to_write))
                                    },
                                    ::builtin::spec_eq(recover_fn(new_durable_state),
                                        recover_fn(durable_state))))]);
            {
                ::builtin::assert_forall_by(|new_durable_state: Seq<u8>,
                        write_addr: int, bytes_to_write: Seq<u8>|
                        {
                            ::builtin::requires({
                                    (((::builtin::forall(|addr: int|
                                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                                                    addr), (write_addr).spec_add(bytes_to_write.len()))),
                                                                        addrs.contains(addr)))) &&
                                                        ((::builtin::spec_literal_nat("0")).spec_le(write_addr))) &&
                                                (((write_addr).spec_add(bytes_to_write.len())).spec_le(durable_state.len())))
                                        &&
                                        (#[verus::internal(trigger)] can_result_from_partial_write(new_durable_state,
                                                durable_state, write_addr, bytes_to_write))
                                });
                            ::builtin::ensures(::builtin::spec_eq(recover_fn(new_durable_state),
                                    recover_fn(durable_state)));
                            lemma_if_addresses_unreachable_in_recovery_then_recovery_unchanged_by_write(new_durable_state,
                                durable_state, write_addr, bytes_to_write, addrs,
                                recover_fn);
                        });
            }
        }
        #[verus::internal(verus_macro)]
        pub fn calculate_crc<S>(val: &S) -> u64 where S: PmCopy + Sized {
            ::builtin::requires([::builtin::spec_eq(val.spec_crc(),
                            spec_crc_u64(val.spec_to_bytes()))]);
            ::builtin::ensures(|out: u64|
                    [::builtin::spec_eq(val.spec_crc(), out),
                            ::builtin::spec_eq(spec_crc_u64(val.spec_to_bytes()),
                                out)]);
            let mut digest = CrcDigest::new();
            digest.write(val);
            digest.sum64()
        }
        #[verus::internal(verus_macro)]
        pub fn calculate_crc_bytes(val: &[u8]) -> u64 {
            ::builtin::ensures(|out: u64|
                    [::builtin::spec_eq(out, spec_crc_u64((val.view()))),
                            ::builtin::spec_eq(out.spec_to_bytes(),
                                spec_crc_bytes((val.view())))]);
            let mut digest = CrcDigest::new();
            digest.write_bytes(val);

            #[verifier::proof_block]
            { lemma_auto_spec_u64_to_from_le_bytes(); }
            digest.sum64()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_establish_extract_bytes_equivalence(mem1: Seq<u8>,
            mem2: Seq<u8>) {
            ::builtin::ensures([::builtin::forall(|i: nat, n: nat|
                                ::builtin::imply(::builtin::ext_equal(extract_bytes(mem1, i,
                                            n), extract_bytes(mem2, i, n)),
                                    ::builtin::spec_eq(#[verus::internal(trigger)] extract_bytes(mem1,
                                            i, n),
                                        #[verus::internal(trigger)] extract_bytes(mem2, i, n))))]);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_subrange_of_subrange_equal(mem: Seq<u8>, pos1: nat,
            pos2: nat, pos3: nat, pos4: nat) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(pos1),
                                            pos2), pos3), pos4), mem.len()))]);
            ::builtin::ensures([::builtin::spec_eq(mem.subrange(::builtin::spec_cast_integer::<_,
                                        int>(pos2), ::builtin::spec_cast_integer::<_, int>(pos3)),
                            mem.subrange(::builtin::spec_cast_integer::<_, int>(pos1),
                                    ::builtin::spec_cast_integer::<_,
                                            int>(pos4)).subrange((pos2).spec_sub(pos1),
                                (pos3).spec_sub(pos1)))]);
            ::builtin::assert_(::builtin::ext_equal(mem.subrange(::builtin::spec_cast_integer::<_,
                                int>(pos2), ::builtin::spec_cast_integer::<_, int>(pos3)),
                    mem.subrange(::builtin::spec_cast_integer::<_, int>(pos1),
                            ::builtin::spec_cast_integer::<_,
                                    int>(pos4)).subrange((pos2).spec_sub(pos1),
                        (pos3).spec_sub(pos1))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_subrange_of_subrange_forall(mem: Seq<u8>) {
            ::builtin::ensures([::builtin::forall(|s1: int, e1: int, s2: int,
                                e2: int|
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        s1), e1), mem.len())) &&
                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        s2), e2), (e1).spec_sub(s1))),
                                    ::builtin::spec_eq(mem.subrange(s1, e1).subrange(s2, e2),
                                        mem.subrange((s1).spec_add(s2), (s1).spec_add(e2)))))]);
            {
                ::builtin::assert_forall_by(|s1: int, e1: int, s2: int,
                        e2: int|
                        {
                            ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    s1), e1), mem.len())) &&
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    s2), e2), (e1).spec_sub(s1))));
                            ::builtin::ensures(::builtin::spec_eq(mem.subrange(s1,
                                            e1).subrange(s2, e2),
                                    mem.subrange((s1).spec_add(s2), (s1).spec_add(e2))));
                            mem.lemma_slice_of_slice(s1, e1, s2, e2);
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_smaller_range_of_seq_is_subrange(mem1: Seq<u8>, i: int,
            j: int, k: int, l: int) {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                i), k), l), j), mem1.len()))]);
            ::builtin::ensures([::builtin::spec_eq(mem1.subrange(i,
                                    j).subrange((k).spec_sub(i), (l).spec_sub(i)),
                            mem1.subrange(k, l))]);
            ::builtin::assert_(::builtin::spec_eq(mem1.subrange(k, l),
                    mem1.subrange(((i).spec_add(k)).spec_sub(i),
                        ((i).spec_add(l)).spec_sub(i))));
            ::builtin::assert_(::builtin::spec_eq(mem1.subrange(i,
                            j).subrange((k).spec_sub(i), (l).spec_sub(i)),
                    mem1.subrange(((i).spec_add(k)).spec_sub(i),
                        ((i).spec_add(l)).spec_sub(i))));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_auto_smaller_range_of_seq_is_subrange(mem1: Seq<u8>) {
            ::builtin::ensures([::builtin::forall(|i: int, j, k: int, l: int|
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), k), l), j), mem1.len())),
                                    ::builtin::spec_eq(mem1.subrange(i,
                                                j).subrange((k).spec_sub(i), (l).spec_sub(i)),
                                        mem1.subrange(k, l))))]);
            {
                ::builtin::assert_forall_by(|i: int, j, k: int, l: int|
                        {
                            ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                        i), k), l), j), mem1.len())));
                            ::builtin::ensures(::builtin::spec_eq(mem1.subrange(i,
                                            j).subrange((k).spec_sub(i), (l).spec_sub(i)),
                                    mem1.subrange(k, l)));
                            lemma_smaller_range_of_seq_is_subrange(mem1, i, j, k, l);
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn lemma_update_then_subrange_is_updated_bytes(s: Seq<u8>,
            addr: int, bytes: Seq<u8>) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_le(addr),
                        ((addr).spec_add(bytes.len())).spec_le(s.len())]);
            ::builtin::ensures([::builtin::spec_eq((#[verus::internal(trigger)] update_bytes(s,
                                        addr, bytes)).subrange(addr, (addr).spec_add(bytes.len())),
                            bytes)]);
            ::builtin::assert_(::builtin::ext_equal(update_bytes(s, addr,
                            bytes).subrange(addr, (addr).spec_add(bytes.len())),
                    bytes));
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn no_outstanding_writes(v: PersistentMemoryRegionView) -> bool {
            ::builtin::spec_eq(v.read_state, v.durable_state)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn no_outstanding_writes_in_range(v: PersistentMemoryRegionView,
            start: int, end: int) -> bool {
            ::builtin::forall(|addr: int|
                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        addr), v.len())) &&
                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(start),
                                        addr), end)),
                        ::builtin::spec_eq(v.read_state.spec_index(addr),
                            v.durable_state.spec_index(addr))))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_can_result_from_partial_write_effect(s2: Seq<u8>,
            s1: Seq<u8>, write_addr: int, bytes: Seq<u8>) {
            ::builtin::requires([can_result_from_partial_write(s2, s1,
                            write_addr, bytes)]);
            ::builtin::ensures([::builtin::forall(|addr: int|
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    addr), s1.len())) &&
                                        !(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                            addr), (write_addr).spec_add(bytes.len())))),
                                    ::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                        s1.spec_index(addr)))),
                        ::builtin::forall(|addr: int|
                                ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                    addr), s1.len())) &&
                                        ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                    addr), (write_addr).spec_add(bytes.len()))),
                                    {
                                        (::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                                    s1.spec_index(addr))) ||
                                            (::builtin::spec_eq(s2.spec_index(addr),
                                                    bytes.spec_index((addr).spec_sub(write_addr))))
                                    }))]);
            {
                ::builtin::assert_forall_by(|addr: int|
                        {
                            ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                addr), s1.len())) &&
                                    !(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                        addr), (write_addr).spec_add(bytes.len())))));
                            ::builtin::ensures(::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                    s1.spec_index(addr)));
                            ::builtin::assert_(chunk_trigger((addr).spec_euclidean_div(const_persistence_chunk_size())));
                        });
            }
            {
                ::builtin::assert_forall_by(|addr: int|
                        {
                            ::builtin::requires(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                addr), s1.len())) &&
                                    ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                addr), (write_addr).spec_add(bytes.len()))));
                            ::builtin::ensures({
                                    (::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                                s1.spec_index(addr))) ||
                                        (::builtin::spec_eq(s2.spec_index(addr),
                                                bytes.spec_index((addr).spec_sub(write_addr))))
                                });
                            ::builtin::assert_(chunk_trigger((addr).spec_euclidean_div(const_persistence_chunk_size())));
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_auto_can_result_from_partial_write_effect() {
            ::builtin::ensures([::builtin::forall(|s2: Seq<u8>, s1: Seq<u8>,
                                write_addr: int, bytes: Seq<u8>|
                                ::builtin::imply(#[verus::internal(trigger)] can_result_from_partial_write(s2,
                                        s1, write_addr, bytes),
                                    {
                                        (::builtin::forall(|addr: int|
                                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                            addr), s1.len())) &&
                                                                !(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                                                    addr), (write_addr).spec_add(bytes.len())))),
                                                            ::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                                                s1.spec_index(addr))))) &&
                                            (::builtin::forall(|addr: int|
                                                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                            addr), s1.len())) &&
                                                                ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                                            addr), (write_addr).spec_add(bytes.len()))),
                                                            {
                                                                (::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                                                            s1.spec_index(addr))) ||
                                                                    (::builtin::spec_eq(s2.spec_index(addr),
                                                                            bytes.spec_index((addr).spec_sub(write_addr))))
                                                            })))
                                    }))]);
            {
                ::builtin::assert_forall_by(|s2: Seq<u8>, s1: Seq<u8>,
                        write_addr: int, bytes: Seq<u8>|
                        {
                            ::builtin::requires(#[verus::internal(trigger)] can_result_from_partial_write(s2,
                                    s1, write_addr, bytes));
                            ::builtin::ensures({
                                    (::builtin::forall(|addr: int|
                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        addr), s1.len())) &&
                                                            !(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                                                addr), (write_addr).spec_add(bytes.len())))),
                                                        ::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                                            s1.spec_index(addr))))) &&
                                        (::builtin::forall(|addr: int|
                                                    ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                                        addr), s1.len())) &&
                                                            ::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(write_addr),
                                                                        addr), (write_addr).spec_add(bytes.len()))),
                                                        {
                                                            (::builtin::spec_eq(#[verus::internal(trigger)] s2.spec_index(addr),
                                                                        s1.spec_index(addr))) ||
                                                                (::builtin::spec_eq(s2.spec_index(addr),
                                                                        bytes.spec_index((addr).spec_sub(write_addr))))
                                                        })))
                                });
                            lemma_can_result_from_partial_write_effect(s2, s1,
                                write_addr, bytes);
                        });
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn lemma_noop_can_result_from_partial_write(s: Seq<u8>,
            write_addr: int, bytes: Seq<u8>) {
            ::builtin::requires([(::builtin::spec_literal_nat("0")).spec_le(write_addr),
                        ((write_addr).spec_add(bytes.len())).spec_le(s.len())]);
            ::builtin::ensures([can_result_from_partial_write(s, s,
                            write_addr, bytes)]);
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn flush_pm_view(v: PersistentMemoryRegionView)
            -> PersistentMemoryRegionView {
            PersistentMemoryRegionView {
                read_state: v.read_state,
                durable_state: v.read_state,
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn views_match_at_addr(v1: PersistentMemoryRegionView,
            v2: PersistentMemoryRegionView, addr: int) -> bool {
            (::builtin::spec_eq(v1.read_state.spec_index(addr),
                        v2.read_state.spec_index(addr))) &&
                (::builtin::spec_eq(v1.durable_state.spec_index(addr),
                        v2.durable_state.spec_index(addr)))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn views_match_in_address_range(v1: PersistentMemoryRegionView,
            v2: PersistentMemoryRegionView, start: int, end: int) -> bool {
            ::builtin::forall(|addr|
                    ::builtin::with_triggers(((v1.read_state.spec_index(addr),),
                            (v1.durable_state.spec_index(addr),),
                            (v2.read_state.spec_index(addr),),
                            (v2.durable_state.spec_index(addr),)),
                        ::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(start),
                                        addr), end)), views_match_at_addr(v1, v2, addr))))
        }
    }
    pub mod pmcopy_t {
        //! This file contains the trusted specification of several traits that 
        //! help us prove that reading from PM is safe. Some of the traits in this 
        //! file correspond to macros defined in the `pmcopy` crate in this repository.
        //! It is also related to some external traits defined and specified 
        //! in pmem/traits_t.rs.
        //! 
        //! Both reading and writing to PM is potentially dangerous; this file 
        //! focuses on ensuring that reads are safe. We want to be able to 
        //! read bytes from PM and then cast them to some target type T,
        //! but this may result in undefined behavior if the bytes are 
        //! an invalid T value. Thus, before doing such a cast, we 
        //! need to be sure that 1) the bytes we are reading have been 
        //! properly initialized with a valid T and 2) they have not been
        //! corrupted. 
        //! 
        //! We also need to be sure that proofs use the correct size for T.
        //! This is tricky, because Verus has no way of obtaining the size 
        //! in bytes of a structure. Rust's std::mem::size_of function
        //! can give the size of a type in constant contexts, but this is 
        //! an exec function that cannot be used in spec or proof code.
        //! 
        //! This file contains the `PmCopy` trait, which indicates whether
        //! a type is safe to copy from PM and defines some methods and 
        //! axioms for dealing with such structures.
        #![verus::trusted]
        use crate::pmem::pmemspec_t::*;
        use builtin::*;
        use builtin_macros::*;
        use vstd::bytes;
        use vstd::bytes::*;
        use vstd::prelude::*;
        use vstd::layout::*;
        use crate::pmem::traits_t::{
            PmSized, PmSafe, ConstPmSized, UnsafeSpecPmSized,
        };
        use deps_hack::{crc64fast::Digest, pmcopy_primitive};
        use core::slice;
        use std::convert::TryInto;
        use std::ptr;
        use std::mem::MaybeUninit;
        #[verus::internal(reveal_group)]
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        pub fn pmcopy_axioms() {
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(axiom_bytes_len)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(axiom_to_from_bytes)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(axiom_u64_to_le_bytes)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
            ::builtin::reveal_hide_({
                    #[verus::internal(reveal_fn)]
                    fn __VERUS_REVEAL_INTERNAL__() {
                        ::builtin::reveal_hide_internal_path_(axiom_u64_from_le_bytes)
                    }
                    __VERUS_REVEAL_INTERNAL__
                }, 1);
        }
        #[verus::internal(verus_macro)]
        pub trait PmCopy: PmSized + SpecPmSized + Sized + PmSafe + Copy +
            CloneProof + EqProof {
        }
        #[verus::internal(verus_macro)]
        pub trait PmCopyHelper: PmCopy {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_to_bytes(self)
            -> Seq<u8>;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_from_bytes(bytes: Seq<u8>)
            -> Self;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn bytes_parseable(bytes: Seq<u8>)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_crc(self)
            -> u64;
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn as_byte_slice(&self)
            -> &[u8];
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn as_signed_byte_slice(&self)
            -> &[i8];
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_to_bytes(self) -> Seq<u8> {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_from_bytes(bytes: Seq<u8>) -> Self {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__bytes_parseable(bytes: Seq<u8>) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_crc(self) -> u64 {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn VERUS_SPEC__as_byte_slice(&self) -> &[u8] {
                ::builtin::ensures(|out: &[u8]|
                        [::builtin::spec_eq((out.view()), self.spec_to_bytes())]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn VERUS_SPEC__as_signed_byte_slice(&self) -> &[i8] {
                ::builtin::ensures(|out: &[i8]|
                        [::builtin::forall(|i: int|
                                        #[verus::internal(auto_trigger)] (::builtin::imply(::builtin::spec_chained_cmp(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                                            i), (out.view()).len())),
                                                ::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                                            u8>(out.spec_index(i)),
                                                    self.spec_to_bytes().spec_index(i)))))]);
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        impl<T> PmCopyHelper for T where T: PmCopy {
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            fn spec_to_bytes(self) -> Seq<u8> {
                ::core::panicking::panic("not implemented")
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn spec_from_bytes(bytes: Seq<u8>) -> Self {
                ::builtin::choose::<T,
                        _>(|x: T| ::builtin::spec_eq(x.spec_to_bytes(), bytes))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_crc(self) -> u64 { spec_crc_u64(self.spec_to_bytes()) }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn bytes_parseable(bytes: Seq<u8>) -> bool {
                ::builtin::spec_eq(Self::spec_from_bytes(bytes).spec_to_bytes(),
                    bytes)
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn as_byte_slice(&self) -> &[u8] {
                let ptr = self as *const Self;
                unsafe {
                    core::slice::from_raw_parts(ptr as *const u8,
                        Self::size_of() as usize)
                }
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn as_signed_byte_slice(&self) -> &[i8] {
                let ptr = self as *const Self;
                unsafe {
                    core::slice::from_raw_parts(ptr as *const i8,
                        Self::size_of() as usize)
                }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn axiom_bytes_len<S: PmCopy>(s: S) {
            ::builtin::ensures([::builtin::spec_eq(#[verus::internal(trigger)] s.spec_to_bytes().len(),
                            S::spec_size_of())]);
            admit();
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn axiom_to_from_bytes<S: PmCopy>(s: S) {
            ::builtin::ensures([::builtin::spec_eq(s,
                            #[verus::internal(trigger)] S::spec_from_bytes(s.spec_to_bytes()))]);
            admit();
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn axiom_u64_to_le_bytes(v: u64) {
            ::builtin::ensures([::builtin::spec_eq(v.spec_to_bytes(),
                            #[verus::internal(trigger)] spec_u64_to_le_bytes(v))]);
            admit();
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn axiom_u64_from_le_bytes(s: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(s.len(),
                            ::builtin::spec_literal_nat("8"))]);
            ::builtin::ensures([::builtin::spec_eq(u64::spec_from_bytes(s),
                            #[verus::internal(trigger)] spec_u64_from_le_bytes(s))]);
            admit();
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        pub fn axiom_from_bytes_equal<S: PmCopy>(s1: Seq<u8>, s2: Seq<u8>) {
            ::builtin::requires([::builtin::spec_eq(#[verus::internal(trigger)] S::spec_from_bytes(s1),
                            #[verus::internal(trigger)] S::spec_from_bytes(s2))]);
            ::builtin::ensures([::builtin::spec_eq(s1, s2)]);
            admit();
        }
        #[verus::internal(verus_macro)]
        impl PmCopy for u64 { }
        #[verifier::external_body]
        #[verifier::reject_recursive_types(S)]
        #[verus::internal(verus_macro)]
        pub struct MaybeCorruptedBytes<S> where S: PmCopy {
            val: Box<MaybeUninit<S>>,
        }
        #[verus::internal(verus_macro)]
        impl<S> MaybeCorruptedBytes<S> where S: PmCopy {
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new() -> Self {
                MaybeCorruptedBytes { val: Box::<S>::new_uninit() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(uninterp)]
            #[verus::internal(spec)]
            #[verus::internal(external_body)]
            pub fn view(self) -> Seq<u8> {
                ::core::panicking::panic("not implemented")
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn copy_from_slice(&mut self, bytes: &[u8],
                verus_tmp_true_val: Ghost<S>,
                verus_tmp_addrs: Ghost<Seq<int>>,
                verus_tmp_pmc: Ghost<PersistentMemoryConstants>) {
                #[verus::internal(header_unwrap_parameter)]
                let true_val;

                #[verifier::proof_block]
                { true_val = verus_tmp_true_val.view() };
                #[verus::internal(header_unwrap_parameter)]
                let addrs;

                #[verifier::proof_block]
                { addrs = verus_tmp_addrs.view() };
                #[verus::internal(header_unwrap_parameter)]
                let pmc;

                #[verifier::proof_block]
                { pmc = verus_tmp_pmc.view() };
                ::builtin::requires([pmc.maybe_corrupted((bytes.view()),
                                true_val.spec_to_bytes(), addrs),
                            ::builtin::spec_eq((bytes.view()).len(),
                                S::spec_size_of())]);
                ::builtin::ensures([::builtin::spec_eq((self.view()),
                                (bytes.view()))]);
                self.copy_from_slice_helper(bytes);
            }
            #[verifier::external]
            #[inline(always)]
            #[verus::internal(verus_macro)]
            fn copy_from_slice_helper(&mut self, bytes: &[u8]) {
                let self_bytes = self.val.as_bytes_mut();
                MaybeUninit::copy_from_slice(self_bytes, bytes);
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn as_slice(&self) -> &[u8] {
                ::builtin::ensures(|out: &[u8]|
                        [::builtin::spec_eq((out.view()), (self.view()))]);
                let bytes = self.val.as_bytes();
                unsafe { MaybeUninit::slice_assume_init_ref(bytes) }
            }
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn extract_init_val(self, verus_tmp_true_val: Ghost<S>)
                -> Box<S> {
                #[verus::internal(header_unwrap_parameter)]
                let true_val;

                #[verifier::proof_block]
                { true_val = verus_tmp_true_val.view() };
                ::builtin::requires([::builtin::spec_eq((self.view()),
                                true_val.spec_to_bytes())]);
                ::builtin::ensures(|out: Box<S>|
                        [::builtin::spec_eq(out, true_val)]);
                unsafe { self.val.assume_init() }
            }
        }
        #[verus::internal(verus_macro)]
        impl MaybeCorruptedBytes<u64> {
            #[verifier::external_body]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn extract_cdb(self, verus_tmp_true_bytes: Ghost<Seq<u8>>,
                verus_tmp_addrs: Ghost<Seq<int>>,
                verus_tmp_pmc: Ghost<PersistentMemoryConstants>) -> Box<u64> {
                #[verus::internal(header_unwrap_parameter)]
                let true_bytes;

                #[verifier::proof_block]
                { true_bytes = verus_tmp_true_bytes.view() };
                #[verus::internal(header_unwrap_parameter)]
                let addrs;

                #[verifier::proof_block]
                { addrs = verus_tmp_addrs.view() };
                #[verus::internal(header_unwrap_parameter)]
                let pmc;

                #[verifier::proof_block]
                { pmc = verus_tmp_pmc.view() };
                ::builtin::requires([pmc.maybe_corrupted((self.view()),
                                true_bytes, addrs),
                            ({
                                    let true_val = u64::spec_from_bytes(true_bytes);
                                    (::builtin::spec_eq(true_val, CDB_TRUE)) ||
                                        (::builtin::spec_eq(true_val, CDB_FALSE))
                                })]);
                ::builtin::ensures(|out: Box<u64>|
                        [::builtin::spec_eq(out.spec_to_bytes(), (self.view()))]);
                unsafe { self.val.assume_init() }
            }
        }
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn slice_range<T>(vec: &Vec<T>, start: usize, len: usize)
            -> &[T] {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), (start).spec_add(len)), (vec.view()).len())),
                        ((start).spec_add(len)).spec_le(usize::MAX)]);
            ::builtin::ensures(|out: &[T]|
                    [::builtin::spec_eq((out.view()),
                                (vec.view()).subrange(::builtin::spec_cast_integer::<_,
                                            int>(start), (start).spec_add(len)))]);
            &vec[start..start + len]
        }
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        pub fn slice_range_to_vec<T>(vec: &Vec<T>, start: usize, len: usize)
            -> Vec<T> where T: Clone {
            ::builtin::requires([::builtin::spec_chained_cmp(::builtin::spec_chained_le(::builtin::spec_chained_lt(::builtin::spec_chained_le(::builtin::spec_chained_value(::builtin::spec_literal_nat("0")),
                                        start), (start).spec_add(len)), (vec.view()).len())),
                        ((start).spec_add(len)).spec_le(usize::MAX)]);
            ::builtin::ensures(|out: Vec<T>|
                    [::builtin::spec_eq((out.view()),
                                (vec.view()).subrange(::builtin::spec_cast_integer::<_,
                                            int>(start), (start).spec_add(len)))]);
            vec[start..start + len].to_vec()
        }
        #[verus::internal(size_of)]
        const _: () = { ::builtin::global_size_of::<usize>(8); };
        #[verus::internal(size_of_broadcast_proof)]
        #[verifier::external_body]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        fn VERUS_layout_of_usize() {
            ::builtin::ensures([::builtin::spec_eq(#[verus::internal(trigger)] ::vstd::layout::size_of::<usize>(),
                            ::builtin::spec_literal_nat("8")),
                        ::vstd::layout::is_sized::<usize>()]);
        }
        #[verus::internal(size_of)]
        const _: () = { ::builtin::global_size_of::<isize>(8); };
        #[verus::internal(size_of_broadcast_proof)]
        #[verifier::external_body]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(broadcast_forall)]
        #[verus::internal(proof)]
        fn VERUS_layout_of_isize() {
            ::builtin::ensures([::builtin::spec_eq(#[verus::internal(trigger)] ::vstd::layout::size_of::<isize>(),
                            ::builtin::spec_literal_nat("8")),
                        ::vstd::layout::is_sized::<isize>()]);
        }
        #[verus::internal(verus_macro)]
        pub trait SpecPmSized: UnsafeSpecPmSized {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_size_of()
            -> nat;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn spec_align_of()
            -> nat;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_size_of() -> nat {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__spec_align_of() -> nat {
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        impl SpecPmSized for u8 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for u8 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> u8 {
                ::builtin::ensures(|res: u8|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for u8 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for u8 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for u8 {
            const SIZE: usize = 1usize;
            const ALIGN: usize = 1usize;
        }
        const SIZE_CHECK_U8: usize =
            (core::mem::size_of::<u8>() == <u8>::SIZE) as usize - 1;
        const ALIGN_CHECK_U8: usize =
            (core::mem::align_of::<u8>() == <u8>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for u8 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for u16 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(2usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(2usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for u16 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> u16 {
                ::builtin::ensures(|res: u16|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for u16 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for u16 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for u16 {
            const SIZE: usize = 2usize;
            const ALIGN: usize = 2usize;
        }
        const SIZE_CHECK_U16: usize =
            (core::mem::size_of::<u16>() == <u16>::SIZE) as usize - 1;
        const ALIGN_CHECK_U16: usize =
            (core::mem::align_of::<u16>() == <u16>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for u16 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for u32 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for u32 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> u32 {
                ::builtin::ensures(|res: u32|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for u32 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for u32 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for u32 {
            const SIZE: usize = 4usize;
            const ALIGN: usize = 4usize;
        }
        const SIZE_CHECK_U32: usize =
            (core::mem::size_of::<u32>() == <u32>::SIZE) as usize - 1;
        const ALIGN_CHECK_U32: usize =
            (core::mem::align_of::<u32>() == <u32>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for u32 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for u64 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for u64 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> u64 {
                ::builtin::ensures(|res: u64|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for u64 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for u64 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for u64 {
            const SIZE: usize = 8usize;
            const ALIGN: usize = 8usize;
        }
        const SIZE_CHECK_U64: usize =
            (core::mem::size_of::<u64>() == <u64>::SIZE) as usize - 1;
        const ALIGN_CHECK_U64: usize =
            (core::mem::align_of::<u64>() == <u64>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for u64 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for u128 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(16usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(16usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for u128 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> u128 {
                ::builtin::ensures(|res: u128|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for u128 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for u128 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for u128 {
            const SIZE: usize = 16usize;
            const ALIGN: usize = 16usize;
        }
        const SIZE_CHECK_U128: usize =
            (core::mem::size_of::<u128>() == <u128>::SIZE) as usize - 1;
        const ALIGN_CHECK_U128: usize =
            (core::mem::align_of::<u128>() == <u128>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for u128 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for usize {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for usize {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> usize {
                ::builtin::ensures(|res: usize|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for usize {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for usize {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for usize {
            const SIZE: usize = 8usize;
            const ALIGN: usize = 8usize;
        }
        const SIZE_CHECK_USIZE: usize =
            (core::mem::size_of::<usize>() == <usize>::SIZE) as usize - 1;
        const ALIGN_CHECK_USIZE: usize =
            (core::mem::align_of::<usize>() == <usize>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for usize {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for i8 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for i8 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> i8 {
                ::builtin::ensures(|res: i8|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for i8 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for i8 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for i8 {
            const SIZE: usize = 1usize;
            const ALIGN: usize = 1usize;
        }
        const SIZE_CHECK_I8: usize =
            (core::mem::size_of::<i8>() == <i8>::SIZE) as usize - 1;
        const ALIGN_CHECK_I8: usize =
            (core::mem::align_of::<i8>() == <i8>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for i8 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for i16 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(2usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(2usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for i16 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> i16 {
                ::builtin::ensures(|res: i16|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for i16 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for i16 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for i16 {
            const SIZE: usize = 2usize;
            const ALIGN: usize = 2usize;
        }
        const SIZE_CHECK_I16: usize =
            (core::mem::size_of::<i16>() == <i16>::SIZE) as usize - 1;
        const ALIGN_CHECK_I16: usize =
            (core::mem::align_of::<i16>() == <i16>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for i16 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for i32 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for i32 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> i32 {
                ::builtin::ensures(|res: i32|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for i32 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for i32 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for i32 {
            const SIZE: usize = 4usize;
            const ALIGN: usize = 4usize;
        }
        const SIZE_CHECK_I32: usize =
            (core::mem::size_of::<i32>() == <i32>::SIZE) as usize - 1;
        const ALIGN_CHECK_I32: usize =
            (core::mem::align_of::<i32>() == <i32>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for i32 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for i64 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for i64 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> i64 {
                ::builtin::ensures(|res: i64|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for i64 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for i64 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for i64 {
            const SIZE: usize = 8usize;
            const ALIGN: usize = 8usize;
        }
        const SIZE_CHECK_I64: usize =
            (core::mem::size_of::<i64>() == <i64>::SIZE) as usize - 1;
        const ALIGN_CHECK_I64: usize =
            (core::mem::align_of::<i64>() == <i64>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for i64 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for i128 {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(16usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(16usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for i128 {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> i128 {
                ::builtin::ensures(|res: i128|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for i128 {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for i128 {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for i128 {
            const SIZE: usize = 16usize;
            const ALIGN: usize = 16usize;
        }
        const SIZE_CHECK_I128: usize =
            (core::mem::size_of::<i128>() == <i128>::SIZE) as usize - 1;
        const ALIGN_CHECK_I128: usize =
            (core::mem::align_of::<i128>() == <i128>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for i128 {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for isize {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(8usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for isize {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> isize {
                ::builtin::ensures(|res: isize|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for isize {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for isize {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for isize {
            const SIZE: usize = 8usize;
            const ALIGN: usize = 8usize;
        }
        const SIZE_CHECK_ISIZE: usize =
            (core::mem::size_of::<isize>() == <isize>::SIZE) as usize - 1;
        const ALIGN_CHECK_ISIZE: usize =
            (core::mem::align_of::<isize>() == <isize>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for isize {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for bool {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for bool {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> bool {
                ::builtin::ensures(|res: bool|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for bool {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for bool {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for bool {
            const SIZE: usize = 1usize;
            const ALIGN: usize = 1usize;
        }
        const SIZE_CHECK_BOOL: usize =
            (core::mem::size_of::<bool>() == <bool>::SIZE) as usize - 1;
        const ALIGN_CHECK_BOOL: usize =
            (core::mem::align_of::<bool>() == <bool>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for bool {}
        #[verus::internal(verus_macro)]
        impl SpecPmSized for char {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> ::builtin::nat {
                ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
            }
        }
        #[verus::internal(verus_macro)]
        impl CloneProof for char {
            #[verus::internal(verus_macro)]
            fn clone_provable(&self) -> char {
                ::builtin::ensures(|res: char|
                        [::builtin::spec_eq(*self, res)]);
                self.clone()
            }
        }
        #[verus::internal(verus_macro)]
        impl EqProof for char {
            #[verus::internal(verus_macro)]
            fn eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                self == other
            }
        }
        unsafe impl PmSized for char {
            fn size_of() -> usize { Self::SIZE }
            fn align_of() -> usize { Self::ALIGN }
        }
        unsafe impl ConstPmSized for char {
            const SIZE: usize = 4usize;
            const ALIGN: usize = 4usize;
        }
        const SIZE_CHECK_CHAR: usize =
            (core::mem::size_of::<char>() == <char>::SIZE) as usize - 1;
        const ALIGN_CHECK_CHAR: usize =
            (core::mem::align_of::<char>() == <char>::ALIGN) as usize - 1;
        unsafe impl UnsafeSpecPmSized for char {}
        #[verus::internal(verus_macro)]
        impl<T: PmSafe + PmSized, const N : usize> SpecPmSized for [T; N] {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_size_of() -> nat {
                ::builtin::spec_cast_integer::<_,
                        nat>(((N).spec_mul(T::spec_size_of())))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            fn spec_align_of() -> nat { T::spec_align_of() }
        }
        #[verifier::opaque]
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        pub fn spec_padding_needed(offset: nat, align: nat) -> nat {
            let misalignment = (offset).spec_euclidean_mod(align);
            if (misalignment).spec_gt(::builtin::spec_literal_nat("0")) {
                    ::builtin::spec_cast_integer::<_,
                            nat>(((align).spec_sub(misalignment)))
                } else { ::builtin::spec_literal_integer("0") }
        }
        #[verus::internal(verus_macro)]
        pub const fn padding_needed(offset: usize, align: usize) -> usize {

            #[verus::internal(const_header_wrapper)]
            ||
                {
                    ::builtin::requires([(align).spec_gt(::builtin::spec_literal_nat("0")),
                                ({
                                        ((((::builtin::spec_eq(align,
                                                                            ::builtin::spec_literal_nat("1"))) ||
                                                                    (::builtin::spec_eq(align,
                                                                            ::builtin::spec_literal_nat("2")))) ||
                                                            (::builtin::spec_eq(align,
                                                                    ::builtin::spec_literal_nat("4")))) ||
                                                    (::builtin::spec_eq(align,
                                                            ::builtin::spec_literal_nat("8")))) ||
                                            (::builtin::spec_eq(align,
                                                    ::builtin::spec_literal_nat("16")))
                                    })]);
                    ::builtin::ensures(|out: usize|
                            [(out).spec_lt(align),
                                    ::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                                nat>(out),
                                        spec_padding_needed(::builtin::spec_cast_integer::<_,
                                                    nat>(offset),
                                            ::builtin::spec_cast_integer::<_, nat>(align)))]);
                };

            #[verifier::proof_block]
            {

                #[verus::internal(const_header_wrapper)]
                ||
                    {
                        ::builtin::reveal_hide_({
                                #[verus::internal(reveal_fn)]
                                fn __VERUS_REVEAL_INTERNAL__() {
                                    ::builtin::reveal_hide_internal_path_(spec_padding_needed)
                                }
                                __VERUS_REVEAL_INTERNAL__
                            }, 1)
                    };
            };
            let misalignment = offset % align;
            if misalignment > 0 { align - misalignment } else { 0 }
        }
        #[verus::internal(verus_macro)]
        pub trait CloneProof: Sized + Clone {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn clone_provable(&self)
            -> Self;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn VERUS_SPEC__clone_provable(&self) -> Self {
                ::builtin::ensures(|res: Self|
                        [::builtin::spec_eq(*self, res)]);
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub trait EqProof: Sized + Eq + PartialEq {
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn eq_provable(&self, other: &Self)
            -> bool;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn VERUS_SPEC__eq_provable(&self, other: &Self) -> bool {
                ::builtin::ensures(|b: bool|
                        [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
                ::builtin::no_method_body()
            }
        }
    }
    pub mod power_t {
        #![verus::trusted]
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::invariant::*;
        use vstd::pcm::frac::*;
        pub use crate::pmem::power_v::{
            PoWERPersistentMemoryRegion, PermissionFactory,
        };
        #[verus::internal(verus_macro)]
        pub trait CheckPermission<State>: Sized {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: State, s2: State)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn id(&self)
            -> int;
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self,
            #[verus::internal(proof)] credit: OpenInvariantCredit,
            #[verus::internal(proof)] r: &mut GhostVarAuth<State>,
            new_state: State);
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__check_permission(&self, s1: State, s2: State)
                -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__id(&self) -> int { ::builtin::no_method_body() }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn VERUS_SPEC__apply(#[verus::internal(proof)] self,
                #[verus::internal(proof)] credit: OpenInvariantCredit,
                #[verus::internal(proof)] r: &mut GhostVarAuth<State>,
                new_state: State) {
                ::builtin::requires([::builtin::spec_eq(self.id(),
                                old(r).id()),
                            self.check_permission((old(r).view()), new_state)]);
                ::builtin::ensures([::builtin::spec_eq(r.id(), old(r).id()),
                            ::builtin::spec_eq((r.view()), new_state)]);
                ::builtin::opens_invariants_any();
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub struct PersistentMemoryRegionAtomic<PM: PersistentMemoryRegion> {
            pub pm: PM,
            pub res: Tracked<GhostVarAuth<Seq<u8>>>,
        }
        #[verus::internal(verus_macro)]
        impl<PM: PersistentMemoryRegion> PersistentMemoryRegionAtomic<PM> {
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn inv(self) -> bool {
                ((self.pm.inv()) &&
                            (::builtin::spec_eq((self.pm.view()).durable_state,
                                    ((self.res.view()).view())))) &&
                    (::builtin::spec_eq((self.res.view()).id(), self.id()))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn id(self) -> int { (self.res.view()).id() }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn view(self) -> PersistentMemoryRegionView {
                (self.pm.view())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(open)]
            #[verus::internal(spec)]
            pub fn constants(self) -> PersistentMemoryConstants {
                self.pm.constants()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new(pm: PM) -> (Self, Tracked<GhostVar<Seq<u8>>>) {
                ::builtin::requires([pm.inv()]);
                ::builtin::ensures(|result:
                            (Self, Tracked<GhostVar<Seq<u8>>>)|
                        [result.0.inv(),
                                ::builtin::spec_eq(result.0.constants(), pm.constants()),
                                ::builtin::spec_eq((result.0.view()), (pm.view())),
                                ::builtin::spec_eq((result.1.view()).id(), result.0.id()),
                                ::builtin::spec_eq(((result.1.view()).view()),
                                    (pm.view()).durable_state)]);
                #[verus::internal(proof)]
                #[verus::internal(unwrapped_binding)]
                let verus_tmp;

                #[verifier::proof_block]
                { verus_tmp = GhostVarAuth::new((pm.view()).durable_state) };
                #[verus::internal(infer_mode)]
                let mut r_auth;
                #[verus::internal(infer_mode)]
                let mut r;

                #[verifier::proof_block]
                {
                    #[verus::internal(proof)]
                    let (verus_tmp_r_auth, verus_tmp_r) = verus_tmp;
                    r_auth = verus_tmp_r_auth;
                    r = verus_tmp_r;
                };
                let pm_la =
                    Self {
                        pm: pm,
                        res: #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] r_auth),
                    };
                (pm_la,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] r))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn write<Perm>(&mut self, addr: u64, bytes: &[u8],
                verus_tmp_perm: Tracked<Perm>) where
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).inv(),
                            ((addr).spec_add((bytes.view()).len())).spec_le((old(self).view()).len()),
                            ::builtin::spec_eq(perm.id(), old(self).id()),
                            ::builtin::forall(|s|
                                    ::builtin::imply(can_result_from_partial_write(s,
                                            (old(self).view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            (bytes.view())),
                                        #[verus::internal(trigger)] perm.check_permission((old(self).view()).durable_state,
                                            s)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.id(), old(self).id()),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            (self.view()).can_result_from_write((old(self).view()),
                                ::builtin::spec_cast_integer::<_, int>(addr),
                                (bytes.view()))]);
                self.pm.write(addr, bytes);
                let credit = create_open_invariant_credit();

                #[verifier::proof_block]
                {
                    perm.apply(credit.get(), self.res.borrow_mut(),
                        (self.pm.view()).durable_state);
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn serialize_and_write<S,
                Perm>(&mut self, addr: u64, to_write: &S,
                verus_tmp_perm: Tracked<Perm>) where S: PmCopy + Sized,
                Perm: CheckPermission<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm;

                #[verifier::proof_block]
                { perm = verus_tmp_perm.get() };
                ::builtin::requires([old(self).inv(),
                            ((addr).spec_add(S::spec_size_of())).spec_le((old(self).view()).len()),
                            ::builtin::spec_eq(perm.id(), old(self).id()),
                            ::builtin::forall(|s|
                                    ::builtin::imply(can_result_from_partial_write(s,
                                            (old(self).view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            to_write.spec_to_bytes()),
                                        #[verus::internal(trigger)] perm.check_permission((old(self).view()).durable_state,
                                            s)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.id(), old(self).id()),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            (self.view()).can_result_from_write((old(self).view()),
                                ::builtin::spec_cast_integer::<_, int>(addr),
                                to_write.spec_to_bytes())]);

                #[verus::internal(proof_block)]
                {
                    ::builtin::reveal_hide_({
                            #[verus::internal(reveal_fn)]
                            fn __VERUS_REVEAL_INTERNAL__() {
                                ::builtin::reveal_hide_internal_path_(pmcopy_axioms)
                            }

                            #[verus::internal(broadcast_use_reveal)]
                            __VERUS_REVEAL_INTERNAL__
                        }, 1);
                }
                self.pm.serialize_and_write(addr, to_write);
                let credit = create_open_invariant_credit();

                #[verifier::proof_block]
                {
                    perm.apply(credit.get(), self.res.borrow_mut(),
                        (self.pm.view()).durable_state);
                }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn flush(&mut self) {
                ::builtin::requires([old(self).inv()]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.id(), old(self).id()),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            ::builtin::spec_eq((self.view()), (old(self).view())),
                            (self.view()).flush_predicted()]);
                self.pm.flush()
            }
        }
    }
    pub mod power_sound_t {
        #![verus::trusted]
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::power_t::*;
        use vstd::prelude::*;
        use vstd::invariant::*;
        use vstd::pcm::frac::*;
        use std::sync::Arc;
        #[verus::internal(verus_macro)]
        trait PoWERApplication<PM>: Sized where PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn valid(self, state: Seq<u8>)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn setup(&self, pm: &mut PM);
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn run<PermFactory>(&self, pm: PersistentMemoryRegionAtomic<PM>,
            verus_tmp_perm_factory: Tracked<PermFactory>)
            where
            PermFactory: PermissionFactory<Seq<u8>>;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__valid(self, state: Seq<u8>) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn VERUS_SPEC__setup(&self, pm: &mut PM) {
                ::builtin::requires([old(pm).inv()]);
                ::builtin::ensures([pm.inv(),
                            self.valid((pm.view()).durable_state)]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn VERUS_SPEC__run<PermFactory>(&self,
                pm: PersistentMemoryRegionAtomic<PM>,
                verus_tmp_perm_factory: Tracked<PermFactory>) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                ::builtin::requires([pm.inv(),
                            ::builtin::spec_eq((pm.view()).durable_state,
                                (pm.view()).read_state),
                            ::builtin::spec_eq(perm_factory.id(), pm.id()),
                            ::builtin::forall(|s1, s2|
                                    ::builtin::imply(self.valid(s2),
                                        #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                            s2))), self.valid((pm.view()).durable_state)]);
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        struct ExampleApp {
            addr: u64,
            val0: u8,
            val1: u8,
        }
        #[verus::internal(verus_macro)]
        impl<PM> PoWERApplication<PM> for ExampleApp where
            PM: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn valid(self, state: Seq<u8>) -> bool {
                ((self.addr).spec_lt(state.len())) &&
                    ({
                            (::builtin::spec_eq(state.spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(self.addr)), self.val0)) ||
                                (::builtin::spec_eq(state.spec_index(::builtin::spec_cast_integer::<_,
                                                    int>(self.addr)), self.val1))
                        })
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn setup(&self, pm: &mut PM) {
                let len = pm.get_region_size();
                if self.addr >= len { loop {} }
                pm.write(self.addr,
                    <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.val0])).as_slice());
                pm.flush();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            fn run<PermFactory>(&self, pm: PersistentMemoryRegionAtomic<PM>,
                verus_tmp_perm_factory: Tracked<PermFactory>) where
                PermFactory: PermissionFactory<Seq<u8>> {
                #[verus::internal(header_unwrap_parameter)]
                let perm_factory;

                #[verifier::proof_block]
                { perm_factory = verus_tmp_perm_factory.get() };
                let mut power_pm: PoWERPersistentMemoryRegion<PM> =
                    PoWERPersistentMemoryRegion::new_atomic(pm);
                loop {
                    ::builtin::invariant([power_pm.inv(),
                                ::builtin::spec_eq(perm_factory.id(), power_pm.id()),
                                (self.addr).spec_lt((power_pm.view()).len()),
                                <Self as
                                        PoWERApplication<PM>>::valid(*self,
                                    (power_pm.view()).durable_state),
                                ::builtin::forall(|s1, s2|
                                        ::builtin::imply(<Self as
                                                    PoWERApplication<PM>>::valid(*self, s2),
                                            #[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                s2)))]);

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_forall_by(|s1, s2|
                                            {
                                                ::builtin::requires(<Self as
                                                                PoWERApplication<PM>>::valid(*self, s1) &&
                                                        can_result_from_partial_write(s2, s1,
                                                            ::builtin::spec_cast_integer::<_, int>(self.addr),
                                                            ::vstd::vstd::seq::Seq::empty().push(self.val0)));
                                                ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                        s2));
                                                crate::pmem::pmemutil_v::lemma_can_result_from_partial_write_effect(s2,
                                                    s1, ::builtin::spec_cast_integer::<_, int>(self.addr),
                                                    ::vstd::vstd::seq::Seq::empty().push(self.val0));
                                            });
                                }
                            };
                    }

                    #[verifier::proof_block]
                    {

                        #[verus::internal(const_header_wrapper)]
                        ||
                            {
                                {
                                    ::builtin::assert_forall_by(|s1, s2|
                                            {
                                                ::builtin::requires(<Self as
                                                                PoWERApplication<PM>>::valid(*self, s1) &&
                                                        can_result_from_partial_write(s2, s1,
                                                            ::builtin::spec_cast_integer::<_, int>(self.addr),
                                                            ::vstd::vstd::seq::Seq::empty().push(self.val1)));
                                                ::builtin::ensures(#[verus::internal(trigger)] perm_factory.check_permission(s1,
                                                        s2));
                                                crate::pmem::pmemutil_v::lemma_can_result_from_partial_write_effect(s2,
                                                    s1, ::builtin::spec_cast_integer::<_, int>(self.addr),
                                                    ::vstd::vstd::seq::Seq::empty().push(self.val1));
                                            });
                                }
                            };
                    }
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (power_pm.view()).durable_state };
                    #[verus::internal(spec)]
                    let mut durable_0;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_0 = verus_tmp;
                        durable_0 = verus_tmp_durable_0;
                    };
                    power_pm.write::<PermFactory::Perm>(self.addr,
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.val0])).as_slice(),
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (power_pm.view()).durable_state };
                    #[verus::internal(spec)]
                    let mut durable_1;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_1 = verus_tmp;
                        durable_1 = verus_tmp_durable_1;
                    };

                    #[verifier::proof_block]
                    {
                        crate::pmem::pmemutil_v::lemma_can_result_from_partial_write_effect(durable_1,
                            durable_0,
                            ::builtin::spec_cast_integer::<_, int>(self.addr),
                            ::vstd::vstd::seq::Seq::empty().push(self.val0));
                    }
                    power_pm.write::<PermFactory::Perm>(self.addr,
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.val1])).as_slice(),
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (power_pm.view()).durable_state };
                    #[verus::internal(spec)]
                    let mut durable_2;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_2 = verus_tmp;
                        durable_2 = verus_tmp_durable_2;
                    };

                    #[verifier::proof_block]
                    {
                        crate::pmem::pmemutil_v::lemma_can_result_from_partial_write_effect(durable_2,
                            durable_1,
                            ::builtin::spec_cast_integer::<_, int>(self.addr),
                            ::vstd::vstd::seq::Seq::empty().push(self.val1));
                    }
                    power_pm.flush();
                    power_pm.write::<PermFactory::Perm>(self.addr,
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.val1])).as_slice(),
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (power_pm.view()).durable_state };
                    #[verus::internal(spec)]
                    let mut durable_3;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_3 = verus_tmp;
                        durable_3 = verus_tmp_durable_3;
                    };

                    #[verifier::proof_block]
                    {
                        crate::pmem::pmemutil_v::lemma_can_result_from_partial_write_effect(durable_3,
                            durable_2,
                            ::builtin::spec_cast_integer::<_, int>(self.addr),
                            ::vstd::vstd::seq::Seq::empty().push(self.val1));
                    }
                    power_pm.write::<PermFactory::Perm>(self.addr,
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([self.val0])).as_slice(),
                        #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory.grant_permission()));
                    #[verus::internal(spec)]
                    #[verus::internal(unwrapped_binding)]
                    let mut verus_tmp;

                    #[verifier::proof_block]
                    { verus_tmp = (power_pm.view()).durable_state };
                    #[verus::internal(spec)]
                    let mut durable_4;

                    #[verifier::proof_block]
                    {
                        #[verus::internal(spec)]
                        let verus_tmp_durable_4 = verus_tmp;
                        durable_4 = verus_tmp_durable_4;
                    };

                    #[verifier::proof_block]
                    {
                        crate::pmem::pmemutil_v::lemma_can_result_from_partial_write_effect(durable_4,
                            durable_3,
                            ::builtin::spec_cast_integer::<_, int>(self.addr),
                            ::vstd::vstd::seq::Seq::empty().push(self.val0));
                    }
                    power_pm.flush();
                }
            }
        }
        #[verus::internal(verus_macro)]
        struct DurableResource {
            r: GhostVar<Seq<u8>>,
        }
        #[verus::internal(verus_macro)]
        struct DurablePredicate<PM, A> where PM: PersistentMemoryRegion,
            A: PoWERApplication<PM> {
            id: int,
            app: A,
            _pm: core::marker::PhantomData<PM>,
        }
        #[verus::internal(verus_macro)]
        impl<PM, A>
            InvariantPredicate<DurablePredicate<PM, A>, DurableResource> for
            DurablePredicate<PM, A> where PM: PersistentMemoryRegion,
            A: PoWERApplication<PM> {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn inv(pred: DurablePredicate<PM, A>, inner: DurableResource)
                -> bool {
                (::builtin::spec_eq(inner.r.id(), pred.id)) &&
                    (pred.app.valid((inner.r.view())))
            }
        }
        #[verus::internal(verus_macro)]
        struct SoundPermission<PM, A> where PM: PersistentMemoryRegion,
            A: PoWERApplication<PM> {
            inv: Arc<AtomicInvariant<DurablePredicate<PM, A>, DurableResource,
            DurablePredicate<PM, A>>>,
        }
        #[verus::internal(verus_macro)]
        impl<PM, A> CheckPermission<Seq<u8>> for SoundPermission<PM, A> where
            PM: PersistentMemoryRegion, A: PoWERApplication<PM> {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: Seq<u8>, s2: Seq<u8>) -> bool {
                self.inv.constant().app.valid(s2)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn id(&self) -> int { self.inv.constant().id }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self,
                #[verus::internal(proof)] credit: OpenInvariantCredit,
                #[verus::internal(proof)] r: &mut GhostVarAuth<Seq<u8>>,
                new_state: Seq<u8>) {

                #[verifier::invariant_block]
                {

                    #[cfg(verus_keep_ghost_body)]
                    ::vstd::vstd::invariant::spend_open_invariant_credit_in_proof(credit);
                    #[cfg(verus_keep_ghost_body)]
                    #[allow(unused_mut)]
                    let (guard, mut inner) =
                        ::vstd::vstd::invariant::open_atomic_invariant_begin(&self.inv);
                    { r.update(&mut inner.r, new_state); }

                    #[cfg(verus_keep_ghost_body)]
                    ::vstd::vstd::invariant::open_invariant_end(guard, inner);
                };
            }
        }
        #[verus::internal(verus_macro)]
        impl<PM, A> PermissionFactory<Seq<u8>> for SoundPermission<PM, A>
            where PM: PersistentMemoryRegion, A: PoWERApplication<PM> {
            type Perm = SoundPermission<PM, A>;
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: Seq<u8>, s2: Seq<u8>) -> bool {
                CheckPermission::check_permission(self, s1, s2)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn id(&self) -> int { CheckPermission::id(self) }
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn grant_permission(#[verus::internal(proof)] &self)
                -> SoundPermission<PM, A> {
                Self { inv: self.inv.clone() }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn clone(#[verus::internal(proof)] &self) -> Self {
                Self { inv: self.inv.clone() }
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        fn main_first_time<PM, A>(mut pm: PM, app: A) where
            PM: PersistentMemoryRegion, A: PoWERApplication<PM> {
            ::builtin::requires([pm.inv()]);
            app.setup(&mut pm);
            let (mut pm_atomic, verus_tmp_r) =
                PersistentMemoryRegionAtomic::new(pm);
            #[verus::internal(proof)]
            let mut r;

            #[verifier::proof_block]
            { r = verus_tmp_r.get(); };
            #[verus::internal(spec)]
            #[verus::internal(unwrapped_binding)]
            let mut verus_tmp;

            #[verifier::proof_block]
            {
                verus_tmp =
                    DurablePredicate {
                        id: r.id(),
                        app: app,
                        _pm: core::marker::PhantomData,
                    }
            };
            #[verus::internal(spec)]
            let mut pred;

            #[verifier::proof_block]
            {
                #[verus::internal(spec)]
                let verus_tmp_pred = verus_tmp;
                pred = verus_tmp_pred;
            };
            #[verus::internal(proof)]
            #[verus::internal(unwrapped_binding)]
            let verus_tmp;

            #[verifier::proof_block]
            { verus_tmp = DurableResource { r: r } };
            #[verus::internal(infer_mode)]
            let mut inv_res;

            #[verifier::proof_block]
            {
                #[verus::internal(proof)]
                let verus_tmp_inv_res = verus_tmp;
                inv_res = verus_tmp_inv_res;
            };
            #[verus::internal(proof)]
            #[verus::internal(unwrapped_binding)]
            let verus_tmp;

            #[verifier::proof_block]
            {
                verus_tmp =
                    AtomicInvariant::<_, _,
                            DurablePredicate<PM,
                            A>>::new(pred, inv_res,
                        ::builtin::spec_literal_integer("0"))
            };
            #[verus::internal(infer_mode)]
            let mut inv;

            #[verifier::proof_block]
            {
                #[verus::internal(proof)]
                let verus_tmp_inv = verus_tmp;
                inv = verus_tmp_inv;
            };
            pm_atomic.flush();
            #[verus::internal(proof)]
            #[verus::internal(unwrapped_binding)]
            let verus_tmp;

            #[verifier::proof_block]
            { verus_tmp = SoundPermission { inv: Arc::new(inv) } };
            #[verus::internal(infer_mode)]
            let mut perm_factory;

            #[verifier::proof_block]
            {
                #[verus::internal(proof)]
                let verus_tmp_perm_factory = verus_tmp;
                perm_factory = verus_tmp_perm_factory;
            };
            app.run::<SoundPermission<PM,
                A>>(pm_atomic,
                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(exec)]
        fn main_after_crash<PM, A>(pm: PM, app: A) where
            PM: PersistentMemoryRegion, A: PoWERApplication<PM> {
            ::builtin::requires([pm.inv()]);
            let (mut pm_atomic, verus_tmp_r) =
                PersistentMemoryRegionAtomic::new(pm);
            #[verus::internal(proof)]
            let mut r;

            #[verifier::proof_block]
            { r = verus_tmp_r.get(); };
            #[verus::internal(spec)]
            #[verus::internal(unwrapped_binding)]
            let mut verus_tmp;

            #[verifier::proof_block]
            {
                verus_tmp =
                    DurablePredicate {
                        id: r.id(),
                        app: app,
                        _pm: core::marker::PhantomData,
                    }
            };
            #[verus::internal(spec)]
            let mut pred;

            #[verifier::proof_block]
            {
                #[verus::internal(spec)]
                let verus_tmp_pred = verus_tmp;
                pred = verus_tmp_pred;
            };
            #[verus::internal(proof)]
            #[verus::internal(unwrapped_binding)]
            let verus_tmp;

            #[verifier::proof_block]
            { verus_tmp = invariant_recovery_axiom(pred) };
            #[verus::internal(infer_mode)]
            let mut inv;

            #[verifier::proof_block]
            {
                #[verus::internal(proof)]
                let verus_tmp_inv = verus_tmp;
                inv = verus_tmp_inv;
            };
            #[cfg(verus_keep_ghost_body)]
            let credit =
                ::vstd::vstd::invariant::create_open_invariant_credit();

            #[verifier::invariant_block]
            {

                #[cfg(verus_keep_ghost_body)]
                ::vstd::vstd::invariant::spend_open_invariant_credit(credit);
                #[cfg(verus_keep_ghost_body)]
                #[allow(unused_mut)]
                let (guard, mut inner) =
                    ::vstd::vstd::invariant::open_atomic_invariant_begin(&inv);
                {

                    #[verifier::proof_block]
                    { pm_atomic.res.borrow().agree(&inner.r); }
                }

                #[cfg(verus_keep_ghost_body)]
                ::vstd::vstd::invariant::open_invariant_end(guard, inner);
            };
            pm_atomic.flush();
            #[verus::internal(proof)]
            #[verus::internal(unwrapped_binding)]
            let verus_tmp;

            #[verifier::proof_block]
            { verus_tmp = SoundPermission { inv: Arc::new(inv) } };
            #[verus::internal(infer_mode)]
            let mut perm_factory;

            #[verifier::proof_block]
            {
                #[verus::internal(proof)]
                let verus_tmp_perm_factory = verus_tmp;
                perm_factory = verus_tmp_perm_factory;
            };
            app.run::<SoundPermission<PM,
                A>>(pm_atomic,
                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory))
        }
        #[verifier::external_body]
        #[verus::internal(verus_macro)]
        #[verus::internal(returns(proof))]
        #[verus::internal(proof)]
        fn invariant_recovery_axiom<PM, A>(pred: DurablePredicate<PM, A>)
            ->
                AtomicInvariant<DurablePredicate<PM, A>, DurableResource,
                DurablePredicate<PM, A>> where PM: PersistentMemoryRegion,
            A: PoWERApplication<PM> {
            ::builtin::ensures(|result:
                        AtomicInvariant<DurablePredicate<PM, A>, DurableResource,
                        DurablePredicate<PM, A>>|
                    [::builtin::spec_eq(result.constant(), pred)]);
            ::core::panicking::panic("not implemented")
        }
    }
    pub mod power_v {
        #![verus::trusted]
        use crate::pmem::pmemspec_t::*;
        use crate::pmem::pmcopy_t::*;
        use crate::pmem::power_t::*;
        use builtin::*;
        use builtin_macros::*;
        use vstd::prelude::*;
        use vstd::invariant::*;
        use vstd::pcm::frac::*;
        #[verus::internal(verus_macro)]
        pub trait SimpleCheckPermission<State>: Sized {
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn check_permission(&self, s: State)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn id(&self)
            -> int;
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self,
            #[verus::internal(proof)] credit: OpenInvariantCredit,
            #[verus::internal(proof)] r: &mut GhostVarAuth<State>,
            new_state: State);
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__check_permission(&self, s: State) -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__id(&self) -> int { ::builtin::no_method_body() }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn VERUS_SPEC__apply(#[verus::internal(proof)] self,
                #[verus::internal(proof)] credit: OpenInvariantCredit,
                #[verus::internal(proof)] r: &mut GhostVarAuth<State>,
                new_state: State) {
                ::builtin::requires([::builtin::spec_eq(self.id(),
                                old(r).id()), self.check_permission(new_state)]);
                ::builtin::ensures([::builtin::spec_eq(r.id(), old(r).id()),
                            ::builtin::spec_eq((r.view()), new_state)]);
                ::builtin::opens_invariants_any();
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub struct SimplePermissionAdapter<State, SimplePerm> where
            SimplePerm: SimpleCheckPermission<State> {
            perm: SimplePerm,
            _state: core::marker::PhantomData<State>,
        }
        #[verus::internal(verus_macro)]
        impl<State, SimplePerm> SimplePermissionAdapter<State, SimplePerm>
            where SimplePerm: SimpleCheckPermission<State> {
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn new(#[verus::internal(proof)] perm: SimplePerm) -> Self {
                ::builtin::ensures(|result: Self|
                        [::builtin::spec_eq(result.id(), perm.id()),
                                ::builtin::forall(|s1, s2|
                                        (perm.check_permission(s2)) ==
                                            (result.check_permission(s1, s2)))]);
                Self { perm: perm, _state: core::marker::PhantomData }
            }
        }
        #[verus::internal(verus_macro)]
        impl<State, SimplePerm> CheckPermission<State> for
            SimplePermissionAdapter<State, SimplePerm> where
            SimplePerm: SimpleCheckPermission<State> {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: State, s2: State) -> bool {
                self.perm.check_permission(s2)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn id(&self) -> int { self.perm.id() }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self,
                #[verus::internal(proof)] credit: OpenInvariantCredit,
                #[verus::internal(proof)] r: &mut GhostVarAuth<State>,
                new_state: State) {
                self.perm.apply(credit, r, new_state)
            }
        }
        #[verus::internal(verus_macro)]
        pub trait PermissionFactory<State>: Sized {
            type Perm: CheckPermission<State>;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: State, s2: State)
            -> bool;
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn id(&self)
            -> int;
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn grant_permission(#[verus::internal(proof)] &self)
            -> Self::Perm;
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn clone(#[verus::internal(proof)] &self)
            -> Self;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__check_permission(&self, s1: State, s2: State)
                -> bool {
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn VERUS_SPEC__id(&self) -> int { ::builtin::no_method_body() }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn VERUS_SPEC__grant_permission(#[verus::internal(proof)] &self)
                -> Self::Perm {
                ::builtin::ensures(|perm: Self::Perm|
                        [::builtin::spec_eq(self.id(), perm.id()),
                                ::builtin::forall(|s1, s2|
                                        ::builtin::imply(self.check_permission(s1, s2),
                                            #[verus::internal(trigger)] perm.check_permission(s1,
                                                s2)))]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            fn VERUS_SPEC__clone(#[verus::internal(proof)] &self) -> Self {
                ::builtin::ensures(|other: Self|
                        [::builtin::spec_eq(self.id(), other.id()),
                                ::builtin::forall(|s1, s2|
                                        ::builtin::imply(self.check_permission(s1, s2),
                                            #[verus::internal(trigger)] other.check_permission(s1,
                                                s2)))]);
                ::builtin::no_method_body()
            }
        }
        #[verus::internal(verus_macro)]
        pub struct CombinedPermission<State, PermA, PermB> where
            PermA: CheckPermission<State>, PermB: CheckPermission<State> {
            a: PermA,
            b: PermB,
            _s: core::marker::PhantomData<State>,
        }
        #[verus::internal(verus_macro)]
        impl<State, PermA, PermB> CombinedPermission<State, PermA, PermB>
            where PermA: CheckPermission<State>, PermB: CheckPermission<State>
            {
            #[verifier::type_invariant]
            #[verus::internal(verus_macro)]
            #[verus::internal(spec)]
            fn inv(self) -> bool {
                ::builtin::spec_eq(self.a.id(), self.b.id())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(returns(proof))]
            #[verus::internal(proof)]
            pub fn new(#[verus::internal(proof)] a: PermA,
                #[verus::internal(proof)] b: PermB) -> Self {
                ::builtin::requires([::builtin::spec_eq(a.id(), b.id())]);
                ::builtin::ensures(|combined: Self|
                        [::builtin::spec_eq(combined.id(), a.id()),
                                ::builtin::forall(|s1: State, s2: State|
                                        (#[verus::internal(trigger)] combined.check_permission(s1,
                                                    s2)) ==
                                            (a.check_permission(s1, s2) ||
                                                    b.check_permission(s1, s2)))]);
                Self { a: a, b: b, _s: core::marker::PhantomData }
            }
        }
        #[verus::internal(verus_macro)]
        impl<State, PermA, PermB> CheckPermission<State> for
            CombinedPermission<State, PermA, PermB> where
            PermA: CheckPermission<State>, PermB: CheckPermission<State> {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn check_permission(&self, s1: State, s2: State) -> bool {
                self.a.check_permission(s1, s2) ||
                    self.b.check_permission(s1, s2)
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            fn id(&self) -> int { self.a.id() }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            fn apply(#[verus::internal(proof)] self,
                #[verus::internal(proof)] credit: OpenInvariantCredit,
                #[verus::internal(proof)] r: &mut GhostVarAuth<State>,
                new_state: State) {
                use_type_invariant(&self);
                if self.a.check_permission((r.view()), new_state) {
                        self.a.apply(credit, r, new_state)
                    } else { self.b.apply(credit, r, new_state) }
            }
        }
        #[allow(dead_code)]
        #[verus::internal(verus_macro)]
        pub struct PoWERPersistentMemoryRegion<PMRegion> where
            PMRegion: PersistentMemoryRegion {
            pm_region: PersistentMemoryRegionAtomic<PMRegion>,
        }
        #[verus::internal(verus_macro)]
        impl<PMRegion> PoWERPersistentMemoryRegion<PMRegion> where
            PMRegion: PersistentMemoryRegion {
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn view(&self) -> PersistentMemoryRegionView {
                (self.pm_region.view())
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn inv(&self) -> bool { self.pm_region.inv() }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn constants(&self) -> PersistentMemoryConstants {
                self.pm_region.constants()
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(closed)]
            #[verus::internal(spec)]
            pub fn id(&self) -> int { self.pm_region.id() }
            #[verus::internal(verus_macro)]
            #[verus::internal(proof)]
            pub fn lemma_inv_implies_view_valid(&self) {
                ::builtin::requires([self.inv()]);
                ::builtin::ensures([(self.view()).valid(),
                            self.constants().valid()]);
                self.pm_region.pm.lemma_inv_implies_view_valid();
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new(pm_region: PMRegion)
                -> (Self, Tracked<GhostVar<Seq<u8>>>) {
                ::builtin::requires([pm_region.inv()]);
                ::builtin::ensures(|result:
                            (Self, Tracked<GhostVar<Seq<u8>>>)|
                        [result.0.inv(),
                                ::builtin::spec_eq((result.0.view()), (pm_region.view())),
                                ::builtin::spec_eq(result.0.constants(),
                                    pm_region.constants()),
                                ::builtin::spec_eq((result.1.view()).id(), result.0.id()),
                                ::builtin::spec_eq(((result.1.view()).view()),
                                    (result.0.view()).durable_state)]);
                let (pm_region, verus_tmp_r) =
                    PersistentMemoryRegionAtomic::new(pm_region);
                #[verus::internal(proof)]
                let mut r;

                #[verifier::proof_block]
                { r = verus_tmp_r.get(); };
                let power_region = Self { pm_region: pm_region };
                (power_region,
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] r))
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn new_atomic(pm_region:
                    PersistentMemoryRegionAtomic<PMRegion>) -> Self {
                ::builtin::requires([pm_region.inv()]);
                ::builtin::ensures(|result: Self|
                        [result.inv(),
                                ::builtin::spec_eq((result.view()), (pm_region.view())),
                                ::builtin::spec_eq(result.constants(),
                                    pm_region.constants()),
                                ::builtin::spec_eq(result.id(), pm_region.id())]);
                Self { pm_region: pm_region }
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn get_pm_region_ref(&self) -> &PMRegion {
                ::builtin::requires([self.inv()]);
                ::builtin::ensures(|pm_region: &PMRegion|
                        [pm_region.inv(),
                                ::builtin::spec_eq((pm_region.view()), (self.view())),
                                ::builtin::spec_eq(pm_region.constants(),
                                    self.constants())]);
                &self.pm_region.pm
            }
            #[allow(unused_variables)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn write<Perm>(&mut self, addr: u64, bytes: &[u8],
                perm: Tracked<Perm>) where Perm: CheckPermission<Seq<u8>> {
                ::builtin::requires([old(self).inv(),
                            ::builtin::spec_eq((perm.view()).id(), old(self).id()),
                            ((addr).spec_add((bytes.view()).len())).spec_le((old(self).view()).len()),
                            ::builtin::forall(|s|
                                    ::builtin::imply(can_result_from_partial_write(s,
                                            (old(self).view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            (bytes.view())),
                                        #[verus::internal(trigger)] (perm.view()).check_permission((old(self).view()).durable_state,
                                            s)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            ::builtin::spec_eq(self.id(), old(self).id()),
                            (self.view()).can_result_from_write((old(self).view()),
                                ::builtin::spec_cast_integer::<_, int>(addr),
                                (bytes.view()))]);
                self.pm_region.write(addr, bytes, perm);
            }
            #[allow(unused_variables)]
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn serialize_and_write<Perm,
                S>(&mut self, addr: u64, to_write: &S, perm: Tracked<Perm>)
                where Perm: CheckPermission<Seq<u8>>, S: PmCopy + Sized {
                ::builtin::requires([old(self).inv(),
                            ::builtin::spec_eq((perm.view()).id(), old(self).id()),
                            ((addr).spec_add(S::spec_size_of())).spec_le((old(self).view()).len()),
                            ::builtin::forall(|s|
                                    ::builtin::imply(can_result_from_partial_write(s,
                                            (old(self).view()).durable_state,
                                            ::builtin::spec_cast_integer::<_, int>(addr),
                                            to_write.spec_to_bytes()),
                                        #[verus::internal(trigger)] (perm.view()).check_permission((old(self).view()).durable_state,
                                            s)))]);
                ::builtin::ensures([self.inv(),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            ::builtin::spec_eq(self.id(), old(self).id()),
                            (self.view()).can_result_from_write((old(self).view()),
                                ::builtin::spec_cast_integer::<_, int>(addr),
                                to_write.spec_to_bytes())]);
                self.pm_region.serialize_and_write(addr, to_write, perm);
            }
            #[verus::internal(verus_macro)]
            #[verus::internal(exec)]
            pub fn flush(&mut self) {
                ::builtin::requires([old(self).inv()]);
                ::builtin::ensures([(old(self).view()).flush_predicted(),
                            self.inv(),
                            ::builtin::spec_eq(self.constants(), old(self).constants()),
                            ::builtin::spec_eq(self.id(), old(self).id()),
                            ::builtin::spec_eq((self.view()), (old(self).view()))]);
                self.pm_region.flush()
            }
        }
    }
    pub mod traits_t {
        //! This file defines external and unsafe traits PmSized 
        //! and PmSafe that are used to prove that accesses to PM
        //! are safe. Aside from the hardcoded unsafe implementations
        //! in this file, these traits should *ONLY* be implemented
        //! via derive macros, which are defined in the pmcopy crate.
        //! 
        //! Both reading and writing to PM are potentially dangerous
        //! operations. It is not crash-safe to write a structure with
        //! references to external resources (e.g., references, raw pointers,
        //! file descriptors), as these resources may be lost in a crash,
        //! causing a dangling reference upon recovery. The PmSafe marker
        //! trait establishes which types are safe to write to PM and can
        //! only be derived for safe types.
        //! 
        //! To read safely from PM, we need to know the runtime size and
        //! alignment of the structure we are reading so that we can 
        //! eventually cast the read bytes to a more useful type without
        //! risking UB. The PmSized and ConstPmSized traits provide 
        //! methods to calculate the runtime size and alignment alongside
        //! the SpecPmSized trait (defined in pmem/pmcopy_t.rs) and check
        //! that the calculated size is correct, which helps us ensure 
        //! that proofs use the correct size for structures. 
        #![verus::trusted]
        use builtin_macros::*;
        use builtin::*;
        use vstd::prelude::*;
        use deps_hack::PmCopy;
        use super::pmcopy_t::SpecPmSized;
        pub unsafe trait PmSafe {}
        unsafe impl PmSafe for u8 {}
        unsafe impl PmSafe for u16 {}
        unsafe impl PmSafe for u32 {}
        unsafe impl PmSafe for u64 {}
        unsafe impl PmSafe for u128 {}
        unsafe impl PmSafe for usize {}
        unsafe impl PmSafe for i8 {}
        unsafe impl PmSafe for i16 {}
        unsafe impl PmSafe for i32 {}
        unsafe impl PmSafe for i64 {}
        unsafe impl PmSafe for i128 {}
        unsafe impl PmSafe for isize {}
        unsafe impl<T: PmSafe, const N : usize> PmSafe for [T; N] {}
        unsafe impl PmSafe for bool {}
        unsafe impl PmSafe for char {}
        unsafe impl PmSafe for f32 {}
        unsafe impl PmSafe for f64 {}
        #[verifier::external_trait_specification]
        #[verus::internal(verus_macro)]
        pub trait ExPmSafe {
            type ExternalTraitSpecificationFor: PmSafe;
        }
        #[verifier::external_trait_specification]
        #[verus::internal(verus_macro)]
        pub trait ExPmSized: SpecPmSized {
            type ExternalTraitSpecificationFor: PmSized;
            #[verus::internal(verus_macro)]
            fn size_of()
            -> usize;
            #[verus::internal(verus_macro)]
            fn align_of()
            -> usize;
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__size_of() -> usize {
                ::builtin::ensures(|out: usize|
                        [::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                            int>(out), Self::spec_size_of())]);
                ::builtin::no_method_body()
            }
            #[doc(hidden)]
            #[verus::internal(verus_macro)]
            fn VERUS_SPEC__align_of() -> usize {
                ::builtin::ensures(|out: usize|
                        [::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                            int>(out), Self::spec_align_of())]);
                ::builtin::no_method_body()
            }
        }
        #[verifier::external_trait_specification]
        #[verus::internal(verus_macro)]
        pub trait ExUnsafeSpecPmSized {
            type ExternalTraitSpecificationFor: UnsafeSpecPmSized;
        }
        #[verus::internal(verus_macro)]
        pub fn size_of<S: PmSized>() -> usize {
            ::builtin::ensures(|out: usize|
                    [::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                        nat>(out), S::spec_size_of())]);
            S::size_of()
        }
        #[verus::internal(verus_macro)]
        pub fn align_of<S: PmSized>() -> usize {
            ::builtin::ensures(|out: usize|
                    [::builtin::spec_eq(::builtin::spec_cast_integer::<_,
                                        nat>(out), S::spec_align_of())]);
            S::align_of()
        }
        pub unsafe trait PmSized: SpecPmSized {
            fn size_of()
            -> usize;
            fn align_of()
            -> usize;
        }
        pub unsafe trait ConstPmSized {
            const SIZE: usize;
            const ALIGN: usize;
        }
        pub unsafe trait UnsafeSpecPmSized {}
        unsafe impl<T: PmSafe + PmSized, const N : usize> PmSized for [T; N] {
            fn size_of() -> usize { N * T::size_of() }
            fn align_of() -> usize { T::align_of() }
        }
        unsafe impl<T: PmSafe + PmSized, const N : usize> UnsafeSpecPmSized
            for [T; N] {}
        unsafe impl<T: PmSafe + PmSized + ConstPmSized, const N : usize>
            ConstPmSized for [T; N] {
            const SIZE: usize = N * T::SIZE;
            const ALIGN: usize = T::ALIGN;
        }
    }
}
pub mod testkv_v {
    use builtin::*;
    use builtin_macros::*;
    use vstd::prelude::*;
    use crate::common::util_v::*;
    use crate::kv2::concurrentspec_t::*;
    use crate::kv2::impl_t::KvStore;
    use crate::kv2::rwkv_v::*;
    use crate::kv2::spec_t::{
        AtomicKvStore, KvError, LogicalRange, LogicalRangeGapsPolicy,
        RecoveredKvStore, SetupParameters,
    };
    #[cfg(target_os = "linux")]
    use crate::pmem::linux_pmemfile_t::*;
    use crate::pmem::pmcopy_t::*;
    use crate::pmem::pmemmock_t::*;
    use crate::pmem::pmemspec_t::*;
    use crate::pmem::pmemutil_v::*;
    use crate::pmem::traits_t::*;
    use crate::pmem::power_t::*;
    use deps_hack::PmCopy;
    use deps_hack::rand::Rng;
    use std::hash::Hash;
    use vstd::pcm::*;
    use vstd::pervasive::runtime_assert;
    use vstd::pcm::frac::*;
    #[verifier::external_body]
    #[verus::internal(verus_macro)]
    #[verus::internal(exec)]
    pub fn generate_fresh_id() -> u128 {
        deps_hack::rand::thread_rng().gen::<u128>()
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    union TestUnion {
        a: u8,
        b: u64,
        c: u128,
    }
    unsafe impl pmcopy for TestUnion where u8: pmcopy, u64: pmcopy,
        u128: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestUnion {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let size_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u8>::spec_size_of(),
                                <u64>::spec_size_of(), <u128>::spec_size_of()]);
            let largest_size = nat_seq_max(size_seq);
            let largest_size =
                (largest_size).spec_add(spec_padding_needed(largest_size,
                        <TestUnion>::spec_align_of()));
            largest_size
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u8>::spec_align_of(),
                                <u64>::spec_align_of(), <u128>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestUnion {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestUnion {
        const SIZE: usize =
            {
                let mut largest_size: usize = 0;
                if largest_size <= <u8>::SIZE { largest_size = <u8>::SIZE; }
                if largest_size <= <u64>::SIZE { largest_size = <u64>::SIZE; }
                if largest_size <= <u128>::SIZE {
                        largest_size = <u128>::SIZE;
                    }
                let largest_size: usize =
                    largest_size +
                        padding_needed(largest_size, <TestUnion>::ALIGN);
                largest_size
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u8>::ALIGN {
                        largest_alignment = <u8>::ALIGN;
                    }
                if largest_alignment <= <u64>::ALIGN {
                        largest_alignment = <u64>::ALIGN;
                    }
                if largest_alignment <= <u128>::ALIGN {
                        largest_alignment = <u128>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTUNION: usize =
        (core::mem::size_of::<TestUnion>() == <TestUnion>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTUNION: usize =
        (core::mem::align_of::<TestUnion>() == <TestUnion>::ALIGN) as usize -
            1;
    unsafe impl UnsafeSpecPmSized for TestUnion {}
    impl Clone for TestUnion {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestUnion {
        fn eq(&self, other: &Self) -> bool {
            unsafe {
                match (self, other) {
                    (TestUnion { a: val0 }, TestUnion { a: val1 }) =>
                        val0 == val1,
                    (TestUnion { b: val0 }, TestUnion { b: val1 }) =>
                        val0 == val1,
                    (TestUnion { c: val0 }, TestUnion { c: val1 }) =>
                        val0 == val1,
                    (_, _) => false,
                }
            }
        }
    }
    impl Eq for TestUnion {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testunion_clone(b: &TestUnion) -> TestUnion {
        ::builtin::ensures(|res: TestUnion| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testunion_eq(lhs: &TestUnion, rhs: &TestUnion) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestUnion {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestUnion {
            ::builtin::ensures(|res: TestUnion|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestUnion {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestUnion {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestUnion { }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum1 { V1, }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum1 {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for TestEnum1 {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum1 {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum1 {}
    unsafe impl pmcopy for TestEnum1 {}
    impl PmCopy for TestEnum1 {}
    impl Clone for TestEnum1 {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum1 {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum1::V1, TestEnum1::V1) => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum1 {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum1_clone(b: &TestEnum1) -> TestEnum1 {
        ::builtin::ensures(|res: TestEnum1| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum1_eq(lhs: &TestEnum1, rhs: &TestEnum1) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum1 {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum1 {
            ::builtin::ensures(|res: TestEnum1|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum1 {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_TESTENUM1: usize =
        (core::mem::size_of::<TestEnum1>() == <TestEnum1>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM1: usize =
        (core::mem::align_of::<TestEnum1>() == <TestEnum1>::ALIGN) as usize -
            1;
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum1 { }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum2 { V1, V2, V3, V4, }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum2 {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for TestEnum2 {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum2 {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum2 {}
    unsafe impl pmcopy for TestEnum2 {}
    impl PmCopy for TestEnum2 {}
    impl Clone for TestEnum2 {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum2 {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum2::V1, TestEnum2::V1) => true,
                (TestEnum2::V2, TestEnum2::V2) => true,
                (TestEnum2::V3, TestEnum2::V3) => true,
                (TestEnum2::V4, TestEnum2::V4) => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum2 {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum2_clone(b: &TestEnum2) -> TestEnum2 {
        ::builtin::ensures(|res: TestEnum2| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum2_eq(lhs: &TestEnum2, rhs: &TestEnum2) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum2 {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum2 {
            ::builtin::ensures(|res: TestEnum2|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum2 {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_TESTENUM2: usize =
        (core::mem::size_of::<TestEnum2>() == <TestEnum2>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM2: usize =
        (core::mem::align_of::<TestEnum2>() == <TestEnum2>::ALIGN) as usize -
            1;
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum2 { }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum3 { V1(u16), }
    unsafe impl pmcopy for TestEnum3 where u16: pmcopy {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum3V1Fields(u16);
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum3V1Fields { }
    unsafe impl pmcopy for TestEnum3V1Fields where u16: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum3V1Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u16>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u16>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum3V1Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u16>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum3V1Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum3V1Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u16>::SIZE + padding_needed(offset, <u16>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum3V1Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u16>::ALIGN {
                        largest_alignment = <u16>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM3V1FIELDS: usize =
        (core::mem::size_of::<TestEnum3V1Fields>() ==
                        <TestEnum3V1Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM3V1FIELDS: usize =
        (core::mem::align_of::<TestEnum3V1Fields>() ==
                        <TestEnum3V1Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum3V1Fields {}
    impl Clone for TestEnum3V1Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum3V1Fields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for TestEnum3V1Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3v1fields_clone(b: &TestEnum3V1Fields)
        -> TestEnum3V1Fields {
        ::builtin::ensures(|res: TestEnum3V1Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3v1fields_eq(lhs: &TestEnum3V1Fields,
        rhs: &TestEnum3V1Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum3V1Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum3V1Fields {
            ::builtin::ensures(|res: TestEnum3V1Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum3V1Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum3V1Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    union TestEnum3FieldUnion {
        v1: TestEnum3V1Fields,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum3FieldUnion { }
    unsafe impl pmcopy for TestEnum3FieldUnion where TestEnum3V1Fields: pmcopy
        {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum3FieldUnion {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let size_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum3V1Fields>::spec_size_of()]);
            let largest_size = nat_seq_max(size_seq);
            let largest_size =
                (largest_size).spec_add(spec_padding_needed(largest_size,
                        <TestEnum3FieldUnion>::spec_align_of()));
            largest_size
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum3V1Fields>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum3FieldUnion {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum3FieldUnion {
        const SIZE: usize =
            {
                let mut largest_size: usize = 0;
                if largest_size <= <TestEnum3V1Fields>::SIZE {
                        largest_size = <TestEnum3V1Fields>::SIZE;
                    }
                let largest_size: usize =
                    largest_size +
                        padding_needed(largest_size, <TestEnum3FieldUnion>::ALIGN);
                largest_size
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum3V1Fields>::ALIGN {
                        largest_alignment = <TestEnum3V1Fields>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM3FIELDUNION: usize =
        (core::mem::size_of::<TestEnum3FieldUnion>() ==
                        <TestEnum3FieldUnion>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM3FIELDUNION: usize =
        (core::mem::align_of::<TestEnum3FieldUnion>() ==
                        <TestEnum3FieldUnion>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum3FieldUnion {}
    impl Clone for TestEnum3FieldUnion {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum3FieldUnion {
        fn eq(&self, other: &Self) -> bool {
            unsafe {
                match (self, other) {
                    (TestEnum3FieldUnion { v1: val0 }, TestEnum3FieldUnion {
                        v1: val1 }) => val0 == val1,
                    (_, _) => false,
                }
            }
        }
    }
    impl Eq for TestEnum3FieldUnion {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3fieldunion_clone(b: &TestEnum3FieldUnion)
        -> TestEnum3FieldUnion {
        ::builtin::ensures(|res: TestEnum3FieldUnion|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3fieldunion_eq(lhs: &TestEnum3FieldUnion,
        rhs: &TestEnum3FieldUnion) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum3FieldUnion {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum3FieldUnion {
            ::builtin::ensures(|res: TestEnum3FieldUnion|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum3FieldUnion {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum3FieldUnion {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum3EnumDiscriminant { V1, }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum3EnumDiscriminant { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum3EnumDiscriminant {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for TestEnum3EnumDiscriminant {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum3EnumDiscriminant {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum3EnumDiscriminant {}
    unsafe impl pmcopy for TestEnum3EnumDiscriminant {}
    impl PmCopy for TestEnum3EnumDiscriminant {}
    impl Clone for TestEnum3EnumDiscriminant {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum3EnumDiscriminant {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum3EnumDiscriminant::V1, TestEnum3EnumDiscriminant::V1)
                    => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum3EnumDiscriminant {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3enumdiscriminant_clone(b: &TestEnum3EnumDiscriminant)
        -> TestEnum3EnumDiscriminant {
        ::builtin::ensures(|res: TestEnum3EnumDiscriminant|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3enumdiscriminant_eq(lhs: &TestEnum3EnumDiscriminant,
        rhs: &TestEnum3EnumDiscriminant) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum3EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum3EnumDiscriminant {
            ::builtin::ensures(|res: TestEnum3EnumDiscriminant|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum3EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_TESTENUM3ENUMDISCRIMINANT: usize =
        (core::mem::size_of::<TestEnum3EnumDiscriminant>() ==
                        <TestEnum3EnumDiscriminant>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM3ENUMDISCRIMINANT: usize =
        (core::mem::align_of::<TestEnum3EnumDiscriminant>() ==
                        <TestEnum3EnumDiscriminant>::ALIGN) as usize - 1;
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum3LayoutStruct {
        tag: TestEnum3EnumDiscriminant,
        payload: TestEnum3FieldUnion,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum3LayoutStruct { }
    unsafe impl pmcopy for TestEnum3LayoutStruct where
        TestEnum3EnumDiscriminant: pmcopy, TestEnum3FieldUnion: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum3LayoutStruct {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum3EnumDiscriminant>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum3EnumDiscriminant>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum3FieldUnion>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum3FieldUnion>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum3LayoutStruct>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum3EnumDiscriminant>::spec_align_of(),
                                <TestEnum3FieldUnion>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum3LayoutStruct {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum3LayoutStruct {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <TestEnum3EnumDiscriminant>::SIZE +
                        padding_needed(offset, <TestEnum3EnumDiscriminant>::ALIGN);
                let offset: usize =
                    offset + <TestEnum3FieldUnion>::SIZE +
                        padding_needed(offset, <TestEnum3FieldUnion>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset, <TestEnum3LayoutStruct>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum3EnumDiscriminant>::ALIGN {
                        largest_alignment = <TestEnum3EnumDiscriminant>::ALIGN;
                    }
                if largest_alignment <= <TestEnum3FieldUnion>::ALIGN {
                        largest_alignment = <TestEnum3FieldUnion>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM3LAYOUTSTRUCT: usize =
        (core::mem::size_of::<TestEnum3LayoutStruct>() ==
                        <TestEnum3LayoutStruct>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM3LAYOUTSTRUCT: usize =
        (core::mem::align_of::<TestEnum3LayoutStruct>() ==
                        <TestEnum3LayoutStruct>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum3LayoutStruct {}
    impl Clone for TestEnum3LayoutStruct {
        fn clone(&self) -> Self {
            Self { tag: self.tag.clone(), payload: self.payload.clone() }
        }
    }
    impl PartialEq for TestEnum3LayoutStruct {
        fn eq(&self, other: &Self) -> bool {
            self.tag == other.tag && self.payload == other.payload
        }
    }
    impl Eq for TestEnum3LayoutStruct {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3layoutstruct_clone(b: &TestEnum3LayoutStruct)
        -> TestEnum3LayoutStruct {
        ::builtin::ensures(|res: TestEnum3LayoutStruct|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3layoutstruct_eq(lhs: &TestEnum3LayoutStruct,
        rhs: &TestEnum3LayoutStruct) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum3LayoutStruct {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum3LayoutStruct {
            ::builtin::ensures(|res: TestEnum3LayoutStruct|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum3LayoutStruct {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum3LayoutStruct {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum3 {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            TestEnum3LayoutStruct::spec_size_of()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            TestEnum3LayoutStruct::spec_align_of()
        }
    }
    unsafe impl PmSized for TestEnum3 {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum3 {
        const SIZE: usize = TestEnum3LayoutStruct::SIZE;
        const ALIGN: usize = TestEnum3LayoutStruct::ALIGN;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum3 {}
    const SIZE_CHECK_TESTENUM3: usize =
        (core::mem::size_of::<TestEnum3>() == <TestEnum3>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM3: usize =
        (core::mem::align_of::<TestEnum3>() == <TestEnum3>::ALIGN) as usize -
            1;
    impl Clone for TestEnum3 {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum3 {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum3::V1(lhs_f0), TestEnum3::V1(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum3 {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3_clone(b: &TestEnum3) -> TestEnum3 {
        ::builtin::ensures(|res: TestEnum3| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum3_eq(lhs: &TestEnum3, rhs: &TestEnum3) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum3 {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum3 {
            ::builtin::ensures(|res: TestEnum3|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum3 {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum3 {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum3 { }
    #[verus::internal(verus_macro)]
    impl TestEnum3 {
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_0(self) -> u16 {
            ::builtin::get_variant_field(self, "V1", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_0(self) -> u16 {
            ::builtin::get_variant_field(self, "V1", "0")
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum4 { V1(u16), V2(u8), V3(u64), }
    unsafe impl pmcopy for TestEnum4 where u16: pmcopy, u8: pmcopy,
        u64: pmcopy {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum4V1Fields(u16);
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum4V1Fields { }
    unsafe impl pmcopy for TestEnum4V1Fields where u16: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum4V1Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u16>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u16>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum4V1Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u16>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum4V1Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum4V1Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u16>::SIZE + padding_needed(offset, <u16>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum4V1Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u16>::ALIGN {
                        largest_alignment = <u16>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM4V1FIELDS: usize =
        (core::mem::size_of::<TestEnum4V1Fields>() ==
                        <TestEnum4V1Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM4V1FIELDS: usize =
        (core::mem::align_of::<TestEnum4V1Fields>() ==
                        <TestEnum4V1Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum4V1Fields {}
    impl Clone for TestEnum4V1Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum4V1Fields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for TestEnum4V1Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4v1fields_clone(b: &TestEnum4V1Fields)
        -> TestEnum4V1Fields {
        ::builtin::ensures(|res: TestEnum4V1Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4v1fields_eq(lhs: &TestEnum4V1Fields,
        rhs: &TestEnum4V1Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum4V1Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum4V1Fields {
            ::builtin::ensures(|res: TestEnum4V1Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum4V1Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum4V1Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum4V2Fields(u8);
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum4V2Fields { }
    unsafe impl pmcopy for TestEnum4V2Fields where u8: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum4V2Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u8>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u8>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum4V2Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u8>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum4V2Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum4V2Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u8>::SIZE + padding_needed(offset, <u8>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum4V2Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u8>::ALIGN {
                        largest_alignment = <u8>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM4V2FIELDS: usize =
        (core::mem::size_of::<TestEnum4V2Fields>() ==
                        <TestEnum4V2Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM4V2FIELDS: usize =
        (core::mem::align_of::<TestEnum4V2Fields>() ==
                        <TestEnum4V2Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum4V2Fields {}
    impl Clone for TestEnum4V2Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum4V2Fields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for TestEnum4V2Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4v2fields_clone(b: &TestEnum4V2Fields)
        -> TestEnum4V2Fields {
        ::builtin::ensures(|res: TestEnum4V2Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4v2fields_eq(lhs: &TestEnum4V2Fields,
        rhs: &TestEnum4V2Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum4V2Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum4V2Fields {
            ::builtin::ensures(|res: TestEnum4V2Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum4V2Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum4V2Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum4V3Fields(u64);
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum4V3Fields { }
    unsafe impl pmcopy for TestEnum4V3Fields where u64: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum4V3Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u64>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum4V3Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum4V3Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum4V3Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum4V3Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u64>::ALIGN {
                        largest_alignment = <u64>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM4V3FIELDS: usize =
        (core::mem::size_of::<TestEnum4V3Fields>() ==
                        <TestEnum4V3Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM4V3FIELDS: usize =
        (core::mem::align_of::<TestEnum4V3Fields>() ==
                        <TestEnum4V3Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum4V3Fields {}
    impl Clone for TestEnum4V3Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum4V3Fields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for TestEnum4V3Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4v3fields_clone(b: &TestEnum4V3Fields)
        -> TestEnum4V3Fields {
        ::builtin::ensures(|res: TestEnum4V3Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4v3fields_eq(lhs: &TestEnum4V3Fields,
        rhs: &TestEnum4V3Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum4V3Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum4V3Fields {
            ::builtin::ensures(|res: TestEnum4V3Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum4V3Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum4V3Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    union TestEnum4FieldUnion {
        v1: TestEnum4V1Fields,
        v2: TestEnum4V2Fields,
        v3: TestEnum4V3Fields,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum4FieldUnion { }
    unsafe impl pmcopy for TestEnum4FieldUnion where
        TestEnum4V1Fields: pmcopy, TestEnum4V2Fields: pmcopy,
        TestEnum4V3Fields: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum4FieldUnion {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let size_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum4V1Fields>::spec_size_of(),
                                <TestEnum4V2Fields>::spec_size_of(),
                                <TestEnum4V3Fields>::spec_size_of()]);
            let largest_size = nat_seq_max(size_seq);
            let largest_size =
                (largest_size).spec_add(spec_padding_needed(largest_size,
                        <TestEnum4FieldUnion>::spec_align_of()));
            largest_size
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum4V1Fields>::spec_align_of(),
                                <TestEnum4V2Fields>::spec_align_of(),
                                <TestEnum4V3Fields>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum4FieldUnion {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum4FieldUnion {
        const SIZE: usize =
            {
                let mut largest_size: usize = 0;
                if largest_size <= <TestEnum4V1Fields>::SIZE {
                        largest_size = <TestEnum4V1Fields>::SIZE;
                    }
                if largest_size <= <TestEnum4V2Fields>::SIZE {
                        largest_size = <TestEnum4V2Fields>::SIZE;
                    }
                if largest_size <= <TestEnum4V3Fields>::SIZE {
                        largest_size = <TestEnum4V3Fields>::SIZE;
                    }
                let largest_size: usize =
                    largest_size +
                        padding_needed(largest_size, <TestEnum4FieldUnion>::ALIGN);
                largest_size
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum4V1Fields>::ALIGN {
                        largest_alignment = <TestEnum4V1Fields>::ALIGN;
                    }
                if largest_alignment <= <TestEnum4V2Fields>::ALIGN {
                        largest_alignment = <TestEnum4V2Fields>::ALIGN;
                    }
                if largest_alignment <= <TestEnum4V3Fields>::ALIGN {
                        largest_alignment = <TestEnum4V3Fields>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM4FIELDUNION: usize =
        (core::mem::size_of::<TestEnum4FieldUnion>() ==
                        <TestEnum4FieldUnion>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM4FIELDUNION: usize =
        (core::mem::align_of::<TestEnum4FieldUnion>() ==
                        <TestEnum4FieldUnion>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum4FieldUnion {}
    impl Clone for TestEnum4FieldUnion {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum4FieldUnion {
        fn eq(&self, other: &Self) -> bool {
            unsafe {
                match (self, other) {
                    (TestEnum4FieldUnion { v1: val0 }, TestEnum4FieldUnion {
                        v1: val1 }) => val0 == val1,
                    (TestEnum4FieldUnion { v2: val0 }, TestEnum4FieldUnion {
                        v2: val1 }) => val0 == val1,
                    (TestEnum4FieldUnion { v3: val0 }, TestEnum4FieldUnion {
                        v3: val1 }) => val0 == val1,
                    (_, _) => false,
                }
            }
        }
    }
    impl Eq for TestEnum4FieldUnion {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4fieldunion_clone(b: &TestEnum4FieldUnion)
        -> TestEnum4FieldUnion {
        ::builtin::ensures(|res: TestEnum4FieldUnion|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4fieldunion_eq(lhs: &TestEnum4FieldUnion,
        rhs: &TestEnum4FieldUnion) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum4FieldUnion {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum4FieldUnion {
            ::builtin::ensures(|res: TestEnum4FieldUnion|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum4FieldUnion {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum4FieldUnion {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum4EnumDiscriminant { V1, V2, V3, }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum4EnumDiscriminant { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum4EnumDiscriminant {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for TestEnum4EnumDiscriminant {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum4EnumDiscriminant {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum4EnumDiscriminant {}
    unsafe impl pmcopy for TestEnum4EnumDiscriminant {}
    impl PmCopy for TestEnum4EnumDiscriminant {}
    impl Clone for TestEnum4EnumDiscriminant {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum4EnumDiscriminant {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum4EnumDiscriminant::V1, TestEnum4EnumDiscriminant::V1)
                    => true,
                (TestEnum4EnumDiscriminant::V2, TestEnum4EnumDiscriminant::V2)
                    => true,
                (TestEnum4EnumDiscriminant::V3, TestEnum4EnumDiscriminant::V3)
                    => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum4EnumDiscriminant {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4enumdiscriminant_clone(b: &TestEnum4EnumDiscriminant)
        -> TestEnum4EnumDiscriminant {
        ::builtin::ensures(|res: TestEnum4EnumDiscriminant|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4enumdiscriminant_eq(lhs: &TestEnum4EnumDiscriminant,
        rhs: &TestEnum4EnumDiscriminant) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum4EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum4EnumDiscriminant {
            ::builtin::ensures(|res: TestEnum4EnumDiscriminant|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum4EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_TESTENUM4ENUMDISCRIMINANT: usize =
        (core::mem::size_of::<TestEnum4EnumDiscriminant>() ==
                        <TestEnum4EnumDiscriminant>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM4ENUMDISCRIMINANT: usize =
        (core::mem::align_of::<TestEnum4EnumDiscriminant>() ==
                        <TestEnum4EnumDiscriminant>::ALIGN) as usize - 1;
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum4LayoutStruct {
        tag: TestEnum4EnumDiscriminant,
        payload: TestEnum4FieldUnion,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum4LayoutStruct { }
    unsafe impl pmcopy for TestEnum4LayoutStruct where
        TestEnum4EnumDiscriminant: pmcopy, TestEnum4FieldUnion: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum4LayoutStruct {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum4EnumDiscriminant>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum4EnumDiscriminant>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum4FieldUnion>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum4FieldUnion>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum4LayoutStruct>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum4EnumDiscriminant>::spec_align_of(),
                                <TestEnum4FieldUnion>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum4LayoutStruct {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum4LayoutStruct {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <TestEnum4EnumDiscriminant>::SIZE +
                        padding_needed(offset, <TestEnum4EnumDiscriminant>::ALIGN);
                let offset: usize =
                    offset + <TestEnum4FieldUnion>::SIZE +
                        padding_needed(offset, <TestEnum4FieldUnion>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset, <TestEnum4LayoutStruct>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum4EnumDiscriminant>::ALIGN {
                        largest_alignment = <TestEnum4EnumDiscriminant>::ALIGN;
                    }
                if largest_alignment <= <TestEnum4FieldUnion>::ALIGN {
                        largest_alignment = <TestEnum4FieldUnion>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM4LAYOUTSTRUCT: usize =
        (core::mem::size_of::<TestEnum4LayoutStruct>() ==
                        <TestEnum4LayoutStruct>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM4LAYOUTSTRUCT: usize =
        (core::mem::align_of::<TestEnum4LayoutStruct>() ==
                        <TestEnum4LayoutStruct>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum4LayoutStruct {}
    impl Clone for TestEnum4LayoutStruct {
        fn clone(&self) -> Self {
            Self { tag: self.tag.clone(), payload: self.payload.clone() }
        }
    }
    impl PartialEq for TestEnum4LayoutStruct {
        fn eq(&self, other: &Self) -> bool {
            self.tag == other.tag && self.payload == other.payload
        }
    }
    impl Eq for TestEnum4LayoutStruct {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4layoutstruct_clone(b: &TestEnum4LayoutStruct)
        -> TestEnum4LayoutStruct {
        ::builtin::ensures(|res: TestEnum4LayoutStruct|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4layoutstruct_eq(lhs: &TestEnum4LayoutStruct,
        rhs: &TestEnum4LayoutStruct) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum4LayoutStruct {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum4LayoutStruct {
            ::builtin::ensures(|res: TestEnum4LayoutStruct|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum4LayoutStruct {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum4LayoutStruct {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum4 {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            TestEnum4LayoutStruct::spec_size_of()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            TestEnum4LayoutStruct::spec_align_of()
        }
    }
    unsafe impl PmSized for TestEnum4 {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum4 {
        const SIZE: usize = TestEnum4LayoutStruct::SIZE;
        const ALIGN: usize = TestEnum4LayoutStruct::ALIGN;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum4 {}
    const SIZE_CHECK_TESTENUM4: usize =
        (core::mem::size_of::<TestEnum4>() == <TestEnum4>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM4: usize =
        (core::mem::align_of::<TestEnum4>() == <TestEnum4>::ALIGN) as usize -
            1;
    impl Clone for TestEnum4 {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum4 {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum4::V1(lhs_f0), TestEnum4::V1(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (TestEnum4::V2(lhs_f0), TestEnum4::V2(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (TestEnum4::V3(lhs_f0), TestEnum4::V3(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum4 {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4_clone(b: &TestEnum4) -> TestEnum4 {
        ::builtin::ensures(|res: TestEnum4| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum4_eq(lhs: &TestEnum4, rhs: &TestEnum4) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum4 {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum4 {
            ::builtin::ensures(|res: TestEnum4|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum4 {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum4 {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum4 { }
    #[verus::internal(verus_macro)]
    impl TestEnum4 {
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_0(self) -> u64 {
            ::builtin::get_variant_field(self, "V3", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_0(self) -> u16 {
            ::builtin::get_variant_field(self, "V1", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V2_0(self) -> u8 {
            ::builtin::get_variant_field(self, "V2", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V3_0(self) -> u64 {
            ::builtin::get_variant_field(self, "V3", "0")
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum5 { V1, V2(u128), V3(u32), }
    unsafe impl pmcopy for TestEnum5 where u128: pmcopy, u32: pmcopy {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum5V1Fields {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum5V1Fields { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum5V1Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(0usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
        }
    }
    unsafe impl pmcopy for TestEnum5V1Fields {}
    unsafe impl PmSized for TestEnum5V1Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum5V1Fields {
        const SIZE: usize = 0usize;
        const ALIGN: usize = 1usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum5V1Fields {}
    const SIZE_CHECK_TESTENUM5V1FIELDS: usize =
        (core::mem::size_of::<TestEnum5V1Fields>() ==
                        <TestEnum5V1Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM5V1FIELDS: usize =
        (core::mem::align_of::<TestEnum5V1Fields>() ==
                        <TestEnum5V1Fields>::ALIGN) as usize - 1;
    impl Clone for TestEnum5V1Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum5V1Fields {
        fn eq(&self, other: &Self) -> bool { true }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum5V2Fields(u128);
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum5V2Fields { }
    unsafe impl pmcopy for TestEnum5V2Fields where u128: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum5V2Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u128>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum5V2Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u128>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum5V2Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum5V2Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u128>::SIZE +
                        padding_needed(offset, <u128>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum5V2Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u128>::ALIGN {
                        largest_alignment = <u128>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM5V2FIELDS: usize =
        (core::mem::size_of::<TestEnum5V2Fields>() ==
                        <TestEnum5V2Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM5V2FIELDS: usize =
        (core::mem::align_of::<TestEnum5V2Fields>() ==
                        <TestEnum5V2Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum5V2Fields {}
    impl Clone for TestEnum5V2Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum5V2Fields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for TestEnum5V2Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5v2fields_clone(b: &TestEnum5V2Fields)
        -> TestEnum5V2Fields {
        ::builtin::ensures(|res: TestEnum5V2Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5v2fields_eq(lhs: &TestEnum5V2Fields,
        rhs: &TestEnum5V2Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum5V2Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum5V2Fields {
            ::builtin::ensures(|res: TestEnum5V2Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum5V2Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum5V2Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum5V3Fields(u32);
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum5V3Fields { }
    unsafe impl pmcopy for TestEnum5V3Fields where u32: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum5V3Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u32>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u32>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum5V3Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u32>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum5V3Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum5V3Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u32>::SIZE + padding_needed(offset, <u32>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum5V3Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u32>::ALIGN {
                        largest_alignment = <u32>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM5V3FIELDS: usize =
        (core::mem::size_of::<TestEnum5V3Fields>() ==
                        <TestEnum5V3Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM5V3FIELDS: usize =
        (core::mem::align_of::<TestEnum5V3Fields>() ==
                        <TestEnum5V3Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum5V3Fields {}
    impl Clone for TestEnum5V3Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum5V3Fields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for TestEnum5V3Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5v3fields_clone(b: &TestEnum5V3Fields)
        -> TestEnum5V3Fields {
        ::builtin::ensures(|res: TestEnum5V3Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5v3fields_eq(lhs: &TestEnum5V3Fields,
        rhs: &TestEnum5V3Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum5V3Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum5V3Fields {
            ::builtin::ensures(|res: TestEnum5V3Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum5V3Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum5V3Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    union TestEnum5FieldUnion {
        v1: TestEnum5V1Fields,
        v2: TestEnum5V2Fields,
        v3: TestEnum5V3Fields,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum5FieldUnion { }
    unsafe impl pmcopy for TestEnum5FieldUnion where
        TestEnum5V1Fields: pmcopy, TestEnum5V2Fields: pmcopy,
        TestEnum5V3Fields: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum5FieldUnion {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let size_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum5V1Fields>::spec_size_of(),
                                <TestEnum5V2Fields>::spec_size_of(),
                                <TestEnum5V3Fields>::spec_size_of()]);
            let largest_size = nat_seq_max(size_seq);
            let largest_size =
                (largest_size).spec_add(spec_padding_needed(largest_size,
                        <TestEnum5FieldUnion>::spec_align_of()));
            largest_size
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum5V1Fields>::spec_align_of(),
                                <TestEnum5V2Fields>::spec_align_of(),
                                <TestEnum5V3Fields>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum5FieldUnion {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum5FieldUnion {
        const SIZE: usize =
            {
                let mut largest_size: usize = 0;
                if largest_size <= <TestEnum5V1Fields>::SIZE {
                        largest_size = <TestEnum5V1Fields>::SIZE;
                    }
                if largest_size <= <TestEnum5V2Fields>::SIZE {
                        largest_size = <TestEnum5V2Fields>::SIZE;
                    }
                if largest_size <= <TestEnum5V3Fields>::SIZE {
                        largest_size = <TestEnum5V3Fields>::SIZE;
                    }
                let largest_size: usize =
                    largest_size +
                        padding_needed(largest_size, <TestEnum5FieldUnion>::ALIGN);
                largest_size
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum5V1Fields>::ALIGN {
                        largest_alignment = <TestEnum5V1Fields>::ALIGN;
                    }
                if largest_alignment <= <TestEnum5V2Fields>::ALIGN {
                        largest_alignment = <TestEnum5V2Fields>::ALIGN;
                    }
                if largest_alignment <= <TestEnum5V3Fields>::ALIGN {
                        largest_alignment = <TestEnum5V3Fields>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM5FIELDUNION: usize =
        (core::mem::size_of::<TestEnum5FieldUnion>() ==
                        <TestEnum5FieldUnion>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM5FIELDUNION: usize =
        (core::mem::align_of::<TestEnum5FieldUnion>() ==
                        <TestEnum5FieldUnion>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum5FieldUnion {}
    impl Clone for TestEnum5FieldUnion {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum5FieldUnion {
        fn eq(&self, other: &Self) -> bool {
            unsafe {
                match (self, other) {
                    (TestEnum5FieldUnion { v1: val0 }, TestEnum5FieldUnion {
                        v1: val1 }) => val0 == val1,
                    (TestEnum5FieldUnion { v2: val0 }, TestEnum5FieldUnion {
                        v2: val1 }) => val0 == val1,
                    (TestEnum5FieldUnion { v3: val0 }, TestEnum5FieldUnion {
                        v3: val1 }) => val0 == val1,
                    (_, _) => false,
                }
            }
        }
    }
    impl Eq for TestEnum5FieldUnion {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5fieldunion_clone(b: &TestEnum5FieldUnion)
        -> TestEnum5FieldUnion {
        ::builtin::ensures(|res: TestEnum5FieldUnion|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5fieldunion_eq(lhs: &TestEnum5FieldUnion,
        rhs: &TestEnum5FieldUnion) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum5FieldUnion {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum5FieldUnion {
            ::builtin::ensures(|res: TestEnum5FieldUnion|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum5FieldUnion {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum5FieldUnion {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum5EnumDiscriminant { V1, V2, V3, }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum5EnumDiscriminant { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum5EnumDiscriminant {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for TestEnum5EnumDiscriminant {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum5EnumDiscriminant {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum5EnumDiscriminant {}
    unsafe impl pmcopy for TestEnum5EnumDiscriminant {}
    impl PmCopy for TestEnum5EnumDiscriminant {}
    impl Clone for TestEnum5EnumDiscriminant {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum5EnumDiscriminant {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum5EnumDiscriminant::V1, TestEnum5EnumDiscriminant::V1)
                    => true,
                (TestEnum5EnumDiscriminant::V2, TestEnum5EnumDiscriminant::V2)
                    => true,
                (TestEnum5EnumDiscriminant::V3, TestEnum5EnumDiscriminant::V3)
                    => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum5EnumDiscriminant {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5enumdiscriminant_clone(b: &TestEnum5EnumDiscriminant)
        -> TestEnum5EnumDiscriminant {
        ::builtin::ensures(|res: TestEnum5EnumDiscriminant|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5enumdiscriminant_eq(lhs: &TestEnum5EnumDiscriminant,
        rhs: &TestEnum5EnumDiscriminant) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum5EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum5EnumDiscriminant {
            ::builtin::ensures(|res: TestEnum5EnumDiscriminant|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum5EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_TESTENUM5ENUMDISCRIMINANT: usize =
        (core::mem::size_of::<TestEnum5EnumDiscriminant>() ==
                        <TestEnum5EnumDiscriminant>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM5ENUMDISCRIMINANT: usize =
        (core::mem::align_of::<TestEnum5EnumDiscriminant>() ==
                        <TestEnum5EnumDiscriminant>::ALIGN) as usize - 1;
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum5LayoutStruct {
        tag: TestEnum5EnumDiscriminant,
        payload: TestEnum5FieldUnion,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum5LayoutStruct { }
    unsafe impl pmcopy for TestEnum5LayoutStruct where
        TestEnum5EnumDiscriminant: pmcopy, TestEnum5FieldUnion: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum5LayoutStruct {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum5EnumDiscriminant>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum5EnumDiscriminant>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum5FieldUnion>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum5FieldUnion>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum5LayoutStruct>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum5EnumDiscriminant>::spec_align_of(),
                                <TestEnum5FieldUnion>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum5LayoutStruct {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum5LayoutStruct {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <TestEnum5EnumDiscriminant>::SIZE +
                        padding_needed(offset, <TestEnum5EnumDiscriminant>::ALIGN);
                let offset: usize =
                    offset + <TestEnum5FieldUnion>::SIZE +
                        padding_needed(offset, <TestEnum5FieldUnion>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset, <TestEnum5LayoutStruct>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum5EnumDiscriminant>::ALIGN {
                        largest_alignment = <TestEnum5EnumDiscriminant>::ALIGN;
                    }
                if largest_alignment <= <TestEnum5FieldUnion>::ALIGN {
                        largest_alignment = <TestEnum5FieldUnion>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM5LAYOUTSTRUCT: usize =
        (core::mem::size_of::<TestEnum5LayoutStruct>() ==
                        <TestEnum5LayoutStruct>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM5LAYOUTSTRUCT: usize =
        (core::mem::align_of::<TestEnum5LayoutStruct>() ==
                        <TestEnum5LayoutStruct>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum5LayoutStruct {}
    impl Clone for TestEnum5LayoutStruct {
        fn clone(&self) -> Self {
            Self { tag: self.tag.clone(), payload: self.payload.clone() }
        }
    }
    impl PartialEq for TestEnum5LayoutStruct {
        fn eq(&self, other: &Self) -> bool {
            self.tag == other.tag && self.payload == other.payload
        }
    }
    impl Eq for TestEnum5LayoutStruct {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5layoutstruct_clone(b: &TestEnum5LayoutStruct)
        -> TestEnum5LayoutStruct {
        ::builtin::ensures(|res: TestEnum5LayoutStruct|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5layoutstruct_eq(lhs: &TestEnum5LayoutStruct,
        rhs: &TestEnum5LayoutStruct) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum5LayoutStruct {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum5LayoutStruct {
            ::builtin::ensures(|res: TestEnum5LayoutStruct|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum5LayoutStruct {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum5LayoutStruct {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum5 {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            TestEnum5LayoutStruct::spec_size_of()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            TestEnum5LayoutStruct::spec_align_of()
        }
    }
    unsafe impl PmSized for TestEnum5 {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum5 {
        const SIZE: usize = TestEnum5LayoutStruct::SIZE;
        const ALIGN: usize = TestEnum5LayoutStruct::ALIGN;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum5 {}
    const SIZE_CHECK_TESTENUM5: usize =
        (core::mem::size_of::<TestEnum5>() == <TestEnum5>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM5: usize =
        (core::mem::align_of::<TestEnum5>() == <TestEnum5>::ALIGN) as usize -
            1;
    impl Clone for TestEnum5 {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum5 {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum5::V1, TestEnum5::V1) => true,
                (TestEnum5::V2(lhs_f0), TestEnum5::V2(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (TestEnum5::V3(lhs_f0), TestEnum5::V3(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum5 {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5_clone(b: &TestEnum5) -> TestEnum5 {
        ::builtin::ensures(|res: TestEnum5| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum5_eq(lhs: &TestEnum5, rhs: &TestEnum5) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum5 {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum5 {
            ::builtin::ensures(|res: TestEnum5|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum5 {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum5 {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum5 { }
    #[verus::internal(verus_macro)]
    impl TestEnum5 {
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V2_0(self) -> u128 {
            ::builtin::get_variant_field(self, "V2", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V3_0(self) -> u32 {
            ::builtin::get_variant_field(self, "V3", "0")
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum6 {
        V1 {
            f0: u64,
            f1: u8,
            f3: u128,
            f4: u16,
        },
    }
    unsafe impl pmcopy for TestEnum6 where u64: pmcopy, u8: pmcopy,
        u128: pmcopy, u16: pmcopy {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum6V1Fields {
        f0: u64,
        f1: u8,
        f3: u128,
        f4: u16,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum6V1Fields { }
    unsafe impl pmcopy for TestEnum6V1Fields where u64: pmcopy, u8: pmcopy,
        u128: pmcopy, u16: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum6V1Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u64>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u8>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u8>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u128>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u16>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u16>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum6V1Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of(),
                                <u8>::spec_align_of(), <u128>::spec_align_of(),
                                <u16>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum6V1Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum6V1Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                let offset: usize =
                    offset + <u8>::SIZE + padding_needed(offset, <u8>::ALIGN);
                let offset: usize =
                    offset + <u128>::SIZE +
                        padding_needed(offset, <u128>::ALIGN);
                let offset: usize =
                    offset + <u16>::SIZE + padding_needed(offset, <u16>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum6V1Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u64>::ALIGN {
                        largest_alignment = <u64>::ALIGN;
                    }
                if largest_alignment <= <u8>::ALIGN {
                        largest_alignment = <u8>::ALIGN;
                    }
                if largest_alignment <= <u128>::ALIGN {
                        largest_alignment = <u128>::ALIGN;
                    }
                if largest_alignment <= <u16>::ALIGN {
                        largest_alignment = <u16>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM6V1FIELDS: usize =
        (core::mem::size_of::<TestEnum6V1Fields>() ==
                        <TestEnum6V1Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM6V1FIELDS: usize =
        (core::mem::align_of::<TestEnum6V1Fields>() ==
                        <TestEnum6V1Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum6V1Fields {}
    impl Clone for TestEnum6V1Fields {
        fn clone(&self) -> Self {
            Self {
                f0: self.f0.clone(),
                f1: self.f1.clone(),
                f3: self.f3.clone(),
                f4: self.f4.clone(),
            }
        }
    }
    impl PartialEq for TestEnum6V1Fields {
        fn eq(&self, other: &Self) -> bool {
            self.f0 == other.f0 && self.f1 == other.f1 && self.f3 == other.f3
                && self.f4 == other.f4
        }
    }
    impl Eq for TestEnum6V1Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6v1fields_clone(b: &TestEnum6V1Fields)
        -> TestEnum6V1Fields {
        ::builtin::ensures(|res: TestEnum6V1Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6v1fields_eq(lhs: &TestEnum6V1Fields,
        rhs: &TestEnum6V1Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum6V1Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum6V1Fields {
            ::builtin::ensures(|res: TestEnum6V1Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum6V1Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum6V1Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    union TestEnum6FieldUnion {
        v1: TestEnum6V1Fields,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum6FieldUnion { }
    unsafe impl pmcopy for TestEnum6FieldUnion where TestEnum6V1Fields: pmcopy
        {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum6FieldUnion {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let size_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum6V1Fields>::spec_size_of()]);
            let largest_size = nat_seq_max(size_seq);
            let largest_size =
                (largest_size).spec_add(spec_padding_needed(largest_size,
                        <TestEnum6FieldUnion>::spec_align_of()));
            largest_size
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum6V1Fields>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum6FieldUnion {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum6FieldUnion {
        const SIZE: usize =
            {
                let mut largest_size: usize = 0;
                if largest_size <= <TestEnum6V1Fields>::SIZE {
                        largest_size = <TestEnum6V1Fields>::SIZE;
                    }
                let largest_size: usize =
                    largest_size +
                        padding_needed(largest_size, <TestEnum6FieldUnion>::ALIGN);
                largest_size
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum6V1Fields>::ALIGN {
                        largest_alignment = <TestEnum6V1Fields>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM6FIELDUNION: usize =
        (core::mem::size_of::<TestEnum6FieldUnion>() ==
                        <TestEnum6FieldUnion>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM6FIELDUNION: usize =
        (core::mem::align_of::<TestEnum6FieldUnion>() ==
                        <TestEnum6FieldUnion>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum6FieldUnion {}
    impl Clone for TestEnum6FieldUnion {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum6FieldUnion {
        fn eq(&self, other: &Self) -> bool {
            unsafe {
                match (self, other) {
                    (TestEnum6FieldUnion { v1: val0 }, TestEnum6FieldUnion {
                        v1: val1 }) => val0 == val1,
                    (_, _) => false,
                }
            }
        }
    }
    impl Eq for TestEnum6FieldUnion {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6fieldunion_clone(b: &TestEnum6FieldUnion)
        -> TestEnum6FieldUnion {
        ::builtin::ensures(|res: TestEnum6FieldUnion|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6fieldunion_eq(lhs: &TestEnum6FieldUnion,
        rhs: &TestEnum6FieldUnion) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum6FieldUnion {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum6FieldUnion {
            ::builtin::ensures(|res: TestEnum6FieldUnion|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum6FieldUnion {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum6FieldUnion {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum6EnumDiscriminant { V1, }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum6EnumDiscriminant { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum6EnumDiscriminant {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for TestEnum6EnumDiscriminant {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum6EnumDiscriminant {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum6EnumDiscriminant {}
    unsafe impl pmcopy for TestEnum6EnumDiscriminant {}
    impl PmCopy for TestEnum6EnumDiscriminant {}
    impl Clone for TestEnum6EnumDiscriminant {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum6EnumDiscriminant {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum6EnumDiscriminant::V1, TestEnum6EnumDiscriminant::V1)
                    => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum6EnumDiscriminant {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6enumdiscriminant_clone(b: &TestEnum6EnumDiscriminant)
        -> TestEnum6EnumDiscriminant {
        ::builtin::ensures(|res: TestEnum6EnumDiscriminant|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6enumdiscriminant_eq(lhs: &TestEnum6EnumDiscriminant,
        rhs: &TestEnum6EnumDiscriminant) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum6EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum6EnumDiscriminant {
            ::builtin::ensures(|res: TestEnum6EnumDiscriminant|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum6EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_TESTENUM6ENUMDISCRIMINANT: usize =
        (core::mem::size_of::<TestEnum6EnumDiscriminant>() ==
                        <TestEnum6EnumDiscriminant>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM6ENUMDISCRIMINANT: usize =
        (core::mem::align_of::<TestEnum6EnumDiscriminant>() ==
                        <TestEnum6EnumDiscriminant>::ALIGN) as usize - 1;
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum6LayoutStruct {
        tag: TestEnum6EnumDiscriminant,
        payload: TestEnum6FieldUnion,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum6LayoutStruct { }
    unsafe impl pmcopy for TestEnum6LayoutStruct where
        TestEnum6EnumDiscriminant: pmcopy, TestEnum6FieldUnion: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum6LayoutStruct {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum6EnumDiscriminant>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum6EnumDiscriminant>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum6FieldUnion>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum6FieldUnion>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum6LayoutStruct>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum6EnumDiscriminant>::spec_align_of(),
                                <TestEnum6FieldUnion>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum6LayoutStruct {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum6LayoutStruct {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <TestEnum6EnumDiscriminant>::SIZE +
                        padding_needed(offset, <TestEnum6EnumDiscriminant>::ALIGN);
                let offset: usize =
                    offset + <TestEnum6FieldUnion>::SIZE +
                        padding_needed(offset, <TestEnum6FieldUnion>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset, <TestEnum6LayoutStruct>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum6EnumDiscriminant>::ALIGN {
                        largest_alignment = <TestEnum6EnumDiscriminant>::ALIGN;
                    }
                if largest_alignment <= <TestEnum6FieldUnion>::ALIGN {
                        largest_alignment = <TestEnum6FieldUnion>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM6LAYOUTSTRUCT: usize =
        (core::mem::size_of::<TestEnum6LayoutStruct>() ==
                        <TestEnum6LayoutStruct>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM6LAYOUTSTRUCT: usize =
        (core::mem::align_of::<TestEnum6LayoutStruct>() ==
                        <TestEnum6LayoutStruct>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum6LayoutStruct {}
    impl Clone for TestEnum6LayoutStruct {
        fn clone(&self) -> Self {
            Self { tag: self.tag.clone(), payload: self.payload.clone() }
        }
    }
    impl PartialEq for TestEnum6LayoutStruct {
        fn eq(&self, other: &Self) -> bool {
            self.tag == other.tag && self.payload == other.payload
        }
    }
    impl Eq for TestEnum6LayoutStruct {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6layoutstruct_clone(b: &TestEnum6LayoutStruct)
        -> TestEnum6LayoutStruct {
        ::builtin::ensures(|res: TestEnum6LayoutStruct|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6layoutstruct_eq(lhs: &TestEnum6LayoutStruct,
        rhs: &TestEnum6LayoutStruct) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum6LayoutStruct {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum6LayoutStruct {
            ::builtin::ensures(|res: TestEnum6LayoutStruct|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum6LayoutStruct {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum6LayoutStruct {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum6 {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            TestEnum6LayoutStruct::spec_size_of()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            TestEnum6LayoutStruct::spec_align_of()
        }
    }
    unsafe impl PmSized for TestEnum6 {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum6 {
        const SIZE: usize = TestEnum6LayoutStruct::SIZE;
        const ALIGN: usize = TestEnum6LayoutStruct::ALIGN;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum6 {}
    const SIZE_CHECK_TESTENUM6: usize =
        (core::mem::size_of::<TestEnum6>() == <TestEnum6>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM6: usize =
        (core::mem::align_of::<TestEnum6>() == <TestEnum6>::ALIGN) as usize -
            1;
    impl Clone for TestEnum6 {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum6 {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum6::V1 {
                    f0: lhs_f0, f1: lhs_f1, f3: lhs_f2, f4: lhs_f3 },
                    TestEnum6::V1 {
                    f0: rhs_f0, f1: rhs_f1, f3: rhs_f2, f4: rhs_f3 }) => {
                    lhs_f0 == rhs_f0 && lhs_f1 == rhs_f1 && lhs_f2 == rhs_f2 &&
                        lhs_f3 == rhs_f3
                }
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum6 {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6_clone(b: &TestEnum6) -> TestEnum6 {
        ::builtin::ensures(|res: TestEnum6| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum6_eq(lhs: &TestEnum6, rhs: &TestEnum6) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum6 {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum6 {
            ::builtin::ensures(|res: TestEnum6|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum6 {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum6 {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum6 { }
    #[verus::internal(verus_macro)]
    impl TestEnum6 {
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_f4(self) -> u16 {
            ::builtin::get_variant_field(self, "V1", "f4")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_f1(self) -> u8 {
            ::builtin::get_variant_field(self, "V1", "f1")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_f3(self) -> u128 {
            ::builtin::get_variant_field(self, "V1", "f3")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_f0(self) -> u64 {
            ::builtin::get_variant_field(self, "V1", "f0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f0(self) -> u64 {
            ::builtin::get_variant_field(self, "V1", "f0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f1(self) -> u8 {
            ::builtin::get_variant_field(self, "V1", "f1")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f3(self) -> u128 {
            ::builtin::get_variant_field(self, "V1", "f3")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f4(self) -> u16 {
            ::builtin::get_variant_field(self, "V1", "f4")
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum7 {
        V1 {
            f0: u64,
            f1: u8,
            f3: u128,
            f4: u16,
        },
        V2,
        V3(u16),
        V4 {
            f0: u128,
            f1: u16,
        },
    }
    unsafe impl pmcopy for TestEnum7 where u64: pmcopy, u8: pmcopy,
        u128: pmcopy, u16: pmcopy, u16: pmcopy, u128: pmcopy, u16: pmcopy {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum7V1Fields {
        f0: u64,
        f1: u8,
        f3: u128,
        f4: u16,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7V1Fields { }
    unsafe impl pmcopy for TestEnum7V1Fields where u64: pmcopy, u8: pmcopy,
        u128: pmcopy, u16: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7V1Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u64>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u8>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u8>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u128>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u16>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u16>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum7V1Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of(),
                                <u8>::spec_align_of(), <u128>::spec_align_of(),
                                <u16>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum7V1Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7V1Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                let offset: usize =
                    offset + <u8>::SIZE + padding_needed(offset, <u8>::ALIGN);
                let offset: usize =
                    offset + <u128>::SIZE +
                        padding_needed(offset, <u128>::ALIGN);
                let offset: usize =
                    offset + <u16>::SIZE + padding_needed(offset, <u16>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum7V1Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u64>::ALIGN {
                        largest_alignment = <u64>::ALIGN;
                    }
                if largest_alignment <= <u8>::ALIGN {
                        largest_alignment = <u8>::ALIGN;
                    }
                if largest_alignment <= <u128>::ALIGN {
                        largest_alignment = <u128>::ALIGN;
                    }
                if largest_alignment <= <u16>::ALIGN {
                        largest_alignment = <u16>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM7V1FIELDS: usize =
        (core::mem::size_of::<TestEnum7V1Fields>() ==
                        <TestEnum7V1Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7V1FIELDS: usize =
        (core::mem::align_of::<TestEnum7V1Fields>() ==
                        <TestEnum7V1Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum7V1Fields {}
    impl Clone for TestEnum7V1Fields {
        fn clone(&self) -> Self {
            Self {
                f0: self.f0.clone(),
                f1: self.f1.clone(),
                f3: self.f3.clone(),
                f4: self.f4.clone(),
            }
        }
    }
    impl PartialEq for TestEnum7V1Fields {
        fn eq(&self, other: &Self) -> bool {
            self.f0 == other.f0 && self.f1 == other.f1 && self.f3 == other.f3
                && self.f4 == other.f4
        }
    }
    impl Eq for TestEnum7V1Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7v1fields_clone(b: &TestEnum7V1Fields)
        -> TestEnum7V1Fields {
        ::builtin::ensures(|res: TestEnum7V1Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7v1fields_eq(lhs: &TestEnum7V1Fields,
        rhs: &TestEnum7V1Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum7V1Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum7V1Fields {
            ::builtin::ensures(|res: TestEnum7V1Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum7V1Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum7V1Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum7V2Fields {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7V2Fields { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7V2Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(0usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
        }
    }
    unsafe impl pmcopy for TestEnum7V2Fields {}
    unsafe impl PmSized for TestEnum7V2Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7V2Fields {
        const SIZE: usize = 0usize;
        const ALIGN: usize = 1usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum7V2Fields {}
    const SIZE_CHECK_TESTENUM7V2FIELDS: usize =
        (core::mem::size_of::<TestEnum7V2Fields>() ==
                        <TestEnum7V2Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7V2FIELDS: usize =
        (core::mem::align_of::<TestEnum7V2Fields>() ==
                        <TestEnum7V2Fields>::ALIGN) as usize - 1;
    impl Clone for TestEnum7V2Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum7V2Fields {
        fn eq(&self, other: &Self) -> bool { true }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum7V3Fields(u16);
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7V3Fields { }
    unsafe impl pmcopy for TestEnum7V3Fields where u16: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7V3Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u16>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u16>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum7V3Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u16>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum7V3Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7V3Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u16>::SIZE + padding_needed(offset, <u16>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum7V3Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u16>::ALIGN {
                        largest_alignment = <u16>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM7V3FIELDS: usize =
        (core::mem::size_of::<TestEnum7V3Fields>() ==
                        <TestEnum7V3Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7V3FIELDS: usize =
        (core::mem::align_of::<TestEnum7V3Fields>() ==
                        <TestEnum7V3Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum7V3Fields {}
    impl Clone for TestEnum7V3Fields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum7V3Fields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for TestEnum7V3Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7v3fields_clone(b: &TestEnum7V3Fields)
        -> TestEnum7V3Fields {
        ::builtin::ensures(|res: TestEnum7V3Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7v3fields_eq(lhs: &TestEnum7V3Fields,
        rhs: &TestEnum7V3Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum7V3Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum7V3Fields {
            ::builtin::ensures(|res: TestEnum7V3Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum7V3Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum7V3Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum7V4Fields {
        f0: u128,
        f1: u16,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7V4Fields { }
    unsafe impl pmcopy for TestEnum7V4Fields where u128: pmcopy, u16: pmcopy
        {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7V4Fields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u128>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u16>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u16>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum7V4Fields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u128>::spec_align_of(),
                                <u16>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum7V4Fields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7V4Fields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u128>::SIZE +
                        padding_needed(offset, <u128>::ALIGN);
                let offset: usize =
                    offset + <u16>::SIZE + padding_needed(offset, <u16>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestEnum7V4Fields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u128>::ALIGN {
                        largest_alignment = <u128>::ALIGN;
                    }
                if largest_alignment <= <u16>::ALIGN {
                        largest_alignment = <u16>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM7V4FIELDS: usize =
        (core::mem::size_of::<TestEnum7V4Fields>() ==
                        <TestEnum7V4Fields>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7V4FIELDS: usize =
        (core::mem::align_of::<TestEnum7V4Fields>() ==
                        <TestEnum7V4Fields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum7V4Fields {}
    impl Clone for TestEnum7V4Fields {
        fn clone(&self) -> Self {
            Self { f0: self.f0.clone(), f1: self.f1.clone() }
        }
    }
    impl PartialEq for TestEnum7V4Fields {
        fn eq(&self, other: &Self) -> bool {
            self.f0 == other.f0 && self.f1 == other.f1
        }
    }
    impl Eq for TestEnum7V4Fields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7v4fields_clone(b: &TestEnum7V4Fields)
        -> TestEnum7V4Fields {
        ::builtin::ensures(|res: TestEnum7V4Fields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7v4fields_eq(lhs: &TestEnum7V4Fields,
        rhs: &TestEnum7V4Fields) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum7V4Fields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum7V4Fields {
            ::builtin::ensures(|res: TestEnum7V4Fields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum7V4Fields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum7V4Fields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    union TestEnum7FieldUnion {
        v1: TestEnum7V1Fields,
        v2: TestEnum7V2Fields,
        v3: TestEnum7V3Fields,
        v4: TestEnum7V4Fields,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7FieldUnion { }
    unsafe impl pmcopy for TestEnum7FieldUnion where
        TestEnum7V1Fields: pmcopy, TestEnum7V2Fields: pmcopy,
        TestEnum7V3Fields: pmcopy, TestEnum7V4Fields: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7FieldUnion {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let size_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum7V1Fields>::spec_size_of(),
                                <TestEnum7V2Fields>::spec_size_of(),
                                <TestEnum7V3Fields>::spec_size_of(),
                                <TestEnum7V4Fields>::spec_size_of()]);
            let largest_size = nat_seq_max(size_seq);
            let largest_size =
                (largest_size).spec_add(spec_padding_needed(largest_size,
                        <TestEnum7FieldUnion>::spec_align_of()));
            largest_size
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum7V1Fields>::spec_align_of(),
                                <TestEnum7V2Fields>::spec_align_of(),
                                <TestEnum7V3Fields>::spec_align_of(),
                                <TestEnum7V4Fields>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum7FieldUnion {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7FieldUnion {
        const SIZE: usize =
            {
                let mut largest_size: usize = 0;
                if largest_size <= <TestEnum7V1Fields>::SIZE {
                        largest_size = <TestEnum7V1Fields>::SIZE;
                    }
                if largest_size <= <TestEnum7V2Fields>::SIZE {
                        largest_size = <TestEnum7V2Fields>::SIZE;
                    }
                if largest_size <= <TestEnum7V3Fields>::SIZE {
                        largest_size = <TestEnum7V3Fields>::SIZE;
                    }
                if largest_size <= <TestEnum7V4Fields>::SIZE {
                        largest_size = <TestEnum7V4Fields>::SIZE;
                    }
                let largest_size: usize =
                    largest_size +
                        padding_needed(largest_size, <TestEnum7FieldUnion>::ALIGN);
                largest_size
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum7V1Fields>::ALIGN {
                        largest_alignment = <TestEnum7V1Fields>::ALIGN;
                    }
                if largest_alignment <= <TestEnum7V2Fields>::ALIGN {
                        largest_alignment = <TestEnum7V2Fields>::ALIGN;
                    }
                if largest_alignment <= <TestEnum7V3Fields>::ALIGN {
                        largest_alignment = <TestEnum7V3Fields>::ALIGN;
                    }
                if largest_alignment <= <TestEnum7V4Fields>::ALIGN {
                        largest_alignment = <TestEnum7V4Fields>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM7FIELDUNION: usize =
        (core::mem::size_of::<TestEnum7FieldUnion>() ==
                        <TestEnum7FieldUnion>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7FIELDUNION: usize =
        (core::mem::align_of::<TestEnum7FieldUnion>() ==
                        <TestEnum7FieldUnion>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum7FieldUnion {}
    impl Clone for TestEnum7FieldUnion {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum7FieldUnion {
        fn eq(&self, other: &Self) -> bool {
            unsafe {
                match (self, other) {
                    (TestEnum7FieldUnion { v1: val0 }, TestEnum7FieldUnion {
                        v1: val1 }) => val0 == val1,
                    (TestEnum7FieldUnion { v2: val0 }, TestEnum7FieldUnion {
                        v2: val1 }) => val0 == val1,
                    (TestEnum7FieldUnion { v3: val0 }, TestEnum7FieldUnion {
                        v3: val1 }) => val0 == val1,
                    (TestEnum7FieldUnion { v4: val0 }, TestEnum7FieldUnion {
                        v4: val1 }) => val0 == val1,
                    (_, _) => false,
                }
            }
        }
    }
    impl Eq for TestEnum7FieldUnion {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7fieldunion_clone(b: &TestEnum7FieldUnion)
        -> TestEnum7FieldUnion {
        ::builtin::ensures(|res: TestEnum7FieldUnion|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7fieldunion_eq(lhs: &TestEnum7FieldUnion,
        rhs: &TestEnum7FieldUnion) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum7FieldUnion {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum7FieldUnion {
            ::builtin::ensures(|res: TestEnum7FieldUnion|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum7FieldUnion {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum7FieldUnion {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum TestEnum7EnumDiscriminant { V1, V2, V3, V4, }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7EnumDiscriminant { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7EnumDiscriminant {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for TestEnum7EnumDiscriminant {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7EnumDiscriminant {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum7EnumDiscriminant {}
    unsafe impl pmcopy for TestEnum7EnumDiscriminant {}
    impl PmCopy for TestEnum7EnumDiscriminant {}
    impl Clone for TestEnum7EnumDiscriminant {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum7EnumDiscriminant {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum7EnumDiscriminant::V1, TestEnum7EnumDiscriminant::V1)
                    => true,
                (TestEnum7EnumDiscriminant::V2, TestEnum7EnumDiscriminant::V2)
                    => true,
                (TestEnum7EnumDiscriminant::V3, TestEnum7EnumDiscriminant::V3)
                    => true,
                (TestEnum7EnumDiscriminant::V4, TestEnum7EnumDiscriminant::V4)
                    => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum7EnumDiscriminant {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7enumdiscriminant_clone(b: &TestEnum7EnumDiscriminant)
        -> TestEnum7EnumDiscriminant {
        ::builtin::ensures(|res: TestEnum7EnumDiscriminant|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7enumdiscriminant_eq(lhs: &TestEnum7EnumDiscriminant,
        rhs: &TestEnum7EnumDiscriminant) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum7EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum7EnumDiscriminant {
            ::builtin::ensures(|res: TestEnum7EnumDiscriminant|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum7EnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_TESTENUM7ENUMDISCRIMINANT: usize =
        (core::mem::size_of::<TestEnum7EnumDiscriminant>() ==
                        <TestEnum7EnumDiscriminant>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7ENUMDISCRIMINANT: usize =
        (core::mem::align_of::<TestEnum7EnumDiscriminant>() ==
                        <TestEnum7EnumDiscriminant>::ALIGN) as usize - 1;
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestEnum7LayoutStruct {
        tag: TestEnum7EnumDiscriminant,
        payload: TestEnum7FieldUnion,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7LayoutStruct { }
    unsafe impl pmcopy for TestEnum7LayoutStruct where
        TestEnum7EnumDiscriminant: pmcopy, TestEnum7FieldUnion: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7LayoutStruct {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum7EnumDiscriminant>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum7EnumDiscriminant>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<TestEnum7FieldUnion>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <TestEnum7FieldUnion>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestEnum7LayoutStruct>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<TestEnum7EnumDiscriminant>::spec_align_of(),
                                <TestEnum7FieldUnion>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestEnum7LayoutStruct {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7LayoutStruct {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <TestEnum7EnumDiscriminant>::SIZE +
                        padding_needed(offset, <TestEnum7EnumDiscriminant>::ALIGN);
                let offset: usize =
                    offset + <TestEnum7FieldUnion>::SIZE +
                        padding_needed(offset, <TestEnum7FieldUnion>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset, <TestEnum7LayoutStruct>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <TestEnum7EnumDiscriminant>::ALIGN {
                        largest_alignment = <TestEnum7EnumDiscriminant>::ALIGN;
                    }
                if largest_alignment <= <TestEnum7FieldUnion>::ALIGN {
                        largest_alignment = <TestEnum7FieldUnion>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTENUM7LAYOUTSTRUCT: usize =
        (core::mem::size_of::<TestEnum7LayoutStruct>() ==
                        <TestEnum7LayoutStruct>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7LAYOUTSTRUCT: usize =
        (core::mem::align_of::<TestEnum7LayoutStruct>() ==
                        <TestEnum7LayoutStruct>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestEnum7LayoutStruct {}
    impl Clone for TestEnum7LayoutStruct {
        fn clone(&self) -> Self {
            Self { tag: self.tag.clone(), payload: self.payload.clone() }
        }
    }
    impl PartialEq for TestEnum7LayoutStruct {
        fn eq(&self, other: &Self) -> bool {
            self.tag == other.tag && self.payload == other.payload
        }
    }
    impl Eq for TestEnum7LayoutStruct {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7layoutstruct_clone(b: &TestEnum7LayoutStruct)
        -> TestEnum7LayoutStruct {
        ::builtin::ensures(|res: TestEnum7LayoutStruct|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7layoutstruct_eq(lhs: &TestEnum7LayoutStruct,
        rhs: &TestEnum7LayoutStruct) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum7LayoutStruct {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum7LayoutStruct {
            ::builtin::ensures(|res: TestEnum7LayoutStruct|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum7LayoutStruct {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum7LayoutStruct {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestEnum7 {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            TestEnum7LayoutStruct::spec_size_of()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            TestEnum7LayoutStruct::spec_align_of()
        }
    }
    unsafe impl PmSized for TestEnum7 {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestEnum7 {
        const SIZE: usize = TestEnum7LayoutStruct::SIZE;
        const ALIGN: usize = TestEnum7LayoutStruct::ALIGN;
    }
    unsafe impl UnsafeSpecPmSized for TestEnum7 {}
    const SIZE_CHECK_TESTENUM7: usize =
        (core::mem::size_of::<TestEnum7>() == <TestEnum7>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTENUM7: usize =
        (core::mem::align_of::<TestEnum7>() == <TestEnum7>::ALIGN) as usize -
            1;
    impl Clone for TestEnum7 {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestEnum7 {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (TestEnum7::V1 {
                    f0: lhs_f0, f1: lhs_f1, f3: lhs_f2, f4: lhs_f3 },
                    TestEnum7::V1 {
                    f0: rhs_f0, f1: rhs_f1, f3: rhs_f2, f4: rhs_f3 }) => {
                    lhs_f0 == rhs_f0 && lhs_f1 == rhs_f1 && lhs_f2 == rhs_f2 &&
                        lhs_f3 == rhs_f3
                }
                (TestEnum7::V2, TestEnum7::V2) => true,
                (TestEnum7::V3(lhs_f0), TestEnum7::V3(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (TestEnum7::V4 { f0: lhs_f0, f1: lhs_f1 }, TestEnum7::V4 {
                    f0: rhs_f0, f1: rhs_f1 }) => {
                    lhs_f0 == rhs_f0 && lhs_f1 == rhs_f1
                }
                (_, _) => false,
            }
        }
    }
    impl Eq for TestEnum7 {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7_clone(b: &TestEnum7) -> TestEnum7 {
        ::builtin::ensures(|res: TestEnum7| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testenum7_eq(lhs: &TestEnum7, rhs: &TestEnum7) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestEnum7 {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestEnum7 {
            ::builtin::ensures(|res: TestEnum7|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestEnum7 {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestEnum7 {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestEnum7 { }
    #[verus::internal(verus_macro)]
    impl TestEnum7 {
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_f4(self) -> u16 {
            ::builtin::get_variant_field(self, "V1", "f4")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_0(self) -> u16 {
            ::builtin::get_variant_field(self, "V3", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_f3(self) -> u128 {
            ::builtin::get_variant_field(self, "V1", "f3")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f0(self) -> u64 {
            ::builtin::get_variant_field(self, "V1", "f0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f1(self) -> u8 {
            ::builtin::get_variant_field(self, "V1", "f1")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f3(self) -> u128 {
            ::builtin::get_variant_field(self, "V1", "f3")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V1_f4(self) -> u16 {
            ::builtin::get_variant_field(self, "V1", "f4")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V3_0(self) -> u16 {
            ::builtin::get_variant_field(self, "V3", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V4_f0(self) -> u128 {
            ::builtin::get_variant_field(self, "V4", "f0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        fn arrow_V4_f1(self) -> u16 {
            ::builtin::get_variant_field(self, "V4", "f1")
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct TestUnnamedFieldStruct(u8, u128, u16);
    unsafe impl pmcopy for TestUnnamedFieldStruct where u8: pmcopy,
        u128: pmcopy, u16: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestUnnamedFieldStruct {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u8>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u8>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u128>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u128>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<u16>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u16>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestUnnamedFieldStruct>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u8>::spec_align_of(),
                                <u128>::spec_align_of(), <u16>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestUnnamedFieldStruct {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestUnnamedFieldStruct {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u8>::SIZE + padding_needed(offset, <u8>::ALIGN);
                let offset: usize =
                    offset + <u128>::SIZE +
                        padding_needed(offset, <u128>::ALIGN);
                let offset: usize =
                    offset + <u16>::SIZE + padding_needed(offset, <u16>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset, <TestUnnamedFieldStruct>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u8>::ALIGN {
                        largest_alignment = <u8>::ALIGN;
                    }
                if largest_alignment <= <u128>::ALIGN {
                        largest_alignment = <u128>::ALIGN;
                    }
                if largest_alignment <= <u16>::ALIGN {
                        largest_alignment = <u16>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTUNNAMEDFIELDSTRUCT: usize =
        (core::mem::size_of::<TestUnnamedFieldStruct>() ==
                        <TestUnnamedFieldStruct>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTUNNAMEDFIELDSTRUCT: usize =
        (core::mem::align_of::<TestUnnamedFieldStruct>() ==
                        <TestUnnamedFieldStruct>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestUnnamedFieldStruct {}
    impl Clone for TestUnnamedFieldStruct {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for TestUnnamedFieldStruct {
        fn eq(&self, other: &Self) -> bool {
            self.0 == other.0 && self.1 == other.1 && self.2 == other.2
        }
    }
    impl Eq for TestUnnamedFieldStruct {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testunnamedfieldstruct_clone(b: &TestUnnamedFieldStruct)
        -> TestUnnamedFieldStruct {
        ::builtin::ensures(|res: TestUnnamedFieldStruct|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testunnamedfieldstruct_eq(lhs: &TestUnnamedFieldStruct,
        rhs: &TestUnnamedFieldStruct) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestUnnamedFieldStruct {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestUnnamedFieldStruct {
            ::builtin::ensures(|res: TestUnnamedFieldStruct|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestUnnamedFieldStruct {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestUnnamedFieldStruct {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestUnnamedFieldStruct { }
    pub type PmemOffset = u128;
    #[repr(C)]
    #[verus::internal(verus_macro)]
    pub enum BlockOffsetType { None, InPMem(PmemOffset), InFile, }
    #[automatically_derived]
    impl ::core::marker::Copy for BlockOffsetType { }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockOffsetType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BlockOffsetType::None =>
                    ::core::fmt::Formatter::write_str(f, "None"),
                BlockOffsetType::InPMem(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "InPMem", &__self_0),
                BlockOffsetType::InFile =>
                    ::core::fmt::Formatter::write_str(f, "InFile"),
            }
        }
    }
    unsafe impl pmcopy for BlockOffsetType where PmemOffset: pmcopy {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct BlockOffsetTypeNoneFields {}
    #[automatically_derived]
    impl ::core::marker::Copy for BlockOffsetTypeNoneFields { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for BlockOffsetTypeNoneFields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(0usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
        }
    }
    unsafe impl pmcopy for BlockOffsetTypeNoneFields {}
    unsafe impl PmSized for BlockOffsetTypeNoneFields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for BlockOffsetTypeNoneFields {
        const SIZE: usize = 0usize;
        const ALIGN: usize = 1usize;
    }
    unsafe impl UnsafeSpecPmSized for BlockOffsetTypeNoneFields {}
    const SIZE_CHECK_BLOCKOFFSETTYPENONEFIELDS: usize =
        (core::mem::size_of::<BlockOffsetTypeNoneFields>() ==
                        <BlockOffsetTypeNoneFields>::SIZE) as usize - 1;
    const ALIGN_CHECK_BLOCKOFFSETTYPENONEFIELDS: usize =
        (core::mem::align_of::<BlockOffsetTypeNoneFields>() ==
                        <BlockOffsetTypeNoneFields>::ALIGN) as usize - 1;
    impl Clone for BlockOffsetTypeNoneFields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for BlockOffsetTypeNoneFields {
        fn eq(&self, other: &Self) -> bool { true }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct BlockOffsetTypeInPMemFields(PmemOffset);
    #[automatically_derived]
    impl ::core::marker::Copy for BlockOffsetTypeInPMemFields { }
    unsafe impl pmcopy for BlockOffsetTypeInPMemFields where
        PmemOffset: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for BlockOffsetTypeInPMemFields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<PmemOffset>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <PmemOffset>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <BlockOffsetTypeInPMemFields>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<PmemOffset>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for BlockOffsetTypeInPMemFields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for BlockOffsetTypeInPMemFields {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <PmemOffset>::SIZE +
                        padding_needed(offset, <PmemOffset>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset,
                            <BlockOffsetTypeInPMemFields>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <PmemOffset>::ALIGN {
                        largest_alignment = <PmemOffset>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_BLOCKOFFSETTYPEINPMEMFIELDS: usize =
        (core::mem::size_of::<BlockOffsetTypeInPMemFields>() ==
                        <BlockOffsetTypeInPMemFields>::SIZE) as usize - 1;
    const ALIGN_CHECK_BLOCKOFFSETTYPEINPMEMFIELDS: usize =
        (core::mem::align_of::<BlockOffsetTypeInPMemFields>() ==
                        <BlockOffsetTypeInPMemFields>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for BlockOffsetTypeInPMemFields {}
    impl Clone for BlockOffsetTypeInPMemFields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for BlockOffsetTypeInPMemFields {
        fn eq(&self, other: &Self) -> bool { self.0 == other.0 }
    }
    impl Eq for BlockOffsetTypeInPMemFields {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypeinpmemfields_clone(b:
            &BlockOffsetTypeInPMemFields) -> BlockOffsetTypeInPMemFields {
        ::builtin::ensures(|res: BlockOffsetTypeInPMemFields|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypeinpmemfields_eq(lhs:
            &BlockOffsetTypeInPMemFields, rhs: &BlockOffsetTypeInPMemFields)
        -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for BlockOffsetTypeInPMemFields {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> BlockOffsetTypeInPMemFields {
            ::builtin::ensures(|res: BlockOffsetTypeInPMemFields|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for BlockOffsetTypeInPMemFields {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for BlockOffsetTypeInPMemFields {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct BlockOffsetTypeInFileFields {}
    #[automatically_derived]
    impl ::core::marker::Copy for BlockOffsetTypeInFileFields { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for BlockOffsetTypeInFileFields {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(0usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(1usize)
        }
    }
    unsafe impl pmcopy for BlockOffsetTypeInFileFields {}
    unsafe impl PmSized for BlockOffsetTypeInFileFields {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for BlockOffsetTypeInFileFields {
        const SIZE: usize = 0usize;
        const ALIGN: usize = 1usize;
    }
    unsafe impl UnsafeSpecPmSized for BlockOffsetTypeInFileFields {}
    const SIZE_CHECK_BLOCKOFFSETTYPEINFILEFIELDS: usize =
        (core::mem::size_of::<BlockOffsetTypeInFileFields>() ==
                        <BlockOffsetTypeInFileFields>::SIZE) as usize - 1;
    const ALIGN_CHECK_BLOCKOFFSETTYPEINFILEFIELDS: usize =
        (core::mem::align_of::<BlockOffsetTypeInFileFields>() ==
                        <BlockOffsetTypeInFileFields>::ALIGN) as usize - 1;
    impl Clone for BlockOffsetTypeInFileFields {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for BlockOffsetTypeInFileFields {
        fn eq(&self, other: &Self) -> bool { true }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    union BlockOffsetTypeFieldUnion {
        none: BlockOffsetTypeNoneFields,
        inpmem: BlockOffsetTypeInPMemFields,
        infile: BlockOffsetTypeInFileFields,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BlockOffsetTypeFieldUnion { }
    unsafe impl pmcopy for BlockOffsetTypeFieldUnion where
        BlockOffsetTypeNoneFields: pmcopy,
        BlockOffsetTypeInPMemFields: pmcopy,
        BlockOffsetTypeInFileFields: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for BlockOffsetTypeFieldUnion {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let size_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<BlockOffsetTypeNoneFields>::spec_size_of(),
                                <BlockOffsetTypeInPMemFields>::spec_size_of(),
                                <BlockOffsetTypeInFileFields>::spec_size_of()]);
            let largest_size = nat_seq_max(size_seq);
            let largest_size =
                (largest_size).spec_add(spec_padding_needed(largest_size,
                        <BlockOffsetTypeFieldUnion>::spec_align_of()));
            largest_size
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<BlockOffsetTypeNoneFields>::spec_align_of(),
                                <BlockOffsetTypeInPMemFields>::spec_align_of(),
                                <BlockOffsetTypeInFileFields>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for BlockOffsetTypeFieldUnion {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for BlockOffsetTypeFieldUnion {
        const SIZE: usize =
            {
                let mut largest_size: usize = 0;
                if largest_size <= <BlockOffsetTypeNoneFields>::SIZE {
                        largest_size = <BlockOffsetTypeNoneFields>::SIZE;
                    }
                if largest_size <= <BlockOffsetTypeInPMemFields>::SIZE {
                        largest_size = <BlockOffsetTypeInPMemFields>::SIZE;
                    }
                if largest_size <= <BlockOffsetTypeInFileFields>::SIZE {
                        largest_size = <BlockOffsetTypeInFileFields>::SIZE;
                    }
                let largest_size: usize =
                    largest_size +
                        padding_needed(largest_size,
                            <BlockOffsetTypeFieldUnion>::ALIGN);
                largest_size
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <BlockOffsetTypeNoneFields>::ALIGN {
                        largest_alignment = <BlockOffsetTypeNoneFields>::ALIGN;
                    }
                if largest_alignment <= <BlockOffsetTypeInPMemFields>::ALIGN {
                        largest_alignment = <BlockOffsetTypeInPMemFields>::ALIGN;
                    }
                if largest_alignment <= <BlockOffsetTypeInFileFields>::ALIGN {
                        largest_alignment = <BlockOffsetTypeInFileFields>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_BLOCKOFFSETTYPEFIELDUNION: usize =
        (core::mem::size_of::<BlockOffsetTypeFieldUnion>() ==
                        <BlockOffsetTypeFieldUnion>::SIZE) as usize - 1;
    const ALIGN_CHECK_BLOCKOFFSETTYPEFIELDUNION: usize =
        (core::mem::align_of::<BlockOffsetTypeFieldUnion>() ==
                        <BlockOffsetTypeFieldUnion>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for BlockOffsetTypeFieldUnion {}
    impl Clone for BlockOffsetTypeFieldUnion {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for BlockOffsetTypeFieldUnion {
        fn eq(&self, other: &Self) -> bool {
            unsafe {
                match (self, other) {
                    (BlockOffsetTypeFieldUnion { none: val0 },
                        BlockOffsetTypeFieldUnion { none: val1 }) => val0 == val1,
                    (BlockOffsetTypeFieldUnion { inpmem: val0 },
                        BlockOffsetTypeFieldUnion { inpmem: val1 }) => val0 == val1,
                    (BlockOffsetTypeFieldUnion { infile: val0 },
                        BlockOffsetTypeFieldUnion { infile: val1 }) => val0 == val1,
                    (_, _) => false,
                }
            }
        }
    }
    impl Eq for BlockOffsetTypeFieldUnion {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypefieldunion_clone(b: &BlockOffsetTypeFieldUnion)
        -> BlockOffsetTypeFieldUnion {
        ::builtin::ensures(|res: BlockOffsetTypeFieldUnion|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypefieldunion_eq(lhs: &BlockOffsetTypeFieldUnion,
        rhs: &BlockOffsetTypeFieldUnion) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for BlockOffsetTypeFieldUnion {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> BlockOffsetTypeFieldUnion {
            ::builtin::ensures(|res: BlockOffsetTypeFieldUnion|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for BlockOffsetTypeFieldUnion {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for BlockOffsetTypeFieldUnion {}
    #[repr(C)]
    #[verus::internal(verus_macro)]
    enum BlockOffsetTypeEnumDiscriminant { None, InPMem, InFile, }
    #[automatically_derived]
    impl ::core::marker::Copy for BlockOffsetTypeEnumDiscriminant { }
    #[verus::internal(verus_macro)]
    impl SpecPmSized for BlockOffsetTypeEnumDiscriminant {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            ::builtin::spec_cast_integer::<_, ::builtin::nat>(4usize)
        }
    }
    unsafe impl PmSized for BlockOffsetTypeEnumDiscriminant {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for BlockOffsetTypeEnumDiscriminant {
        const SIZE: usize = 4usize;
        const ALIGN: usize = 4usize;
    }
    unsafe impl UnsafeSpecPmSized for BlockOffsetTypeEnumDiscriminant {}
    unsafe impl pmcopy for BlockOffsetTypeEnumDiscriminant {}
    impl PmCopy for BlockOffsetTypeEnumDiscriminant {}
    impl Clone for BlockOffsetTypeEnumDiscriminant {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for BlockOffsetTypeEnumDiscriminant {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (BlockOffsetTypeEnumDiscriminant::None,
                    BlockOffsetTypeEnumDiscriminant::None) => true,
                (BlockOffsetTypeEnumDiscriminant::InPMem,
                    BlockOffsetTypeEnumDiscriminant::InPMem) => true,
                (BlockOffsetTypeEnumDiscriminant::InFile,
                    BlockOffsetTypeEnumDiscriminant::InFile) => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for BlockOffsetTypeEnumDiscriminant {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypeenumdiscriminant_clone(b:
            &BlockOffsetTypeEnumDiscriminant)
        -> BlockOffsetTypeEnumDiscriminant {
        ::builtin::ensures(|res: BlockOffsetTypeEnumDiscriminant|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypeenumdiscriminant_eq(lhs:
            &BlockOffsetTypeEnumDiscriminant,
        rhs: &BlockOffsetTypeEnumDiscriminant) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for BlockOffsetTypeEnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> BlockOffsetTypeEnumDiscriminant {
            ::builtin::ensures(|res: BlockOffsetTypeEnumDiscriminant|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for BlockOffsetTypeEnumDiscriminant {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    const SIZE_CHECK_BLOCKOFFSETTYPEENUMDISCRIMINANT: usize =
        (core::mem::size_of::<BlockOffsetTypeEnumDiscriminant>() ==
                        <BlockOffsetTypeEnumDiscriminant>::SIZE) as usize - 1;
    const ALIGN_CHECK_BLOCKOFFSETTYPEENUMDISCRIMINANT: usize =
        (core::mem::align_of::<BlockOffsetTypeEnumDiscriminant>() ==
                        <BlockOffsetTypeEnumDiscriminant>::ALIGN) as usize - 1;
    #[repr(C)]
    #[verus::internal(verus_macro)]
    struct BlockOffsetTypeLayoutStruct {
        tag: BlockOffsetTypeEnumDiscriminant,
        payload: BlockOffsetTypeFieldUnion,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BlockOffsetTypeLayoutStruct { }
    unsafe impl pmcopy for BlockOffsetTypeLayoutStruct where
        BlockOffsetTypeEnumDiscriminant: pmcopy,
        BlockOffsetTypeFieldUnion: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for BlockOffsetTypeLayoutStruct {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<BlockOffsetTypeEnumDiscriminant>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <BlockOffsetTypeEnumDiscriminant>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<BlockOffsetTypeFieldUnion>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <BlockOffsetTypeFieldUnion>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <BlockOffsetTypeLayoutStruct>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<BlockOffsetTypeEnumDiscriminant>::spec_align_of(),
                                <BlockOffsetTypeFieldUnion>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for BlockOffsetTypeLayoutStruct {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for BlockOffsetTypeLayoutStruct {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <BlockOffsetTypeEnumDiscriminant>::SIZE +
                        padding_needed(offset,
                            <BlockOffsetTypeEnumDiscriminant>::ALIGN);
                let offset: usize =
                    offset + <BlockOffsetTypeFieldUnion>::SIZE +
                        padding_needed(offset, <BlockOffsetTypeFieldUnion>::ALIGN);
                let offset: usize =
                    offset +
                        padding_needed(offset,
                            <BlockOffsetTypeLayoutStruct>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <=
                            <BlockOffsetTypeEnumDiscriminant>::ALIGN {
                        largest_alignment =
                            <BlockOffsetTypeEnumDiscriminant>::ALIGN;
                    }
                if largest_alignment <= <BlockOffsetTypeFieldUnion>::ALIGN {
                        largest_alignment = <BlockOffsetTypeFieldUnion>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_BLOCKOFFSETTYPELAYOUTSTRUCT: usize =
        (core::mem::size_of::<BlockOffsetTypeLayoutStruct>() ==
                        <BlockOffsetTypeLayoutStruct>::SIZE) as usize - 1;
    const ALIGN_CHECK_BLOCKOFFSETTYPELAYOUTSTRUCT: usize =
        (core::mem::align_of::<BlockOffsetTypeLayoutStruct>() ==
                        <BlockOffsetTypeLayoutStruct>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for BlockOffsetTypeLayoutStruct {}
    impl Clone for BlockOffsetTypeLayoutStruct {
        fn clone(&self) -> Self {
            Self { tag: self.tag.clone(), payload: self.payload.clone() }
        }
    }
    impl PartialEq for BlockOffsetTypeLayoutStruct {
        fn eq(&self, other: &Self) -> bool {
            self.tag == other.tag && self.payload == other.payload
        }
    }
    impl Eq for BlockOffsetTypeLayoutStruct {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypelayoutstruct_clone(b:
            &BlockOffsetTypeLayoutStruct) -> BlockOffsetTypeLayoutStruct {
        ::builtin::ensures(|res: BlockOffsetTypeLayoutStruct|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettypelayoutstruct_eq(lhs:
            &BlockOffsetTypeLayoutStruct, rhs: &BlockOffsetTypeLayoutStruct)
        -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for BlockOffsetTypeLayoutStruct {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> BlockOffsetTypeLayoutStruct {
            ::builtin::ensures(|res: BlockOffsetTypeLayoutStruct|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for BlockOffsetTypeLayoutStruct {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for BlockOffsetTypeLayoutStruct {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for BlockOffsetType {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            BlockOffsetTypeLayoutStruct::spec_size_of()
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            BlockOffsetTypeLayoutStruct::spec_align_of()
        }
    }
    unsafe impl PmSized for BlockOffsetType {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for BlockOffsetType {
        const SIZE: usize = BlockOffsetTypeLayoutStruct::SIZE;
        const ALIGN: usize = BlockOffsetTypeLayoutStruct::ALIGN;
    }
    unsafe impl UnsafeSpecPmSized for BlockOffsetType {}
    const SIZE_CHECK_BLOCKOFFSETTYPE: usize =
        (core::mem::size_of::<BlockOffsetType>() == <BlockOffsetType>::SIZE)
                as usize - 1;
    const ALIGN_CHECK_BLOCKOFFSETTYPE: usize =
        (core::mem::align_of::<BlockOffsetType>() == <BlockOffsetType>::ALIGN)
                as usize - 1;
    impl Clone for BlockOffsetType {
        fn clone(&self) -> Self { *self }
    }
    impl PartialEq for BlockOffsetType {
        fn eq(&self, other: &Self) -> bool {
            match (self, other) {
                (BlockOffsetType::None, BlockOffsetType::None) => true,
                (BlockOffsetType::InPMem(lhs_f0),
                    BlockOffsetType::InPMem(rhs_f0)) => {
                    lhs_f0 == rhs_f0
                }
                (BlockOffsetType::InFile, BlockOffsetType::InFile) => true,
                (_, _) => false,
            }
        }
    }
    impl Eq for BlockOffsetType {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettype_clone(b: &BlockOffsetType) -> BlockOffsetType {
        ::builtin::ensures(|res: BlockOffsetType|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_blockoffsettype_eq(lhs: &BlockOffsetType, rhs: &BlockOffsetType)
        -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for BlockOffsetType {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> BlockOffsetType {
            ::builtin::ensures(|res: BlockOffsetType|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for BlockOffsetType {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for BlockOffsetType {}
    #[verus::internal(verus_macro)]
    impl BlockOffsetType {
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        #[verus::internal(open)]
        pub fn arrow_0(self) -> PmemOffset {
            ::builtin::get_variant_field(self, "InPMem", "0")
        }
        #[cfg(verus_keep_ghost)]
        #[allow(non_snake_case)]
        #[verus::internal(verus_macro)]
        #[verus::internal(spec)]
        #[verifier::inline]
        #[verus::internal(open)]
        pub fn arrow_InPMem_0(self) -> PmemOffset {
            ::builtin::get_variant_field(self, "InPMem", "0")
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    pub struct TestKey {
        pub val: u64,
    }
    unsafe impl pmcopy for TestKey where u64: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestKey {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u64>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestKey>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestKey {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestKey {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestKey>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u64>::ALIGN {
                        largest_alignment = <u64>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTKEY: usize =
        (core::mem::size_of::<TestKey>() == <TestKey>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTKEY: usize =
        (core::mem::align_of::<TestKey>() == <TestKey>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestKey {}
    impl Clone for TestKey {
        fn clone(&self) -> Self { Self { val: self.val.clone() } }
    }
    impl PartialEq for TestKey {
        fn eq(&self, other: &Self) -> bool { self.val == other.val }
    }
    impl Eq for TestKey {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testkey_clone(b: &TestKey) -> TestKey {
        ::builtin::ensures(|res: TestKey| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testkey_eq(lhs: &TestKey, rhs: &TestKey) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestKey {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestKey {
            ::builtin::ensures(|res: TestKey|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestKey {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestKey {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestKey { }
    #[automatically_derived]
    impl ::core::fmt::Debug for TestKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f, "TestKey",
                "val", &&self.val)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TestKey {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.val, state)
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    pub struct TestItem {
        pub val: u64,
    }
    unsafe impl pmcopy for TestItem where u64: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestItem {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u64>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestItem>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestItem {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestItem {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestItem>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u64>::ALIGN {
                        largest_alignment = <u64>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTITEM: usize =
        (core::mem::size_of::<TestItem>() == <TestItem>::SIZE) as usize - 1;
    const ALIGN_CHECK_TESTITEM: usize =
        (core::mem::align_of::<TestItem>() == <TestItem>::ALIGN) as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestItem {}
    impl Clone for TestItem {
        fn clone(&self) -> Self { Self { val: self.val.clone() } }
    }
    impl PartialEq for TestItem {
        fn eq(&self, other: &Self) -> bool { self.val == other.val }
    }
    impl Eq for TestItem {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testitem_clone(b: &TestItem) -> TestItem {
        ::builtin::ensures(|res: TestItem| [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testitem_eq(lhs: &TestItem, rhs: &TestItem) -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestItem {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestItem {
            ::builtin::ensures(|res: TestItem|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestItem {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestItem {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestItem { }
    #[automatically_derived]
    impl ::core::fmt::Debug for TestItem {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f, "TestItem",
                "val", &&self.val)
        }
    }
    #[repr(C)]
    #[verus::internal(verus_macro)]
    pub struct TestListElement {
        pub val: u64,
        pub start: usize,
        pub end: usize,
    }
    unsafe impl pmcopy for TestListElement where u64: pmcopy, usize: pmcopy,
        usize: pmcopy {}
    #[verus::internal(verus_macro)]
    impl SpecPmSized for TestListElement {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_size_of() -> ::builtin::nat {
            let offset: ::builtin::nat = ::builtin::spec_literal_integer("0");
            let offset: ::builtin::nat =
                ((offset).spec_add(<u64>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <u64>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<usize>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <usize>::spec_align_of()));
            let offset: ::builtin::nat =
                ((offset).spec_add(<usize>::spec_size_of())).spec_add(spec_padding_needed(offset,
                        <usize>::spec_align_of()));
            let offset: ::builtin::nat =
                (offset).spec_add(spec_padding_needed(offset,
                        <TestListElement>::spec_align_of()));
            offset
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_align_of() -> ::builtin::nat {
            let alignment_seq =
                <_ as
                        ::vstd::vstd::view::View>::view(&[<u64>::spec_align_of(),
                                <usize>::spec_align_of(), <usize>::spec_align_of()]);
            nat_seq_max(alignment_seq)
        }
    }
    unsafe impl PmSized for TestListElement {
        fn size_of() -> usize { Self::SIZE }
        fn align_of() -> usize { Self::ALIGN }
    }
    unsafe impl ConstPmSized for TestListElement {
        const SIZE: usize =
            {
                let offset: usize = 0;
                let offset: usize =
                    offset + <u64>::SIZE + padding_needed(offset, <u64>::ALIGN);
                let offset: usize =
                    offset + <usize>::SIZE +
                        padding_needed(offset, <usize>::ALIGN);
                let offset: usize =
                    offset + <usize>::SIZE +
                        padding_needed(offset, <usize>::ALIGN);
                let offset: usize =
                    offset + padding_needed(offset, <TestListElement>::ALIGN);
                offset
            };
        const ALIGN: usize =
            {
                let mut largest_alignment: usize = 0;
                if largest_alignment <= <u64>::ALIGN {
                        largest_alignment = <u64>::ALIGN;
                    }
                if largest_alignment <= <usize>::ALIGN {
                        largest_alignment = <usize>::ALIGN;
                    }
                if largest_alignment <= <usize>::ALIGN {
                        largest_alignment = <usize>::ALIGN;
                    }
                largest_alignment
            };
    }
    const SIZE_CHECK_TESTLISTELEMENT: usize =
        (core::mem::size_of::<TestListElement>() == <TestListElement>::SIZE)
                as usize - 1;
    const ALIGN_CHECK_TESTLISTELEMENT: usize =
        (core::mem::align_of::<TestListElement>() == <TestListElement>::ALIGN)
                as usize - 1;
    unsafe impl UnsafeSpecPmSized for TestListElement {}
    impl Clone for TestListElement {
        fn clone(&self) -> Self {
            Self {
                val: self.val.clone(),
                start: self.start.clone(),
                end: self.end.clone(),
            }
        }
    }
    impl PartialEq for TestListElement {
        fn eq(&self, other: &Self) -> bool {
            self.val == other.val && self.start == other.start &&
                self.end == other.end
        }
    }
    impl Eq for TestListElement {}
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testlistelement_clone(b: &TestListElement) -> TestListElement {
        ::builtin::ensures(|res: TestListElement|
                [::builtin::spec_eq(*b, res)]);
        b.clone()
    }
    #[verifier::external_fn_specification]
    #[verus::internal(verus_macro)]
    pub fn ex_testlistelement_eq(lhs: &TestListElement, rhs: &TestListElement)
        -> bool {
        ::builtin::ensures(|b: bool|
                [::builtin::spec_eq(b, (::builtin::spec_eq(lhs, rhs)))]);
        lhs.eq(rhs)
    }
    #[verus::internal(verus_macro)]
    impl CloneProof for TestListElement {
        #[verus::internal(verus_macro)]
        fn clone_provable(&self) -> TestListElement {
            ::builtin::ensures(|res: TestListElement|
                    [::builtin::spec_eq(*self, res)]);
            self.clone()
        }
    }
    #[verus::internal(verus_macro)]
    impl EqProof for TestListElement {
        #[verus::internal(verus_macro)]
        fn eq_provable(&self, other: &Self) -> bool {
            ::builtin::ensures(|b: bool|
                    [::builtin::spec_eq(b, (::builtin::spec_eq(self, other)))]);
            self.eq(other)
        }
    }
    impl PmCopy for TestListElement {}
    #[automatically_derived]
    impl ::core::marker::Copy for TestListElement { }
    #[automatically_derived]
    impl ::core::fmt::Debug for TestListElement {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(f,
                "TestListElement", "val", &self.val, "start", &self.start,
                "end", &&self.end)
        }
    }
    #[verus::internal(verus_macro)]
    impl LogicalRange for TestListElement {
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_start(&self) -> usize { self.start }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn spec_end(&self) -> usize { self.end }
        #[verus::internal(verus_macro)]
        fn start(&self) -> usize { self.start }
        #[verus::internal(verus_macro)]
        fn end(&self) -> usize { self.end }
    }
    #[verifier::external_body]
    #[verus::internal(verus_macro)]
    fn print_message(msg: &'static str) {
        { ::std::io::_print(format_args!("{0}\n", msg)); };
    }
    #[verifier::external_body]
    #[verus::internal(verus_macro)]
    fn print_result(msg: &'static str, value: u32) {
        { ::std::io::_print(format_args!("{0}: {1}\n", msg, value)); };
    }
    #[verifier::external_body]
    #[verus::internal(verus_macro)]
    fn remove_file(name: &str) { let _ = std::fs::remove_file(name); }
    #[verus::internal(verus_macro)]
    fn create_pm_region(file_name: &str, region_size: u64)
        -> Result<FileBackedPersistentMemoryRegion, PmemError> {
        ::builtin::ensures(|result:
                    Result<FileBackedPersistentMemoryRegion, PmemError>|
                [((if let Ok(pm) = (result) { pm.inv() } else { true }))]);
        #[cfg(target_os = "linux")]
        let mut pm_region =
            FileBackedPersistentMemoryRegion::new(&file_name, region_size,
                PersistentMemoryCheck::DontCheckForPersistentMemory);
        pm_region
    }
    #[verus::internal(verus_macro)]
    pub fn test_kv_on_memory_mapped_file() -> Result<(), ()> {
        let kv_file_name = "test_kv";
        let max_keys = 16;
        let max_list_elements = 16;
        remove_file(kv_file_name);
        let kvstore_id = generate_fresh_id();
        let ps =
            SetupParameters {
                kvstore_id,
                logical_range_gaps_policy: LogicalRangeGapsPolicy::LogicalRangeGapsForbidden,
                max_keys,
                max_list_elements,
                max_operations_per_transaction: 4,
            };
        let region_size =
            match KvStore::<FileBackedPersistentMemoryRegion, TestKey,
                        TestItem, TestListElement>::space_needed_for_setup(&ps) {
                Ok(s) => s,
                Err(e) => {
                    print_message("Failed to compute space needed for setup");
                    return Err(());
                }
            };
        let mut pm =
            match create_pm_region(&kv_file_name, region_size) {
                Ok(p) => p,
                Err(e) => {
                    print_message("Failed to create file for kv store");
                    return Err(());
                }
            };

        #[verifier::proof_block]
        {

            #[verus::internal(const_header_wrapper)]
            ||
                {
                    ::builtin::assume_(vstd::std_specs::hash::obeys_key_model::<TestKey>())
                };
        };
        match KvStore::<FileBackedPersistentMemoryRegion, TestKey, TestItem,
                    TestListElement>::setup(&mut pm, &ps) {
            Ok(()) => {}
            Err(e) => {
                print_message("Failed to set up KV store");
                return Err(());
            }
        }
        let mut kv =
            match KvStore::<FileBackedPersistentMemoryRegion, TestKey,
                        TestItem, TestListElement>::start(pm, kvstore_id) {
                Ok(kv) => kv,
                Err(e) => {
                    print_message("Failed to start KV store");
                    return Err(());
                }
            };
        let key1 = TestKey { val: 0x33333333 };
        let key2 = TestKey { val: 0x44444444 };
        let item1 = TestItem { val: 0x55555555 };
        let item2 = TestItem { val: 0x66666666 };
        match kv.tentatively_create(&key1, &item1) {
            Ok(()) => {}
            Err(e) => {
                print_message("Error when creating key 1");
                return Err(());
            }
        }
        match kv.commit() {
            Ok(()) => {}
            Err(e) => {
                print_message("Error when committing");
                return Err(());
            }
        }
        let read_item1 =
            match kv.read_item(&key1) {
                Ok(i) => i,
                Err(e) => {
                    print_message("Error when reading key");
                    return Err(());
                }
            };
        runtime_assert(read_item1.val == item1.val);
        match kv.read_item(&key2) {
            Ok(i) => {
                print_message("Error: failed to fail when reading non-inserted key");
                return Err(());
            }
            Err(KvError::KeyNotFound) => {}
            Err(e) => {
                print_message("Error: got an unexpected error when reading non-inserted key");
                return Err(());
            }
        }
        print_message("All kv operations gave expected results");
        return Ok(());
    }
    #[verus::internal(verus_macro)]
    impl ReadLinearizer<TestKey, TestItem, TestListElement,
        ReadItemOp<TestKey>> for
        GhostVar<ConcurrentKvStoreView<TestKey, TestItem, TestListElement>> {
        type Completion = Self;
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn namespaces(self) -> Set<int> { Set::empty() }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn pre(self, id: int, op: ReadItemOp<TestKey>) -> bool {
            ::builtin::spec_eq(self.id(), id)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(open)]
        #[verus::internal(spec)]
        fn post(self, completion: Self, id: int, op: ReadItemOp<TestKey>,
            result: Result<TestItem, KvError>) -> bool {
            (::builtin::spec_eq(completion, self)) &&
                (op.result_valid((self.view()), result))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(returns(proof))]
        #[verus::internal(proof)]
        fn apply(#[verus::internal(proof)] self, op: ReadItemOp<TestKey>,
            result: Result<TestItem, KvError>,
            #[verus::internal(proof)] r:
                &GhostVarAuth<ConcurrentKvStoreView<TestKey, TestItem,
                TestListElement>>) -> Self::Completion {
            r.agree(&self);
            self
        }
    }
    #[verus::internal(verus_macro)]
    pub struct TestKvPermission {
        #[verus::internal(spec)]
        is_transition_allowable: ::builtin::FnSpec<(Seq<u8>, Seq<u8>), bool>,
        #[verus::internal(spec)]
        powerpm_id: int,
    }
    #[verus::internal(verus_macro)]
    impl CheckPermission<Seq<u8>> for TestKvPermission {
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        fn check_permission(&self, s1: Seq<u8>, s2: Seq<u8>) -> bool {
            (self.is_transition_allowable)(s1, s2)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        fn id(&self) -> int { self.powerpm_id }
        #[verus::internal(verus_macro)]
        #[verus::internal(proof)]
        fn apply(#[verus::internal(proof)] self,
            #[verus::internal(proof)] credit:
                vstd::invariant::OpenInvariantCredit,
            #[verus::internal(proof)] r: &mut GhostVarAuth<Seq<u8>>,
            new_state: Seq<u8>) {
            admit();
        }
    }
    #[verus::internal(verus_macro)]
    pub struct TestKvPermissionFactory {
        #[verus::internal(spec)]
        is_transition_allowable: ::builtin::FnSpec<(Seq<u8>, Seq<u8>), bool>,
        #[verus::internal(spec)]
        powerpm_id: int,
    }
    #[verus::internal(verus_macro)]
    impl PermissionFactory<Seq<u8>> for TestKvPermissionFactory {
        type Perm = TestKvPermission;
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        fn check_permission(&self, s1: Seq<u8>, s2: Seq<u8>) -> bool {
            (self.is_transition_allowable)(s1, s2)
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(returns(proof))]
        #[verus::internal(proof)]
        fn grant_permission(#[verus::internal(proof)] &self)
            -> TestKvPermission {
            ::builtin::ensures(|perm: TestKvPermission|
                    [::builtin::forall(|s1, s2|
                                    ::builtin::imply(self.check_permission(s1, s2),
                                        #[verus::internal(trigger)] perm.check_permission(s1,
                                            s2)))]);
            TestKvPermission {
                is_transition_allowable: ::builtin::closure_to_fn_spec(|s1:
                            Seq<u8>, s2: Seq<u8>|
                        (self.is_transition_allowable)(s1, s2)),
                powerpm_id: self.powerpm_id,
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(returns(proof))]
        #[verus::internal(proof)]
        fn clone(#[verus::internal(proof)] &self) -> Self {
            ::builtin::ensures(|other: Self|
                    [::builtin::forall(|s1, s2|
                                    ::builtin::imply(self.check_permission(s1, s2),
                                        #[verus::internal(trigger)] other.check_permission(s1,
                                            s2)))]);
            Self {
                is_transition_allowable: self.is_transition_allowable,
                powerpm_id: self.powerpm_id,
            }
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        fn id(&self) -> int { self.powerpm_id }
    }
    #[verus::internal(verus_macro)]
    impl TestKvPermission {
        #[verus::internal(verus_macro)]
        #[verus::internal(returns(proof))]
        #[verus::internal(proof)]
        fn new<PM, K, I, L>(powerpm_id: int) -> Self where
            PM: PersistentMemoryRegion, K: Hash + Eq + Clone + PmCopy +
            std::fmt::Debug, I: PmCopy + std::fmt::Debug, L: PmCopy +
            LogicalRange + std::fmt::Debug + Copy {
            ::builtin::ensures(|perm: Self|
                    [::builtin::spec_eq(perm.id(), powerpm_id)]);
            Self {
                is_transition_allowable: ::builtin::closure_to_fn_spec(|s1:
                            Seq<u8>, s2: Seq<u8>|
                        ::builtin::spec_eq(ConcurrentKvStore::<TestKvPermissionFactory,
                                    PM, K, I, L>::recover(s1),
                            ConcurrentKvStore::<TestKvPermissionFactory, PM, K, I,
                                    L>::recover(s2))),
                powerpm_id: powerpm_id,
            }
        }
    }
    #[verus::internal(verus_macro)]
    struct TestMutatingLinearizer<Op> where
        Op: MutatingOperation<TestKey, TestItem, TestListElement> {
        r: GhostVar<ConcurrentKvStoreView<TestKey, TestItem,
        TestListElement>>,
        #[verus::internal(spec)]
        op: Op,
        #[verus::internal(spec)]
        old_ckv: Option<ConcurrentKvStoreView<TestKey, TestItem,
        TestListElement>>,
        #[verus::internal(spec)]
        new_ckv: Option<ConcurrentKvStoreView<TestKey, TestItem,
        TestListElement>>,
        #[verus::internal(spec)]
        powerpm_id: int,
    }
    #[verus::internal(verus_macro)]
    #[verus::internal(returns(proof))]
    #[verus::internal(proof)]
    fn create_mutating_perm<Op>(op: Op,
        pm_constants: PersistentMemoryConstants, powerpm_id: int)
        -> TestKvPermission where
        Op: MutatingOperation<TestKey, TestItem, TestListElement> {
        ::builtin::ensures(|perm: TestKvPermission|
                [::builtin::spec_eq(perm.id(), powerpm_id),
                        grants_permission_to_mutate::<TestKvPermission, TestKey,
                                TestItem, TestListElement, Op,
                                ConcurrentKvStore<TestKvPermissionFactory,
                                FileBackedPersistentMemoryRegion, TestKey, TestItem,
                                TestListElement>>(perm, op, pm_constants)]);
        #[verus::internal(spec)]
        let is_transition_allowable =
            ::builtin::closure_to_fn_spec(|s1: Seq<u8>, s2: Seq<u8>|
                    {
                        ((if let Some(old_rkv) =
                                            (ConcurrentKvStore::<TestKvPermissionFactory,
                                                        FileBackedPersistentMemoryRegion, TestKey, TestItem,
                                                        TestListElement>::recover(s1)) {
                                        ((if let Some(new_rkv) =
                                                            (ConcurrentKvStore::<TestKvPermissionFactory,
                                                                        FileBackedPersistentMemoryRegion, TestKey, TestItem,
                                                                        TestListElement>::recover(s2)) {
                                                        ::builtin::exists(|result|
                                                                {

                                                                    #[verus::internal(trigger)]
                                                                    op.result_valid(ConcurrentKvStoreView::<TestKey, TestItem,
                                                                            TestListElement> {
                                                                            ps: old_rkv.ps,
                                                                            pm_constants,
                                                                            kv: old_rkv.kv,
                                                                        },
                                                                        ConcurrentKvStoreView::<TestKey, TestItem,
                                                                            TestListElement> {
                                                                            ps: new_rkv.ps,
                                                                            pm_constants,
                                                                            kv: new_rkv.kv,
                                                                        }, result)
                                                                })
                                                    } else { false }))
                                    } else { false }))
                    });
        #[verus::internal(proof)]
        let perm =
            TestKvPermission {
                is_transition_allowable,
                powerpm_id: powerpm_id,
            };
        perm
    }
    #[verus::internal(verus_macro)]
    impl<Op> MutatingLinearizer<TestKey, TestItem, TestListElement, Op> for
        TestMutatingLinearizer<Op> where
        Op: MutatingOperation<TestKey, TestItem, TestListElement> {
        type Completion = Self;
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        fn namespaces(self) -> Set<int> { Set::empty() }
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        fn pre(self, id: int, op: Op) -> bool {
            (((::builtin::spec_eq(self.r.id(), id)) &&
                                (::builtin::spec_eq(self.op, op))) &&
                        (::builtin::is_variant(self.old_ckv, "None"))) &&
                (::builtin::is_variant(self.new_ckv, "None"))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(closed)]
        #[verus::internal(spec)]
        fn post(self, complete: Self::Completion, id: int, op: Op,
            exec_result: Op::ExecResult) -> bool {
            (((::builtin::spec_eq(complete.r.id(), self.r.id())) &&
                                (::builtin::spec_eq(complete.r.id(), id))) &&
                        (::builtin::spec_eq(self.op, op))) &&
                (((if let Some(old_ckv) = (complete.old_ckv) {
                                    ((if let Some(new_ckv) = (complete.new_ckv) {
                                                    op.result_valid(old_ckv, new_ckv, exec_result)
                                                } else { false }))
                                } else { false })))
        }
        #[verus::internal(verus_macro)]
        #[verus::internal(returns(proof))]
        #[verus::internal(proof)]
        fn apply(#[verus::internal(proof)] self, op: Op,
            new_ckv:
                ConcurrentKvStoreView<TestKey, TestItem, TestListElement>,
            exec_result: Op::ExecResult,
            #[verus::internal(proof)] r:
                &mut GhostVarAuth<ConcurrentKvStoreView<TestKey, TestItem,
                TestListElement>>) -> Self::Completion {
            #[verus::internal(proof)]
            let mut mself = self;
            mself.old_ckv = Some((r.view()));
            mself.new_ckv = Some(new_ckv);
            r.update(&mut mself.r, new_ckv);
            mself
        }
    }
    #[verus::internal(verus_macro)]
    pub fn test_concurrent_kv_on_memory_mapped_file() -> Result<(), ()> {
        let kv_file_name = "test_concurrent_kv";
        let max_keys = 16;
        let max_list_elements = 16;
        remove_file(kv_file_name);
        let kvstore_id = generate_fresh_id();
        let ps =
            SetupParameters {
                kvstore_id,
                logical_range_gaps_policy: LogicalRangeGapsPolicy::LogicalRangeGapsForbidden,
                max_keys,
                max_list_elements,
                max_operations_per_transaction: 4,
            };
        let region_size =
            match ConcurrentKvStore::<TestKvPermissionFactory,
                        FileBackedPersistentMemoryRegion, TestKey, TestItem,
                        TestListElement>::space_needed_for_setup(&ps) {
                Ok(s) => s,
                Err(e) => {
                    print_message("Failed to compute space needed for setup");
                    return Err(());
                }
            };
        let mut pm =
            match create_pm_region(&kv_file_name, region_size) {
                Ok(p) => p,
                Err(e) => {
                    print_message("Failed to create file for kv store");
                    return Err(());
                }
            };

        #[verifier::proof_block]
        {

            #[verus::internal(const_header_wrapper)]
            ||
                {
                    ::builtin::assume_(vstd::std_specs::hash::obeys_key_model::<TestKey>())
                };
        };
        match ConcurrentKvStore::<TestKvPermissionFactory,
                    FileBackedPersistentMemoryRegion, TestKey, TestItem,
                    TestListElement>::setup(&mut pm, &ps) {
            Ok(()) => {}
            Err(e) => {
                print_message("Failed to set up KV store");
                return Err(());
            }
        }
        let (mut powerpm, _) =
            PoWERPersistentMemoryRegion::<FileBackedPersistentMemoryRegion>::new(pm);
        #[verus::internal(spec)]
        #[verus::internal(unwrapped_binding)]
        let mut verus_tmp;

        #[verifier::proof_block]
        { verus_tmp = powerpm.constants() };
        #[verus::internal(spec)]
        let mut pm_constants;

        #[verifier::proof_block]
        {
            #[verus::internal(spec)]
            let verus_tmp_pm_constants = verus_tmp;
            pm_constants = verus_tmp_pm_constants;
        };
        #[verus::internal(spec)]
        #[verus::internal(unwrapped_binding)]
        let mut verus_tmp;

        #[verifier::proof_block]
        {
            verus_tmp =
                ConcurrentKvStore::<TestKvPermissionFactory,
                            FileBackedPersistentMemoryRegion, TestKey, TestItem,
                            TestListElement>::recover((powerpm.view()).durable_state).unwrap()
        };
        #[verus::internal(spec)]
        let mut state;

        #[verifier::proof_block]
        {
            #[verus::internal(spec)]
            let verus_tmp_state = verus_tmp;
            state = verus_tmp_state;
        };
        #[verus::internal(spec)]
        #[verus::internal(unwrapped_binding)]
        let mut verus_tmp;

        #[verifier::proof_block]
        {
            verus_tmp =
                ::builtin::closure_to_fn_spec(|s1: Seq<u8>, s2: Seq<u8>|
                        {
                            ::builtin::spec_eq(ConcurrentKvStore::<TestKvPermissionFactory,
                                        FileBackedPersistentMemoryRegion, TestKey, TestItem,
                                        TestListElement>::recover(s1),
                                ConcurrentKvStore::<TestKvPermissionFactory,
                                        FileBackedPersistentMemoryRegion, TestKey, TestItem,
                                        TestListElement>::recover(s2))
                        })
        };
        #[verus::internal(spec)]
        let mut is_transition_allowable;

        #[verifier::proof_block]
        {
            #[verus::internal(spec)]
            let verus_tmp_is_transition_allowable:
                    ::builtin::FnSpec<(Seq<u8>, Seq<u8>), bool> = verus_tmp;
            is_transition_allowable = verus_tmp_is_transition_allowable;
        };
        #[verus::internal(proof)]
        #[verus::internal(unwrapped_binding)]
        let verus_tmp;

        #[verifier::proof_block]
        {
            verus_tmp =
                TestKvPermissionFactory {
                    is_transition_allowable,
                    powerpm_id: powerpm.id(),
                }
        };
        #[verus::internal(infer_mode)]
        let mut perm_factory;

        #[verifier::proof_block]
        {
            #[verus::internal(proof)]
            let verus_tmp_perm_factory = verus_tmp;
            perm_factory = verus_tmp_perm_factory;
        };
        let (mut ckv, verus_tmp_app_resource) =
            match ConcurrentKvStore::<TestKvPermissionFactory,
                        FileBackedPersistentMemoryRegion, TestKey, TestItem,
                        TestListElement>::start(powerpm, kvstore_id,
                    #[verifier::ghost_wrapper] ::builtin::ghost_exec(#[verifier::ghost_block_wrapped] state),
                    #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm_factory))
                {
                Ok(tup) => tup,
                Err(e) => {
                    print_message("Failed to start KV store");
                    return Err(());
                }
            };
        #[verus::internal(proof)]
        let mut app_resource;

        #[verifier::proof_block]
        { app_resource = verus_tmp_app_resource.get(); };
        let key1 = TestKey { val: 0x33333333 };
        let key2 = TestKey { val: 0x44444444 };
        let item1 = TestItem { val: 0x55555555 };
        let item2 = TestItem { val: 0x66666666 };
        #[verus::internal(spec)]
        #[verus::internal(unwrapped_binding)]
        let mut verus_tmp;

        #[verifier::proof_block]
        {
            verus_tmp =
                CreateOp::<TestKey, TestItem> { key: key1, item: item1 }
        };
        #[verus::internal(spec)]
        let mut op;

        #[verifier::proof_block]
        {
            #[verus::internal(spec)]
            let verus_tmp_op = verus_tmp;
            op = verus_tmp_op;
        };
        #[verus::internal(proof)]
        #[verus::internal(unwrapped_binding)]
        let verus_tmp;

        #[verifier::proof_block]
        {
            verus_tmp =
                create_mutating_perm::<CreateOp<TestKey,
                        TestItem>>(op, pm_constants, powerpm.id())
        };
        #[verus::internal(infer_mode)]
        let mut perm;

        #[verifier::proof_block]
        {
            #[verus::internal(proof)]
            let verus_tmp_perm = verus_tmp;
            perm = verus_tmp_perm;
        };
        #[verus::internal(proof)]
        #[verus::internal(unwrapped_binding)]
        let verus_tmp;

        #[verifier::proof_block]
        {
            verus_tmp =
                TestMutatingLinearizer::<CreateOp<TestKey,
                    TestItem>> {
                    r: app_resource,
                    op,
                    old_ckv: None,
                    new_ckv: None,
                    powerpm_id: powerpm.id(),
                }
        };
        #[verus::internal(infer_mode)]
        let mut create_linearizer;

        #[verifier::proof_block]
        {
            #[verus::internal(proof)]
            let mut verus_tmp_create_linearizer = verus_tmp;
            create_linearizer = verus_tmp_create_linearizer;
        };
        let (create_result, verus_tmp_create_linearizer) =
            ckv.create::<TestKvPermission,
                TestMutatingLinearizer<CreateOp<TestKey,
                TestItem>>>(&key1, &item1,
                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] perm),
                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] create_linearizer));
        #[verus::internal(proof)]
        let mut create_linearizer;

        #[verifier::proof_block]
        { create_linearizer = verus_tmp_create_linearizer.get(); };
        match create_result {
            Ok(()) => {}
            Err(e) => {
                print_message("Error when creating key 1");
                return Err(());
            }
        };
        #[verus::internal(proof)]
        #[verus::internal(unwrapped_binding)]
        let verus_tmp;

        #[verifier::proof_block]
        { verus_tmp = create_linearizer.r };
        #[verus::internal(infer_mode)]
        let mut app_resource;

        #[verifier::proof_block]
        {
            #[verus::internal(proof)]
            let verus_tmp_app_resource = verus_tmp;
            app_resource = verus_tmp_app_resource;
        };
        let (read_item_result, verus_tmp_app_resource) =
            ckv.read_item::<GhostVar<ConcurrentKvStoreView<TestKey, TestItem,
                TestListElement>>>(&key1,
                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] app_resource));
        #[verus::internal(proof)]
        let mut app_resource;

        #[verifier::proof_block]
        { app_resource = verus_tmp_app_resource.get(); };
        let read_item1 =
            match read_item_result {
                Ok(i) => i,
                Err(e) => {
                    print_message("Error when reading key");
                    return Err(());
                }
            };
        if read_item1.val != item1.val {
                print_message("ERROR: Read incorrect value");
                return Err(());
            }
        print_message("SUCCESS: Read correct value");
        let (read_item_result, verus_tmp_app_resource) =
            ckv.read_item::<GhostVar<ConcurrentKvStoreView<TestKey, TestItem,
                TestListElement>>>(&key2,
                #[verifier::ghost_wrapper] ::builtin::tracked_exec(#[verifier::tracked_block_wrapped] app_resource));
        #[verus::internal(proof)]
        let mut app_resource;

        #[verifier::proof_block]
        { app_resource = verus_tmp_app_resource.get(); };
        match read_item_result {
            Ok(i) => {
                print_message("Error: failed to fail when reading non-inserted key");
                return Err(());
            }
            Err(KvError::KeyNotFound) => {}
            Err(e) => {
                print_message("Error: got an unexpected error when reading non-inserted key");
                return Err(());
            }
        };
        print_message("All kv operations gave expected results");
        return Ok(());
    }
}
use testkv_v::*;
mod tests {
    use super::*;
}
#[allow(dead_code)]
#[verus::internal(verus_macro)]
fn main() {}
